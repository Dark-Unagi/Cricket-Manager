<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cricket Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-button.active { 
            background-color: #5D5CDE; 
            color: white; 
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
    <!-- Header -->
    <div class="bg-green-600 dark:bg-green-700 text-white p-4 shadow-lg">
        <div class="flex justify-between items-center">
            <div class="flex gap-2">
                <button onclick="showResetConfirmation()" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                    üîÑ New Game
                </button>
                <button onclick="unlockNationalCupTester()" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                    üß™ Test National Cup
                </button>
            </div>
            <div class="flex-1 text-center">
                <h1 class="text-2xl font-bold">Cricket Manager</h1>
                <div class="mt-2">
                    <span class="text-sm">Local Club Level</span> | 
                    <button onclick="showFinancialModal()" class="text-sm hover:bg-white hover:bg-opacity-20 px-2 py-1 rounded transition-colors">
                        Budget: $<span id="budget">50000</span>
                    </button>
                </div>
            </div>
            <div class="text-right">
                <div class="text-sm opacity-75">Season <span id="season-counter">1</span></div>
                <button onclick="showFinancialModal()" class="text-xs hover:bg-white hover:bg-opacity-20 px-2 py-1 rounded transition-colors">
                    üí∞ Finances
                </button>
            </div>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="bg-gray-100 dark:bg-gray-800 flex border-b border-gray-200 dark:border-gray-700">
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium border-r border-gray-200 dark:border-gray-700 active" onclick="showTab('roster')">
            Roster
        </button>
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium border-r border-gray-200 dark:border-gray-700" onclick="showTab('market')">
            Market
        </button>
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium border-r border-gray-200 dark:border-gray-700" onclick="showTab('training')">
            Training
        </button>
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium border-r border-gray-200 dark:border-gray-700" onclick="showTab('game')">
            Game
        </button>
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium" onclick="showTab('league')">
            League
        </button>
    </div>

    <!-- Tab Contents -->
    <div class="p-4">
        <!-- Roster Tab -->
        <div id="roster-tab" class="tab-content active">
            <h2 class="text-xl font-bold mb-4">Team Roster (<span id="roster-count">15</span>/20)</h2>
            
            <!-- Team Name Editor -->
            <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg border mb-4">
                <label class="block text-sm font-medium mb-2">Team Name:</label>
                <input type="text" id="team-name-input" value="Your Team" onchange="updateTeamName()" 
                       class="w-full text-base p-2 border rounded dark:bg-gray-700 dark:border-gray-600" 
                       placeholder="Enter your team name...">
            </div>
            
            <!-- Filter Buttons -->
            <div class="flex flex-wrap gap-2 mb-4">
                <button onclick="filterPlayers('all')" class="filter-btn bg-blue-500 text-white px-3 py-1 rounded text-sm">All</button>
                <button onclick="filterPlayers('Batter')" class="filter-btn bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded text-sm">Batters</button>
                <button onclick="filterPlayers('Bowler')" class="filter-btn bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded text-sm">Bowlers</button>
                <button onclick="filterPlayers('All-rounder')" class="filter-btn bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded text-sm">All-rounders</button>
            </div>

            <!-- Player List -->
            <div id="player-list" class="space-y-3">
                <!-- Players will be generated here -->
            </div>
        </div>

        <!-- Market Tab -->
        <div id="market-tab" class="tab-content">
            <h2 class="text-xl font-bold mb-4">Transfer Market</h2>
            
            <!-- Market Availability Check -->
            <div id="market-unavailable" class="text-center text-gray-500 mt-8" style="display: none;">
                <div class="text-4xl mb-4">üîí</div>
                <h3 class="text-lg font-bold mb-2">Market Unavailable</h3>
                <p>The transfer market is only available during:</p>
                <p class="text-sm mt-2">‚Ä¢ National Cup ‚Ä¢ World Cup ‚Ä¢ Test World Series</p>
                <p class="text-sm mt-4">Complete the Local Cup to unlock the transfer market!</p>
            </div>
            
            <!-- Market Available Content -->
            <div id="market-available" class="space-y-6">
                
                <!-- Scout Management Section -->
                <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg border">
                    <h3 class="text-lg font-bold text-blue-800 dark:text-blue-200 mb-4">üïµÔ∏è Scout Management</h3>
                    
                    <!-- Active Scouts -->
                    <div class="mb-4">
                        <h4 class="font-medium mb-2">Your Scouts:</h4>
                        <div id="active-scouts-list" class="space-y-2 mb-4">
                            <!-- Active scouts will be displayed here -->
                        </div>
                        
                        <!-- Scout Actions -->
                        <div class="flex flex-wrap gap-2">
                            <button onclick="showHireScoutModal()" class="px-3 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded text-sm">
                                üìã Hire Scout
                            </button>
                            <button onclick="sendScoutsOut()" id="send-scouts-btn" class="px-3 py-2 bg-green-500 text-white hover:bg-green-600 rounded text-sm">
                                üîç Send Scouts Out ($500)
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Scout Reports Section -->
                <div class="bg-green-50 dark:bg-green-900 p-4 rounded-lg border">
                    <h3 class="text-lg font-bold text-green-800 dark:text-green-200 mb-4">üìä Scout Reports</h3>
                    
                    <div id="scout-reports-list" class="space-y-3">
                        <!-- Scout reports will be displayed here -->
                    </div>
                    
                    <div id="no-scout-reports" class="text-center text-gray-500 py-4">
                        <p>No scout reports available.</p>
                        <p class="text-sm mt-1">Hire scouts and send them out to discover talent!</p>
                    </div>
                </div>
                
                <!-- Contract Negotiations Section -->
                <div class="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-lg border">
                    <h3 class="text-lg font-bold text-yellow-800 dark:text-yellow-200 mb-4">üíº Contract Negotiations</h3>
                    
                    <div id="contract-negotiations-list" class="space-y-3">
                        <!-- Active contract negotiations will be displayed here -->
                    </div>
                    
                    <div id="no-negotiations" class="text-center text-gray-500 py-4">
                        <p>No active contract negotiations.</p>
                        <p class="text-sm mt-1">Make offers to players from scout reports!</p>
                    </div>
                </div>
                
                <!-- Free Agency Pool -->
                <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg border">
                    <h3 class="text-lg font-bold text-gray-800 dark:text-gray-200 mb-4">üèÉ Free Agency Pool</h3>
                    
                    <div class="mb-3">
                        <p class="text-sm text-gray-600 dark:text-gray-400">
                            Players released by other teams. Lower quality but immediately available.
                        </p>
                    </div>
                    
                    <div id="free-agents-list" class="space-y-2">
                        <!-- Free agents will be displayed here -->
                    </div>
                    
                    <div id="no-free-agents" class="text-center text-gray-500 py-4">
                        <p>No free agents available.</p>
                        <p class="text-sm mt-1">Check back after other teams release players!</p>
                    </div>
                </div>
                
                <!-- Transfer Window Status -->
                <div class="bg-orange-50 dark:bg-orange-900 p-3 rounded border">
                    <div class="flex items-center justify-between">
                        <div>
                            <h4 class="font-medium text-orange-800 dark:text-orange-200">Transfer Window Status</h4>
                            <p id="transfer-window-status" class="text-sm text-orange-600 dark:text-orange-400">
                                Open - You can make contract offers
                            </p>
                        </div>
                        <div class="text-2xl">üìÖ</div>
                    </div>
                </div>
                
            </div>
        </div>

        <!-- Training Tab -->
        <div id="training-tab" class="tab-content">
            <h2 class="text-xl font-bold mb-4">Training Center</h2>
            
            <!-- Training Information Panel -->
            <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg border mb-6">
                <h3 class="text-lg font-bold mb-2 text-blue-800 dark:text-blue-200">üèÉ Training System</h3>
                <div class="text-sm text-blue-700 dark:text-blue-300 space-y-1">
                    <p>‚Ä¢ <strong>Gradual Growth:</strong> Players improve slowly over 2-3 games after training</p>
                    <p>‚Ä¢ <strong>Increasing Costs:</strong> Each training session costs 50% more than the last</p>
                    <p>‚Ä¢ <strong>Individual Limits:</strong> Every player has natural talent ceilings</p>
                    <p>‚Ä¢ <strong>Specialization:</strong> Focus on key skills to build world-class players</p>
                </div>
            </div>
            
            <!-- Player Selection for Training -->
            <div class="mb-6">
                <label class="block text-lg font-bold mb-3">Select Player to Train:</label>
                <select id="training-player-selector" onchange="selectPlayerForTraining()" class="w-full text-base p-3 border rounded-lg dark:bg-gray-700 dark:border-gray-600">
                    <option value="">Choose a player...</option>
                </select>
            </div>
            
            <!-- Training Overview Panel (Default View) -->
            <div id="training-overview-panel" class="bg-gray-50 dark:bg-gray-800 rounded-lg p-6 border">
                <div class="text-center mb-6">
                    <h3 class="text-xl font-bold text-green-600 dark:text-green-400 mb-2">üéØ Training in Progress</h3>
                    <p class="text-sm text-gray-600 dark:text-gray-400">Overview of all active training sessions</p>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Batting Training Overview -->
                    <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-blue-600 dark:text-blue-400 mb-3 text-center">üèè Batting Training</h4>
                        <div id="batting-training-overview" class="space-y-2">
                            <!-- Will be populated with active batting training -->
                        </div>
                    </div>
                    
                    <!-- Bowling Training Overview -->
                    <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-red-600 dark:text-red-400 mb-3 text-center">‚öæ Bowling Training</h4>
                        <div id="bowling-training-overview" class="space-y-2">
                            <!-- Will be populated with active bowling training -->
                        </div>
                    </div>
                    
                    <!-- Fielding & Specialist Training Overview -->
                    <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-green-600 dark:text-green-400 mb-3 text-center">ü•Ö Fielding & Specialist</h4>
                        <div id="fielding-training-overview" class="space-y-2">
                            <!-- Will be populated with active fielding training -->
                        </div>
                    </div>
                </div>
                
                <div id="no-active-training" class="text-center text-gray-500 mt-6" style="display: none;">
                    <p class="text-lg mb-2">No training sessions active</p>
                    <p class="text-sm">Select a player above to start training</p>
                </div>
            </div>

            <!-- Selected Player Training Panel -->
            <div id="player-training-panel" class="bg-gray-50 dark:bg-gray-800 rounded-lg p-6 border" style="display: none;">
                <div class="flex justify-between items-start mb-4">
                    <div>
                        <h3 id="training-player-name" class="text-xl font-bold">Player Name</h3>
                        <p id="training-player-type" class="text-sm text-gray-600 dark:text-gray-400">Player Type</p>
                    </div>
                    <div class="text-right">
                        <p class="text-sm text-gray-600 dark:text-gray-400">Age: <span id="training-player-age">25</span></p>
                        <p class="text-sm text-gray-600 dark:text-gray-400">Games: <span id="training-player-games">15</span></p>
                    </div>
                </div>
                
                <!-- Active Training Queue -->
                <div id="training-queue-section" class="mb-6" style="display: none;">
                    <h4 class="font-bold text-green-600 dark:text-green-400 mb-2">üéØ Active Training</h4>
                    <div id="training-queue-list" class="space-y-2">
                        <!-- Active training items will appear here -->
                    </div>
                </div>
                
                <!-- Training Skills Grid -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    
                    <!-- Batting Training -->
                    <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-blue-600 dark:text-blue-400 mb-3">üèè Batting Training</h4>
                        <div class="space-y-3">
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Defense Training</span>
                                    <span id="defense-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">45/85</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Reduces dismissal chance, improves consistency</p>
                                <div class="flex justify-between items-center">
                                    <span id="defense-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('battingDefense')" id="defense-btn" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Aggression Training</span>
                                    <span id="aggression-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">32/78</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Increases boundary hitting, higher strike rates</p>
                                <div class="flex justify-between items-center">
                                    <span id="aggression-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('battingAggression')" id="aggression-btn" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Consistency Training</span>
                                    <span id="consistency-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">28/92</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">More predictable scores, fewer low scores</p>
                                <div class="flex justify-between items-center">
                                    <span id="consistency-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('battingConsistency')" id="consistency-btn" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                    
                    <!-- Bowling Training -->
                    <div id="bowling-training-section" class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-red-600 dark:text-red-400 mb-3">‚öæ Bowling Training</h4>
                        <div class="space-y-3">
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Defensive Bowling</span>
                                    <span id="bowl-defense-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">35/71</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Limits runs, fewer extras (wides/no-balls)</p>
                                <div class="flex justify-between items-center">
                                    <span id="bowl-defense-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('bowlingDefense')" id="bowl-defense-btn" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Aggressive Bowling</span>
                                    <span id="bowl-aggression-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">41/66</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Takes more wickets, may concede more runs</p>
                                <div class="flex justify-between items-center">
                                    <span id="bowl-aggression-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('bowlingAggression')" id="bowl-aggression-btn" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Bowling Consistency</span>
                                    <span id="bowl-consistency-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">29/89</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Follows captain's plans, balanced approach</p>
                                <div class="flex justify-between items-center">
                                    <span id="bowl-consistency-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('bowlingConsistency')" id="bowl-consistency-btn" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                    
                    <!-- Fielding Training -->
                    <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-green-600 dark:text-green-400 mb-3">ü•Ö Fielding Training</h4>
                        <div class="space-y-3">
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Catching Practice</span>
                                    <span id="catching-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">33/75</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Fewer dropped catches, helps bowlers take wickets</p>
                                <div class="flex justify-between items-center">
                                    <span id="catching-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$300</span>
                                    <button onclick="startTraining('fieldingCatching')" id="catching-btn" class="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Agility Training</span>
                                    <span id="agility-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">27/81</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Better ground fielding, more run-outs</p>
                                <div class="flex justify-between items-center">
                                    <span id="agility-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$300</span>
                                    <button onclick="startTraining('fieldingAgility')" id="agility-btn" class="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                    
                    <!-- Specialist Training -->
                    <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-purple-600 dark:text-purple-400 mb-3">‚≠ê Specialist Training</h4>
                        <div class="space-y-3">
                            
                            <!-- Wicket-Keeping Training -->
                            <div id="wicketkeeping-training" class="training-skill-item" style="display: none;">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Wicket-Keeping</span>
                                    <span id="wicketkeeping-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">0/0</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Stops byes, stumping chances, catching edges</p>
                                <div class="flex justify-between items-center">
                                    <span id="wicketkeeping-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$400</span>
                                    <button onclick="startTraining('wicketKeeping')" id="wicketkeeping-btn" class="px-3 py-1 bg-purple-500 text-white rounded text-sm hover:bg-purple-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Captaincy Training -->
                            <div id="captaincy-training" class="training-skill-item" style="display: none;">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Captaincy</span>
                                    <span id="captaincy-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">0/0</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Better bowling changes, field placements</p>
                                <div class="flex justify-between items-center">
                                    <span id="captaincy-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$600</span>
                                    <button onclick="startTraining('captaincy')" id="captaincy-btn" class="px-3 py-1 bg-purple-500 text-white rounded text-sm hover:bg-purple-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Message for non-specialists -->
                            <div id="no-specialist-training" class="text-center text-gray-500 py-4">
                                <p class="text-sm">This player is not a wicket-keeper or captain.</p>
                                <p class="text-xs mt-1">Assign specialist roles in the Roster tab first.</p>
                            </div>
                            
                        </div>
                    </div>
                    
                </div>
            </div>
        </div>

        <!-- Game Tab -->
        <div id="game-tab" class="tab-content">
            <h2 id="competition-title" class="text-xl font-bold mb-4">Local Cup</h2>
            
            <!-- Competition Selection -->
            <div class="grid grid-cols-2 gap-2 mb-6">
                <button id="local-btn" onclick="selectCompetition('local')" class="competition-btn bg-green-500 text-white py-2 px-3 rounded text-sm font-medium">
                    Local Cup
                </button>
                <button id="national-btn" onclick="selectCompetition('national')" disabled class="competition-btn bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 py-2 px-3 rounded text-sm font-medium cursor-not-allowed">
                    National Cup
                </button>
                <button id="worldcup-btn" onclick="selectCompetition('worldcup')" disabled class="competition-btn bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 py-2 px-3 rounded text-sm font-medium cursor-not-allowed">
                    World Cup
                </button>
                <button id="test-btn" onclick="selectCompetition('test')" disabled class="competition-btn bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 py-2 px-3 rounded text-sm font-medium cursor-not-allowed">
                    Test World Series
                </button>
            </div>
            
            <!-- Match Day Report -->
            <div id="match-day-report" class="bg-gradient-to-r from-green-50 to-blue-50 dark:from-green-900 dark:to-blue-900 p-4 rounded-lg border mb-6">
                <h3 class="text-lg font-bold mb-3 text-center">üìä Match Day Report</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div class="bg-white dark:bg-gray-800 p-3 rounded">
                        <h4 class="font-medium mb-2">üèüÔ∏è Venue Details</h4>
                        <p class="text-sm"><strong>Opponent:</strong> <span id="opponent-name">Thunder Hawks</span></p>
                        <p class="text-sm"><strong>Venue:</strong> <span id="home-away">Home Match</span></p>
                        <p class="text-sm text-green-600 dark:text-green-400 text-xs mt-1" id="home-advantage">üè† Home crowd advantage: +5% motivation boost</p>
                    </div>
                    
                    <div class="bg-white dark:bg-gray-800 p-3 rounded">
                        <h4 class="font-medium mb-2">üèè Pitch Conditions</h4>
                        <p class="text-sm"><strong>Pitch Type:</strong> <span id="pitch-type">Fast Pitch</span></p>
                        <p class="text-sm"><strong>Weather:</strong> <span id="weather-conditions">Sunny & Clear</span></p>
                        <p class="text-sm text-blue-600 dark:text-blue-400 text-xs mt-1" id="conditions-effect">‚ö° Favors fast bowlers and power hitters</p>
                    </div>
                </div>
                
                <div class="text-center text-xs text-gray-600 dark:text-gray-400">
                    Next scheduled match for your team
                </div>
            </div>
            
            <!-- Match Control Buttons -->
            <div class="text-center mb-6">
                <button id="start-match-btn" onclick="startMatch()" class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg text-lg font-medium">
                    üèè Start Match
                </button>
                <button id="auto-complete-btn" onclick="autoCompleteMatch()" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg text-lg font-medium ml-4" style="display: none;">
                    ‚ö° Auto-Complete
                </button>
            </div>
            
            <!-- Live Match Details -->
            <div id="live-match-details" class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg border mb-6" style="display: none;">
                <h3 class="text-lg font-bold mb-3 text-center">üî¥ Live Match</h3>
                <div id="match-commentary" class="space-y-2 max-h-64 overflow-y-auto">
                    <!-- Live match updates will appear here -->
                </div>
            </div>
            
            <!-- Team Selection -->
            <div class="mb-6">
                <h3 class="text-lg font-bold mb-3">üèè Team Selection</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Your Team XI -->
                    <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg">
                        <h4 class="font-medium mb-3 text-blue-800 dark:text-blue-200">Your Team XI</h4>
                        <div id="your-team-xi" class="space-y-2">
                            <!-- Will be populated by selectPlayerForXI -->
                        </div>
                        <div class="mt-3">
                            <label class="block text-sm font-medium mb-2">Select players from roster:</label>
                            <select id="player-selector" onchange="selectPlayerForXI()" class="w-full text-base p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
                                <option value="">Choose a player...</option>
                                <!-- Will be populated with available players -->
                            </select>
                        </div>
                    </div>
                    
                    <!-- Opponent XI -->
                    <div class="bg-red-50 dark:bg-red-900 p-4 rounded-lg">
                        <h4 class="font-medium mb-3 text-red-800 dark:text-red-200"><span id="opponent-team-name">Thunder Hawks</span> XI</h4>
                        <div id="opponent-team-xi" class="space-y-2">
                            <!-- Will be populated with opponent's team -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Team Strategy -->
            <div class="mb-6">
                <h3 class="text-lg font-bold mb-3">üìã Team Strategy</h3>
                
                <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">Batting Strategy:</label>
                            <select id="batting-strategy" class="w-full text-base p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
                                <option value="conservative">Take it slow, don't get out</option>
                                <option value="aggressive">Hit hard, score fast</option>
                                <option value="balanced">Play safe but look for runs</option>
                                <option value="captain-choice">Let captain decide</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium mb-2">Toss Strategy:</label>
                            <select id="toss-strategy" class="w-full text-base p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
                                <option value="bat-first">If we win toss, we bat</option>
                                <option value="field-first">If we win toss, we field</option>
                                <option value="captain-choice">Let captain decide</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- League Tab -->
        <div id="league-tab" class="tab-content">
            <h2 id="league-title" class="text-xl font-bold mb-4">Local Cup Standings</h2>
            
            <!-- League Table -->
            <div class="bg-gray-50 dark:bg-gray-800 rounded-lg overflow-hidden mb-6">
                <div class="grid grid-cols-6 gap-2 p-3 bg-gray-200 dark:bg-gray-700 text-xs font-medium">
                    <div>Team</div>
                    <div class="text-center">P</div>
                    <div class="text-center">W</div>
                    <div class="text-center">L</div>
                    <div class="text-center">Pts</div>
                    <div class="text-center">NRR</div>
                </div>
                <div id="standings-list">
                    <!-- Standings will be generated here -->
                </div>
            </div>
            
            <!-- Season Schedule -->
            <div class="bg-gray-50 dark:bg-gray-800 rounded-lg overflow-hidden mb-6">
                <div class="flex justify-between items-center p-3 bg-gray-200 dark:bg-gray-700">
                    <h3 class="text-lg font-bold">Season Schedule</h3>
                    <button onclick="toggleSchedule()" id="schedule-toggle" class="text-sm px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">
                        Show Schedule
                    </button>
                </div>
                <div id="season-schedule" class="p-4 space-y-4" style="display: none;">
                    <!-- Schedule will be generated here -->
                </div>
            </div>

            <!-- Recent Results -->
            <h3 class="text-lg font-bold mb-3">Recent Results</h3>
            <div id="recent-results" class="space-y-2">
                <!-- Recent match results will show here -->
            </div>
        </div>
    </div>

    <script>
        // Dark mode support
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Game state
        const gameState = {
            budget: 50000,
            level: 'Local Club',
            teamName: 'Your Team',
            players: [],
            currentFilter: 'all',
            currentCompetition: 'local',
            competitions: {
                local: { unlocked: true, completed: false },
                national: { unlocked: false, completed: false },
                worldcup: { unlocked: false, completed: false },
                test: { unlocked: false, completed: false }
            },
            aiTeams: [],
            leagueStandings: [],
            recentResults: [],
            // Fan base and income system
            fanBase: 15, // Starting fan base (secret from player)
            totalIncome: 0, // Total income earned
            winStreak: 0, // Current win streak
            lossStreak: 0, // Current loss streak
            // Financial tracking system
            finances: {
                currentSeason: {
                    fanIncome: { home: 0, away: 0 },
                    training: { batting: 0, bowling: 0, fielding: 0, specialist: 0 },
                    transfers: 0 // For future player purchases
                },
                previousSeason: {
                    fanIncome: { home: 0, away: 0 },
                    training: { batting: 0, bowling: 0, fielding: 0, specialist: 0 },
                    transfers: 0
                },
                seasonHistory: [] // Array of end-of-season budget totals
            }
        };

        // Player class for generating cricketers
        class CricketPlayer {
            constructor(type, level = 'local') {
                this.name = this.generateName();
                this.age = Math.floor(Math.random() * 15) + 18; // 18-32
                this.type = type;
                this.gamesPlayed = Math.floor(Math.random() * 50);
                this.isWicketKeeper = Math.random() < 0.1; // 10% chance
                this.isInjured = false;
                this.injuryDaysLeft = 0;
                
                // CRITICAL: Determine if this is a star player based on level
                this.isStar = this.determineStarStatus(level);
                
                // Generate stats based on level and type
                this.generateStats(level);
                
                // Generate hidden traits
                this.generateHiddenTraits();
                
                // Assign bowling type for bowlers and all-rounders
                if (type === 'Bowler' || type === 'All-rounder') {
                    this.bowlingType = this.generateBowlingType();
                }
            }
            
            determineStarStatus(level) {
                // Star player chances based on competition level
                const starChances = {
                    'local': 0.05,     // 5% chance - very rare at local level
                    'national': 0.15,  // 15% chance - more common at national level
                    'worldcup': 0.30,  // 30% chance - many stars at world level
                    'test': 0.35       // 35% chance - elite level has many stars
                };
                
                const isRegularStar = Math.random() < (starChances[level] || 0.05);
                
                // CRITICAL: Super Star determination for World Cup and above
                if (level === 'worldcup' || level === 'test') {
                    const superStarChance = level === 'worldcup' ? 0.08 : 0.12; // 8% worldcup, 12% test
                    const isSuperStar = Math.random() < superStarChance;
                    
                    if (isSuperStar) {
                        this.isSuperStar = true;
                        return true; // Super Stars are also regular stars
                    }
                }
                
                this.isSuperStar = false;
                return isRegularStar;
            }
            
            generateName() {
                const firstNames = ['Alex', 'Ben', 'Chris', 'Dan', 'Ethan', 'Felix', 'George', 'Harry', 'Ian', 'Jack', 
                                 'Kyle', 'Luke', 'Matt', 'Nick', 'Owen', 'Paul', 'Quinn', 'Ryan', 'Sam', 'Tom',
                                 'Aaron', 'Blake', 'Connor', 'David', 'Eric', 'Frank', 'Glen', 'Henry', 'Isaac', 'James'];
                const lastNames = ['Smith', 'Jones', 'Brown', 'Wilson', 'Taylor', 'Clark', 'White', 'Hall', 'Green', 'Adams',
                                 'Baker', 'Cooper', 'Evans', 'Fisher', 'Gray', 'Hill', 'King', 'Lee', 'Miller', 'Moore',
                                 'Parker', 'Roberts', 'Scott', 'Turner', 'Walker', 'Young', 'Allen', 'Bell', 'Carter', 'Davis'];
                
                return firstNames[Math.floor(Math.random() * firstNames.length)] + ' ' + 
                       lastNames[Math.floor(Math.random() * lastNames.length)];
            }
            
            generateStats(level) {
                // Base stats influenced by level (local = lower, higher levels = better)
                const levelMultiplier = level === 'local' ? 0.6 : level === 'national' ? 0.85 : level === 'worldcup' ? 1.1 : 1.3;
                
                // CRITICAL: Adjust for star players with more substantial bonuses
                const starMultiplier = this.isStar ? 1.6 : 1.0; // Increased from 1.4 to 1.6
                const effectiveMultiplier = levelMultiplier * starMultiplier;
                
                // Games played varies by level
                this.gamesPlayed = level === 'local' ? 
                    Math.floor(Math.random() * 16) + 10 : // 10-25 games local
                    level === 'national' ? 
                    Math.floor(Math.random() * 21) + 30 : // 30-50 games national
                    Math.floor(Math.random() * 31) + 50; // 50-80 games international
                
                // ALL PLAYERS HAVE BATTING STATS (since all players must bat)
                // Generate realistic batting average for level with star boost
                const baseAverage = level === 'local' ? 
                    (15 + Math.random() * 25) : // 15-40 for local
                    level === 'national' ? 
                    (20 + Math.random() * 30) : // 20-50 for national
                    (25 + Math.random() * 35); // 25-60 for international
                
                this.battingAverage = Math.floor(baseAverage * effectiveMultiplier);
                
                // Calculate total runs based on average and games (with some variance)
                const runsVariance = 0.8 + Math.random() * 0.4; // 0.8 to 1.2 multiplier
                this.totalRuns = Math.floor(this.battingAverage * this.gamesPlayed * runsVariance);
                
                // Strike rate with star boost
                this.strikeRate = Math.floor((60 + Math.random() * 80) * effectiveMultiplier);
                
                // High score - star players have much better highs within +/- 5 runs of their average
                if (this.isStar) {
                    // Star players typically hit within +/- 5 runs of their average high scores
                    const starHighScoreBase = this.battingAverage + Math.random() * 10 - 5; // +/- 5 variance
                    this.highScore = Math.max(this.battingAverage + 10, starHighScoreBase);
                } else {
                    // Regular players have more unpredictable high scores
                    const highScoreMultiplier = 1.5 + Math.random() * 1.5; // 1.5-3x average
                    this.highScore = Math.min(
                        Math.floor(this.battingAverage * highScoreMultiplier + Math.random() * 20),
                        level === 'local' ? 180 : level === 'national' ? 220 : 300
                    );
                }
                
                // 50s and 100s based on total runs and high score
                this.fifties = Math.floor(this.totalRuns / (this.battingAverage * 8)); // Rough estimate
                this.hundreds = Math.floor(this.totalRuns / (this.battingAverage * 20)); // Even rougher
                
                // Star players get more 50s and 100s
                if (this.isStar) {
                    this.fifties = Math.floor(this.fifties * 1.3);
                    this.hundreds = Math.floor(this.hundreds * 1.5);
                }
                
                // Adjust for high score - can't have hundreds if high score < 100
                if (this.highScore < 100) {
                    this.hundreds = 0;
                    this.fifties = Math.min(this.fifties, Math.floor(this.totalRuns / (this.battingAverage * 12)));
                }
                if (this.highScore < 50) {
                    this.fifties = 0;
                }
                
                // BOWLING STATS (only for bowlers and all-rounders)
                if (this.type === 'Bowler' || this.type === 'All-rounder') {
                    // Economy rate - star players have significantly lower economies (5+ lower wickets regularly)
                    let baseEconomy = 4.0 + Math.random() * 4.0 + (2.0 - levelMultiplier * 2);
                    if (this.isStar) {
                        baseEconomy = Math.max(2.5, baseEconomy - 1.5); // Star bowlers 1.5 runs per over better
                    }
                    this.economyRate = Math.max(2.5, baseEconomy);
                    
                    // Total wickets - star players take 5+ wickets regularly and have better economy
                    const wicketsPerGame = level === 'local' ? 
                        (1 + Math.random() * 2.5) * effectiveMultiplier : 
                        (1.5 + Math.random() * 3) * effectiveMultiplier;
                    this.totalWickets = Math.floor(wicketsPerGame * this.gamesPlayed);
                    
                    // Star players have much better wicket-taking ability
                    if (this.isStar) {
                        this.totalWickets = Math.floor(this.totalWickets * 1.4);
                    }
                    
                    // Best bowling figures - star players regularly get 5+ wickets
                    let bestWickets;
                    if (this.isStar) {
                        bestWickets = Math.min(
                            Math.floor(Math.random() * 4) + 5, // 5-8 wickets for stars
                            Math.min(8, this.totalWickets)
                        );
                    } else {
                        bestWickets = Math.min(
                            Math.floor(Math.random() * 4) + 3, // 3-6 wickets for regular players
                            Math.min(7, this.totalWickets)
                        );
                    }
                    
                    // Calculate realistic runs for best bowling (good bowling performance)
                    const runsPerWicket = this.economyRate * 3 + Math.random() * 10; // 3 overs per wicket + variance
                    const bestRuns = Math.floor(bestWickets * runsPerWicket * 0.7); // 30% better than average
                    this.bestBowling = `${bestWickets}/${bestRuns}`;
                    
                    // 5-wicket hauls - star players get them much more often
                    if (this.isStar) {
                        this.fiveWicketHauls = bestWickets >= 5 ? Math.floor(this.totalWickets / 15) : 0; // More frequent for stars
                    } else {
                        this.fiveWicketHauls = bestWickets >= 5 ? Math.floor(this.totalWickets / 25) : 0;
                    }
                    
                    this.tenWicketHauls = 0; // Very rare in limited overs cricket
                    
                    // For longer format cricket, 10-wicket hauls might happen
                    if (level !== 'local' && this.totalWickets > 50) {
                        this.tenWicketHauls = Math.floor(this.totalWickets / 80);
                    }
                }
            }
            
            generateHiddenTraits() {
                this.hiddenTraits = [];
                
                // 70% chance of no trait, 25% chance of 1 trait, 5% chance of 2 traits
                const traitCount = Math.random() < 0.7 ? 0 : Math.random() < 0.95 ? 1 : 2;
                
                const negativeTraits = ['Bad Run Calling', 'Dropsies', 'Wild Balls', 'Injury Prone'];
                const positiveTraits = ['Rock Solid', 'Big Hitter', 'Fast Pitch Specialist', 'Slow Pitch Specialist', 
                                      'Bouncy Pitch Specialist', 'Spin Specialist', 'Pace Specialist', 'Great Fielder'];
                
                for (let i = 0; i < traitCount; i++) {
                    const isPositive = Math.random() < 0.6; // 60% chance positive trait
                    const traits = isPositive ? positiveTraits : negativeTraits;
                    const trait = traits[Math.floor(Math.random() * traits.length)];
                    
                    if (!this.hiddenTraits.includes(trait)) {
                        this.hiddenTraits.push(trait);
                    }
                }
                
                // Initialize training system
                this.initializeTrainingSystem();
            }
            
            initializeTrainingSystem() {
                // Training skills (0-100 scale, start at 20-40 for amateurs)
                this.trainingSkills = {
                    // Batting skills
                    battingDefense: Math.floor(Math.random() * 20) + 20,    // 20-39
                    battingAggression: Math.floor(Math.random() * 20) + 20, // 20-39
                    battingConsistency: Math.floor(Math.random() * 20) + 20, // 20-39
                    
                    // Bowling skills (only for bowlers/all-rounders)
                    bowlingDefense: this.type !== 'Batter' ? Math.floor(Math.random() * 20) + 20 : 0,
                    bowlingAggression: this.type !== 'Batter' ? Math.floor(Math.random() * 20) + 20 : 0,
                    bowlingConsistency: this.type !== 'Batter' ? Math.floor(Math.random() * 20) + 20 : 0,
                    
                    // Fielding (all players)
                    fieldingCatching: Math.floor(Math.random() * 20) + 20,   // 20-39
                    fieldingAgility: Math.floor(Math.random() * 20) + 20,    // 20-39
                    
                    // Specialist skills
                    wicketKeeping: this.isWicketKeeper ? Math.floor(Math.random() * 20) + 20 : 0,
                    captaincy: this.isCaptain ? Math.floor(Math.random() * 20) + 20 : 0
                };
                
                // Natural talent ceiling (60-95, determines max potential)
                this.talentCeiling = {
                    battingDefense: Math.floor(Math.random() * 35) + 60,    // 60-94
                    battingAggression: Math.floor(Math.random() * 35) + 60,
                    battingConsistency: Math.floor(Math.random() * 35) + 60,
                    bowlingDefense: Math.floor(Math.random() * 35) + 60,
                    bowlingAggression: Math.floor(Math.random() * 35) + 60,
                    bowlingConsistency: Math.floor(Math.random() * 35) + 60,
                    fieldingCatching: Math.floor(Math.random() * 35) + 60,
                    fieldingAgility: Math.floor(Math.random() * 35) + 60,
                    wicketKeeping: Math.floor(Math.random() * 35) + 60,
                    captaincy: Math.floor(Math.random() * 35) + 60
                };
                
                // Training costs (start at base, multiply by 1.5 each time)
                this.trainingCosts = {
                    battingDefense: 500,
                    battingAggression: 500,
                    battingConsistency: 500,
                    bowlingDefense: 500,
                    bowlingAggression: 500,
                    bowlingConsistency: 500,
                    fieldingCatching: 300,
                    fieldingAgility: 300,
                    wicketKeeping: 400,
                    captaincy: 600
                };
                
                // Training queue (pending improvements)
                this.trainingQueue = [];
                
                // Training difficulty (some players struggle with certain skills)
                this.trainingDifficulty = this.generateTrainingDifficulty();
            }
            
            generateTrainingDifficulty() {
                // Some players find certain skills harder to learn
                const difficulty = {};
                const skills = Object.keys(this.trainingCosts);
                
                skills.forEach(skill => {
                    // 70% normal, 20% easier, 10% harder
                    const rand = Math.random();
                    if (rand < 0.1) {
                        difficulty[skill] = 'hard';    // +50% cost, slower progress
                    } else if (rand < 0.3) {
                        difficulty[skill] = 'easy';    // -25% cost, faster progress
                    } else {
                        difficulty[skill] = 'normal';  // Standard rates
                    }
                });
                
                return difficulty;
            }
            
            generateBowlingType() {
                const types = ['Fast', 'Medium', 'Swing', 'Off-spin', 'Leg-spin'];
                return types[Math.floor(Math.random() * types.length)];
            }
        }

        // Generate initial roster with bowling balance requirements
        function generateInitialRoster() {
            const roster = [];
            
            // Generate 6 batters first
            for (let i = 0; i < 6; i++) {
                roster.push(new CricketPlayer('Batter'));
            }
            
            // Track required bowling types to ensure balance
            const requiredBowlingTypes = {
                'Fast': 2,      // Need at least 2 fast bowlers
                'Swing': 1,     // Need at least 1 swing bowler
                'Medium': 1,    // Need at least 1 medium bowler
                'Off-spin': 1,  // Need at least 1 off-spin bowler
                'Leg-spin': 1   // Need at least 1 leg-spin bowler
            };
            
            const bowlingTypeCounts = {
                'Fast': 0,
                'Swing': 0,
                'Medium': 0,
                'Off-spin': 0,
                'Leg-spin': 0
            };
            
            // Generate 5 specialist bowlers with required types
            for (let i = 0; i < 5; i++) {
                let bowler = new CricketPlayer('Bowler');
                
                // For the first few bowlers, ensure we meet minimum requirements
                if (i < Object.keys(requiredBowlingTypes).length) {
                    // Find a required type that we haven't met yet
                    const neededTypes = Object.keys(requiredBowlingTypes).filter(type => 
                        bowlingTypeCounts[type] < requiredBowlingTypes[type]
                    );
                    
                    if (neededTypes.length > 0) {
                        // Assign the first needed type
                        bowler.bowlingType = neededTypes[0];
                        bowlingTypeCounts[bowler.bowlingType]++;
                    }
                } else {
                    // For remaining bowlers, track their random types
                    bowlingTypeCounts[bowler.bowlingType]++;
                }
                
                roster.push(bowler);
            }
            
            // Generate 4 all-rounders with bowling balance considerations
            for (let i = 0; i < 4; i++) {
                let allRounder = new CricketPlayer('All-rounder');
                
                // Check if we still need any bowling types and assign them to all-rounders
                const stillNeeded = Object.keys(requiredBowlingTypes).filter(type => 
                    bowlingTypeCounts[type] < requiredBowlingTypes[type]
                );
                
                if (stillNeeded.length > 0) {
                    // Assign a needed bowling type to this all-rounder
                    allRounder.bowlingType = stillNeeded[0];
                    bowlingTypeCounts[allRounder.bowlingType]++;
                } else {
                    // All requirements met, track the random type
                    bowlingTypeCounts[allRounder.bowlingType]++;
                }
                
                roster.push(allRounder);
            }
            
            // Final check - ensure all minimum requirements are met
            Object.keys(requiredBowlingTypes).forEach(type => {
                const needed = requiredBowlingTypes[type];
                const current = bowlingTypeCounts[type];
                
                if (current < needed) {
                    console.log(`Bowling balance warning: Only ${current} ${type} bowlers (need ${needed})`);
                    
                    // Find random bowlers/all-rounders and reassign their types
                    const bowlingPlayers = roster.filter(p => p.type === 'Bowler' || p.type === 'All-rounder');
                    const remaining = needed - current;
                    
                    for (let i = 0; i < remaining && i < bowlingPlayers.length; i++) {
                        // Find a player whose type can be changed
                        const player = bowlingPlayers[i];
                        if (bowlingTypeCounts[player.bowlingType] > requiredBowlingTypes[player.bowlingType]) {
                            // Safe to change this player's type
                            bowlingTypeCounts[player.bowlingType]--;
                            player.bowlingType = type;
                            bowlingTypeCounts[type]++;
                        }
                    }
                }
            });
            
            console.log('Final bowling type distribution:', bowlingTypeCounts);
            
            return roster;
        }

        // Display players
        function displayPlayers() {
            const playerList = document.getElementById('player-list');
            const filteredPlayers = gameState.currentFilter === 'all' ? 
                gameState.players : gameState.players.filter(p => p.type === gameState.currentFilter);
            
            playerList.innerHTML = filteredPlayers.map(player => {
                // CRITICAL: Add Super Star indicator
                let playerNameDisplay = player.name;
                if (player.isSuperStar) {
                    playerNameDisplay = `‚≠ê ${player.name}`;
                } else if (player.isStar) {
                    playerNameDisplay = `‚òÖ ${player.name}`;
                }

                let statsHTML = `
                    <div class="text-xs text-gray-600 dark:text-gray-400 mt-1">
                        Games: ${player.gamesPlayed} | Age: ${player.age}
                        <br><strong>BATTING:</strong>
                        <br>Runs: ${player.totalRuns} | Avg: ${player.battingAverage} | S/R: ${player.strikeRate}
                        <br>High Score: ${player.highScore} | 50s: ${player.fifties} | 100s: ${player.hundreds}
                `;
                
                if (player.type === 'Bowler' || player.type === 'All-rounder') {
                    statsHTML += `
                        <br><br><strong>BOWLING:</strong>
                        <br>Wickets: ${player.totalWickets} | Economy: ${player.economyRate.toFixed(1)}
                        <br>Best: ${player.bestBowling} | 5w: ${player.fiveWicketHauls} | 10w: ${player.tenWicketHauls}
                        ${player.bowlingType ? `<br>Style: ${player.bowlingType}` : ''}
                    `;
                }
                
                statsHTML += '</div>';
                
                const typeColor = player.type === 'Batter' ? 'bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200' :
                                player.type === 'Bowler' ? 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200' :
                                'bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200';
                
                return `
                    <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg border border-gray-200 dark:border-gray-700">
                        <div class="flex justify-between items-start">
                            <div class="flex items-center gap-3">
                                <div class="flex flex-col gap-1">
                                    <label class="text-xs text-gray-500">Captain</label>
                                    <input type="radio" name="captain" value="${player.name}" onchange="setCaptain('${player.name}')" 
                                           class="w-4 h-4 text-blue-600" ${player.isCaptain ? 'checked' : ''}>
                                </div>
                                <div class="flex flex-col gap-1">
                                    <label class="text-xs text-gray-500">WK</label>
                                    <input type="radio" name="wicketkeeper" value="${player.name}" onchange="setWicketKeeper('${player.name}')" 
                                           class="w-4 h-4 text-yellow-600" ${player.isWicketKeeper ? 'checked' : ''}>
                                </div>
                                <div class="flex-1">
                                    <div class="flex items-center gap-2">
                                        <h3 class="font-medium">${player.name}</h3>
                                        ${player.isCaptain ? '<span class="text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-1 rounded">CAPTAIN</span>' : ''}
                                        ${player.isWicketKeeper ? '<span class="text-xs bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 px-1 rounded">WK</span>' : ''}
                                        ${player.isInjured ? '<span class="text-xs bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 px-1 rounded">INJURED</span>' : ''}
                                    </div>
                                    <span class="inline-block text-xs px-2 py-1 rounded ${typeColor} mt-1">${player.type}</span>
                                    ${statsHTML}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('roster-count').textContent = gameState.players.length;
        }

        // Tab switching
        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
            
            // CRITICAL: Reset training tab when switching tabs
            if (tabName === 'training') {
                resetTrainingTabToOverview();
            }
        }

        // Filter players
        function filterPlayers(type) {
            gameState.currentFilter = type;
            
            // Update filter button styles
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-200', 'dark:bg-gray-700');
            });
            
            event.target.classList.remove('bg-gray-200', 'dark:bg-gray-700');
            event.target.classList.add('bg-blue-500', 'text-white');
            
            displayPlayers();
        }

        // AI Team class
        class AITeam {
            constructor(name, level = 'local') {
                this.name = name;
                this.level = level;
                this.players = this.generateTeamRoster(level);
                this.gamesPlayed = 0;
                this.wins = 0;
                this.losses = 0;
                this.points = 0;
                this.netRunRate = 0;
                this.budget = Math.floor(Math.random() * 30000) + 40000; // 40k-70k budget
                this.isPlayer = false;
                
                // Fan base and income system with level scaling
                this.fanBase = this.generateInitialFanBase(level);
                this.totalIncome = 0;
                this.winStreak = 0;
                this.lossStreak = 0;
            }
            
            generateInitialFanBase(level) {
                // CRITICAL: Enhanced fan base scaling for National Cup and beyond
                switch (level) {
                    case 'local':
                        return Math.floor(Math.random() * 20) + 8; // 8-27 fans
                    case 'national':
                        return Math.floor(Math.random() * 800) + 400; // 400-1199 fans (much higher for national)
                    case 'worldcup':
                        return Math.floor(Math.random() * 5000) + 2000; // 2000-6999 fans
                    case 'test':
                        return Math.floor(Math.random() * 8000) + 5000; // 5000-12999 fans
                    default:
                        return 15;
                }
            }
            
            generateTeamRoster(level) {
                const roster = [];
                // CRITICAL: Generate higher-skilled teams for National Cup and World Cup
                // Still 6 batters, 5 bowlers, 4 all-rounders but with level scaling
                for (let i = 0; i < 6; i++) roster.push(new CricketPlayer('Batter', level));
                for (let i = 0; i < 5; i++) roster.push(new CricketPlayer('Bowler', level));
                for (let i = 0; i < 4; i++) roster.push(new CricketPlayer('All-rounder', level));
                return roster;
            }
            
            selectXI(pitchType) {
                // AI team selects XI using same logic as generateOpponentXI
                const batters = this.players.filter(p => p.type === 'Batter');
                const bowlers = this.players.filter(p => p.type === 'Bowler');
                const allRounders = this.players.filter(p => p.type === 'All-rounder');
                
                // Sort by skill
                batters.sort((a, b) => (b.battingAverage || 0) - (a.battingAverage || 0));
                bowlers.sort((a, b) => (b.totalWickets || 0) - (a.totalWickets || 0));
                allRounders.sort((a, b) => (b.battingAverage + b.totalWickets) - (a.battingAverage + a.totalWickets));
                
                // Build XI with 4-6 bowling options
                const selectedXI = [];
                selectedXI.push(...batters.slice(0, 3)); // Top 3 batters
                selectedXI.push(...allRounders.slice(0, 2)); // Top 2 all-rounders
                selectedXI.push(...bowlers.slice(0, 4)); // Top 4 bowlers
                selectedXI.push(...batters.slice(3, 5)); // Fill remaining with batters
                
                return selectedXI.slice(0, 11);
            }
            
            getTeamStrength() {
                // Calculate overall team strength based on player stats
                let totalStrength = 0;
                this.players.forEach(player => {
                    let playerStrength = 0;
                    if (player.type === 'Batter' || player.type === 'All-rounder') {
                        playerStrength += player.battingAverage + (player.strikeRate / 2);
                    }
                    if (player.type === 'Bowler' || player.type === 'All-rounder') {
                        playerStrength += (player.totalWickets / 2) + (10 - player.economyRate);
                    }
                    totalStrength += playerStrength;
                });
                return totalStrength / this.players.length;
            }
        }

        // Generate AI teams for competition
        function generateAITeams(level) {
            // Different team names for each competition level
            const teamNamesByLevel = {
                'local': [
                    'Town Strikers', 'Village Warriors', 'County Crushers', 'Local Legends', 'Park Rangers',
                    'Community Champions', 'District Dynamos', 'Borough Blazers', 'Suburb Stars', 'City Slickers',
                    'Metro Mavericks', 'Regional Rebels', 'Valley Victors', 'Hill Hawks', 'River Riders'
                ],
                'national': [
                    'Sydney Thunder', 'Melbourne Storm', 'Brisbane Heat', 'Perth Scorchers', 'Adelaide Strikers',
                    'Hobart Hurricanes', 'Darwin Cyclones', 'Newcastle Knights', 'Gold Coast Titans', 'Canberra Capitals',
                    'Auckland Aces', 'Wellington Phoenix', 'Canterbury Crusaders', 'Otago Volts', 'Central Stags'
                ],
                'worldcup': [
                    'Team Australia', 'Team England', 'Team India', 'Team Pakistan', 'Team South Africa',
                    'Team New Zealand', 'Team West Indies', 'Team Sri Lanka', 'Team Bangladesh', 'Team Afghanistan',
                    'Team Ireland', 'Team Scotland', 'Team Netherlands', 'Team Zimbabwe', 'Team Kenya',
                    'Team Canada', 'Team USA', 'Team Nepal', 'Team Oman', 'Team UAE'
                ],
                'test': [
                    'Elite Legends', 'Championship Giants', 'Premier Titans', 'Supreme Warriors', 'Ultimate Champions',
                    'Master Crusaders', 'Grand Victors', 'Royal Gladiators', 'Imperial Eagles', 'Sovereign Lions',
                    'Dynasty Kings', 'Pinnacle Panthers', 'Apex Predators', 'Summit Stallions', 'Crown Conquerors'
                ]
            };
            
            const teamNames = teamNamesByLevel[level] || teamNamesByLevel['local'];
            
            const teams = [];
            // CRITICAL: For National Cup, we need exactly 10 AI teams for 11 total (including player) = 20 games
            const numTeams = level === 'local' ? 7 : level === 'national' ? 10 : 15; // 8, 11, or 16 teams total
            
            for (let i = 0; i < numTeams; i++) {
                teams.push(new AITeam(teamNames[i], level));
            }
            
            return teams;
        }

        // Competition selection
        function selectCompetition(competition) {
            if (!gameState.competitions[competition].unlocked) return;
            
            gameState.currentCompetition = competition;
            
            // Update UI
            document.querySelectorAll('.competition-btn').forEach(btn => {
                btn.classList.remove('bg-green-500', 'text-white');
                btn.classList.add('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400');
            });
            
            const selectedBtn = document.getElementById(competition + '-btn');
            selectedBtn.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400');
            selectedBtn.classList.add('bg-green-500', 'text-white');
            
            // Update titles
            const competitionNames = {
                local: 'Local Cup',
                national: 'National Cup', 
                worldcup: 'World Cup',
                test: 'Test World Series'
            };
            
            document.getElementById('competition-title').textContent = competitionNames[competition];
            document.getElementById('league-title').textContent = competitionNames[competition] + ' Standings';
            
            // CRITICAL FIX: Reset World Cup state when switching to non-World Cup competitions
            if (competition !== 'worldcup') {
                worldCupState.isWorldCupActive = false;
                console.log(`Switched away from World Cup to ${competition} - World Cup state deactivated`);
            }
            
            // CRITICAL: Initialize appropriate tournament format
            if (competition === 'worldcup') {
                // Initialize World Cup tournament
                initializeWorldCupTournament();
            } else {
                // Initialize regular league competition
                initializeCompetition(competition);
            }
            
            // CRITICAL: Update market availability immediately when competition changes
            checkMarketAvailability();
            
            // CRITICAL: Schedule new match with fresh AI teams from the new competition level
            matchState.roundNumber = 1;
            if (competition === 'worldcup') {
                scheduleNextWorldCupMatch();
            } else {
                scheduleNextMatch();
            }
            
            // CRITICAL FIX: Force update standings display immediately after competition change
            updateStandings();
            updateRecentResults();
            
            // Auto-save the competition change
            autoSave();
        }

        // Initialize competition with AI teams
        function initializeCompetition(level) {
            gameState.aiTeams = generateAITeams(level);
            
            // Initialize player's fan base for competition level if needed
            initializePlayerFanBase(level);
            
            // Add player's team to standings
            gameState.leagueStandings = [
                {
                    name: 'Your Team',
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0,
                    points: 0,
                    netRunRate: 0,
                    isPlayer: true
                },
                ...gameState.aiTeams.map(team => ({
                    name: team.name,
                    gamesPlayed: team.gamesPlayed,
                    wins: team.wins,
                    losses: team.losses,
                    points: team.points,
                    netRunRate: team.netRunRate,
                    isPlayer: false
                }))
            ];
            
            gameState.recentResults = [];
            updateStandings();
            updateRecentResults();
        }
        
        // Initialize player fan base based on competition level
        function initializePlayerFanBase(level) {
            // Only adjust fan base when moving to a higher competition, never reduce
            const minFanBaseForLevel = {
                'local': 15,
                'national': 200,
                'worldcup': 1000, 
                'test': 2000
            };
            
            const currentMin = minFanBaseForLevel[level] || 15;
            if (gameState.fanBase < currentMin) {
                gameState.fanBase = currentMin;
            }
        }
        
        // Fan base and income management system
        function calculateFanBaseChange(won, playerScored100) {
            if (won) {
                gameState.winStreak++;
                gameState.lossStreak = 0;
                
                // Win streak bonus: 5% + 1% per additional win + 1% for centuries
                let increase = 5 + Math.max(0, gameState.winStreak - 1);
                if (playerScored100) increase += 1;
                
                const newFans = Math.floor(gameState.fanBase * (increase / 100));
                gameState.fanBase += newFans;
                
                // Apply competition caps
                applyFanBaseCaps();
                
            } else {
                gameState.lossStreak++;
                gameState.winStreak = 0;
                
                // Loss streak penalty: 3% + 1% per additional loss
                const decrease = 3 + Math.max(0, gameState.lossStreak - 1);
                const lostFans = Math.floor(gameState.fanBase * (decrease / 100));
                gameState.fanBase = Math.max(5, gameState.fanBase - lostFans); // Never go below 5 fans
            }
        }
        
        // Apply fan base caps based on competition level
        function applyFanBaseCaps() {
            const level = gameState.currentCompetition;
            
            if (level === 'local') {
                gameState.fanBase = Math.min(gameState.fanBase, 100);
            } else if (level === 'national') {
                // Cap at 2000 with small growth beyond
                if (gameState.fanBase > 2000) {
                    const excess = gameState.fanBase - 2000;
                    const reducedGrowth = Math.floor(excess * 0.1); // 10% of excess growth
                    gameState.fanBase = 2000 + reducedGrowth;
                }
            } else if (level === 'worldcup' || level === 'test') {
                // Diminishing returns after 10000
                if (gameState.fanBase > 10000) {
                    const excess = gameState.fanBase - 10000;
                    const reducedGrowth = Math.floor(excess * 0.2); // 20% of excess growth
                    gameState.fanBase = 10000 + reducedGrowth;
                }
            }
        }
        
        // Calculate match income based on fan bases and home/away split
        function calculateMatchIncome(playerTeam, opponentTeam, isHomeGame) {
            const level = gameState.currentCompetition;
            
            // Fan value per game based on competition level
            const fanValues = {
                'local': 5,
                'national': 15,
                'worldcup': 35,
                'test': 50
            };
            
            const fanValue = fanValues[level] || 5;
            
            // Calculate total attendance (both teams' fans)
            const playerFans = gameState.fanBase;
            const opponentFans = opponentTeam.fanBase || 50; // Fallback if undefined
            const totalAttendance = playerFans + opponentFans;
            
            // Calculate total gate revenue
            const totalRevenue = totalAttendance * fanValue;
            
            // Home team gets 80%, away team gets 20%
            const playerIncome = isHomeGame ? 
                Math.floor(totalRevenue * 0.8) : 
                Math.floor(totalRevenue * 0.2);
                
            const opponentIncome = isHomeGame ?
                Math.floor(totalRevenue * 0.2) :
                Math.floor(totalRevenue * 0.8);
            
            // Update incomes
            gameState.totalIncome += playerIncome;
            if (opponentTeam.totalIncome !== undefined) {
                opponentTeam.totalIncome += opponentIncome;
            }
            
            return {
                playerIncome,
                opponentIncome,
                totalRevenue,
                attendance: totalAttendance
            };
        }
        
        // Update AI team fan bases based on their results
        function updateAITeamFanBases() {
            gameState.aiTeams.forEach(team => {
                // Simple fan base update for AI teams
                if (team.wins > team.losses) {
                    // Winning team gains fans
                    const increase = 2 + Math.floor(Math.random() * 3); // 2-4% increase
                    team.fanBase = Math.floor(team.fanBase * (1 + increase / 100));
                } else if (team.losses > team.wins) {
                    // Losing team loses fans
                    const decrease = 1 + Math.floor(Math.random() * 2); // 1-2% decrease
                    team.fanBase = Math.max(5, Math.floor(team.fanBase * (1 - decrease / 100)));
                }
                
                // Apply same caps as player
                const level = gameState.currentCompetition;
                if (level === 'local') {
                    team.fanBase = Math.min(team.fanBase, 100);
                } else if (level === 'national') {
                    if (team.fanBase > 2000) {
                        const excess = team.fanBase - 2000;
                        const reducedGrowth = Math.floor(excess * 0.1);
                        team.fanBase = 2000 + reducedGrowth;
                    }
                } else if (level === 'worldcup' || level === 'test') {
                    if (team.fanBase > 10000) {
                        const excess = team.fanBase - 10000;
                        const reducedGrowth = Math.floor(excess * 0.2);
                        team.fanBase = 10000 + reducedGrowth;
                    }
                }
            });
        }

        // Update league standings display
        function updateStandings() {
            // CRITICAL: Check if World Cup is active and use World Cup display instead
            if (worldCupState.isWorldCupActive) {
                updateWorldCupDisplay();
                return;
            }
            
            const standingsList = document.getElementById('standings-list');
            
            // Sort by points, then by net run rate
            const sortedStandings = [...gameState.leagueStandings].sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                return b.netRunRate - a.netRunRate;
            });
            
            standingsList.innerHTML = sortedStandings.map((team, index) => {
                const position = index + 1;
                const bgColor = team.isPlayer ? 'bg-blue-50 dark:bg-blue-900' : 'bg-white dark:bg-gray-800';
                const textColor = team.isPlayer ? 'font-bold text-blue-800 dark:text-blue-200' : '';
                
                return `
                    <div class="grid grid-cols-6 gap-2 p-3 border-b border-gray-200 dark:border-gray-700 ${bgColor}">
                        <div class="${textColor}">${position}. ${team.name}</div>
                        <div class="text-center text-xs">${team.gamesPlayed}</div>
                        <div class="text-center text-xs">${team.wins}</div>
                        <div class="text-center text-xs">${team.losses}</div>
                        <div class="text-center text-xs font-medium">${team.points}</div>
                        <div class="text-center text-xs">${team.netRunRate.toFixed(2)}</div>
                    </div>
                `;
            }).join('');
        }

        // Update recent results display - show only current round's results
        function updateRecentResults() {
            const recentResultsDiv = document.getElementById('recent-results');
            
            if (gameState.recentResults.length === 0) {
                recentResultsDiv.innerHTML = '<p class="text-gray-500 text-sm">No matches played yet</p>';
                return;
            }
            
            // Show only the most recent round's results
            // Calculate how many matches should be in the current round
            const totalTeams = 1 + gameState.aiTeams.length; // Player + AI teams
            const matchesPerRound = Math.floor(totalTeams / 2); // Half the teams play each round
            
            // Get only the last round's matches (most recent results)
            const currentRoundResults = gameState.recentResults.slice(-matchesPerRound);
            
            recentResultsDiv.innerHTML = `
                <div class="mb-2">
                    <h4 class="text-sm font-medium text-gray-600 dark:text-gray-400">Round ${matchState.roundNumber - 1} Results:</h4>
                </div>
            ` + currentRoundResults.map((result, index) => {
                // Format result message with proper cricket format
                const team1Name = result.team1;
                const team2Name = result.team2;
                const winner = result.winner;
                const margin = result.margin;
                
                // Determine loser for proper result format
                const loser = winner === team1Name ? team2Name : team1Name;
                let resultMessage;
                
                if (winner === 'Tie') {
                    resultMessage = 'Match tied';
                } else if (margin.includes('runs')) {
                    resultMessage = `${winner} won by ${margin}`;
                } else {
                    resultMessage = `${winner} won by ${margin}`;
                }
                
                // Show scores in cricket format with space and | separator
                const scoresDisplay = `${team1Name} - ${result.score1}  |  ${team2Name} - ${result.score2}`;
                
                // Use the correct index from the current round results
                const actualResultIndex = gameState.recentResults.length - matchesPerRound + index;
                
                return `
                    <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded border hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer transition-colors" 
                         onclick="showMatchTranscript(${actualResultIndex})">
                        <div class="text-sm font-medium">${resultMessage}</div>
                        <div class="text-xs text-gray-600 dark:text-gray-400 mt-1">
                            ${scoresDisplay}
                        </div>
                        <div class="text-xs text-blue-600 dark:text-blue-400 mt-1">
                            Click to view match transcript ‚Üí
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Show match transcript modal with tabs
        function showMatchTranscript(resultIndex) {
            const result = gameState.recentResults[resultIndex];
            if (!result || !result.transcript) {
                showCustomAlert('Match transcript not available');
                return;
            }
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-6xl w-full max-h-[90vh] overflow-hidden">
                    <div class="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700">
                        <div class="flex items-center">
                            <h3 class="text-lg font-bold mr-6">Match Details</h3>
                            <!-- Tab Navigation -->
                            <div class="flex border-b">
                                <button onclick="showMatchTab('transcript')" id="transcript-tab-btn" 
                                        class="match-tab-btn px-4 py-2 text-sm font-medium border-b-2 border-blue-500 text-blue-600 dark:text-blue-400">
                                    Transcript
                                </button>
                                <button onclick="showMatchTab('scorecard')" id="scorecard-tab-btn" 
                                        class="match-tab-btn px-4 py-2 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                                    Scorecard
                                </button>
                            </div>
                        </div>
                        <button onclick="this.closest('.fixed').remove()" 
                                class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-xl">
                            ‚úï
                        </button>
                    </div>
                    
                    <div class="overflow-y-auto max-h-[calc(90vh-160px)]">
                        <!-- Transcript Tab Content -->
                        <div id="transcript-content" class="match-tab-content p-4">
                            <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded">
                                <p class="font-medium">${result.winner} won by ${result.margin}</p>
                                <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">
                                    ${result.team1} - ${result.score1}  |  ${result.team2} - ${result.score2}
                                </p>
                            </div>
                            <div class="space-y-2">
                                ${result.transcript}
                            </div>
                        </div>
                        
                        <!-- Scorecard Tab Content -->
                        <div id="scorecard-content" class="match-tab-content p-4" style="display: none;">
                            ${generateScorecard(result)}
                        </div>
                    </div>
                    
                    <div class="p-4 border-t border-gray-200 dark:border-gray-700 text-center">
                        <button onclick="this.closest('.fixed').remove()" 
                                class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Show match tab function
        function showMatchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.match-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Remove active styles from all tabs
            document.querySelectorAll('.match-tab-btn').forEach(btn => {
                btn.classList.remove('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
                btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-200');
            });
            
            // Show selected tab content
            document.getElementById(tabName + '-content').style.display = 'block';
            
            // Add active styles to selected tab
            const activeBtn = document.getElementById(tabName + '-tab-btn');
            activeBtn.classList.add('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
            activeBtn.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-200');
        }
        
        // Generate scorecard display
        function generateScorecard(result) {
            // Find the match data from stored result or currentMatch
            let matchData = null;
            
            // First check if match data is stored in the result (for persistence)
            if (result.matchData) {
                matchData = result.matchData;
            }
            // Fallback to current match if it matches
            else if (currentMatch && currentMatch.getMatchResult().team1 === result.team1 && currentMatch.getMatchResult().team2 === result.team2) {
                matchData = currentMatch;
            }
            
            // If we don't have detailed match data, show simplified scorecard
            if (!matchData) {
                return `
                    <div class="text-center text-gray-500 mt-8">
                        <p>Detailed scorecard not available for this match.</p>
                        <p class="text-sm mt-2">Only matches played in the current session have detailed statistics.</p>
                    </div>
                `;
            }
            
            return generateDetailedScorecard(matchData);
        }
        
        // Generate detailed scorecard from match data
        function generateDetailedScorecard(match) {
            let scorecardHTML = '';
            
            // First Innings (Batting First)
            const firstInningsBatters = match.battingFirst === match.team1 ? match.team1Players : match.team2Players;
            const firstInningsFielders = match.battingFirst === match.team1 ? match.team2Players : match.team1Players;
            const firstInningsExtras = match.battingFirst === match.team1 ? match.team1Extras : match.team2Extras;
            const firstInningsScore = match.battingFirst === match.team1 ? match.team1Score : match.team2Score;
            const firstInningsTeamName = match.battingFirst.name || 'Your Team';
            
            scorecardHTML += generateInningsScorecard(firstInningsTeamName, firstInningsBatters, firstInningsFielders, firstInningsExtras, firstInningsScore, true);
            
            // Second Innings (Chasing)
            const secondInningsBatters = match.battingFirst === match.team1 ? match.team2Players : match.team1Players;
            const secondInningsFielders = match.battingFirst === match.team1 ? match.team1Players : match.team2Players;
            const secondInningsExtras = match.battingFirst === match.team1 ? match.team2Extras : match.team1Extras;
            const secondInningsScore = match.battingFirst === match.team1 ? match.team2Score : match.team1Score;
            const secondInningsTeamName = match.battingFirst === match.team1 ? (match.team2.name || 'Your Team') : (match.team1.name || 'Your Team');
            
            scorecardHTML += generateInningsScorecard(secondInningsTeamName, secondInningsBatters, secondInningsFielders, secondInningsExtras, secondInningsScore, false);
            
            return scorecardHTML;
        }
        
        // Generate innings scorecard
        function generateInningsScorecard(teamName, batters, fielders, extras, score, isFirstInnings) {
            let html = `
                <div class="mb-8">
                    <h4 class="text-lg font-bold mb-4 text-blue-600 dark:text-blue-400">${teamName} ${isFirstInnings ? '(1st Innings)' : '(2nd Innings)'}</h4>
                    
                    <!-- Batting Performance -->
                    <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 mb-4">
                        <h5 class="font-medium mb-3">Batting</h5>
                        <div class="space-y-1 font-mono text-sm">
            `;
            
            // Display each batsman
            batters.forEach((player, index) => {
                if (player.matchStats.ballsFaced > 0 || player.matchStats.isOut) {
                    const lastName = player.name.split(' ').pop();
                    let dismissalText = '';
                    
                    if (player.matchStats.isOut) {
                        switch (player.matchStats.dismissalType) {
                            case 'bowled':
                                dismissalText = `b. ${player.matchStats.bowlerWhoGotWicket.split(' ').pop()}`;
                                break;
                            case 'caught':
                                const catcherName = player.matchStats.caughtBy ? player.matchStats.caughtBy.split(' ').pop() : 'fielder';
                                dismissalText = `c. ${catcherName} b. ${player.matchStats.bowlerWhoGotWicket.split(' ').pop()}`;
                                break;
                            case 'lbw':
                                dismissalText = `lbw b. ${player.matchStats.bowlerWhoGotWicket.split(' ').pop()}`;
                                break;
                            case 'runout':
                                dismissalText = 'run out';
                                break;
                            case 'stumped':
                                dismissalText = `st. wk b. ${player.matchStats.bowlerWhoGotWicket.split(' ').pop()}`;
                                break;
                        }
                    } else if (player.matchStats.ballsFaced > 0) {
                        dismissalText = 'NOT OUT';
                    }
                    
                    html += `
                        <div class="flex justify-between items-center">
                            <span class="flex-1">${player.name}</span>
                            <span class="flex-1 text-left text-sm text-gray-600 dark:text-gray-400">${dismissalText}</span>
                            <span class="font-bold w-16 text-right">${player.matchStats.runs}</span>
                            <span class="w-16 text-right text-xs text-gray-500">(${player.matchStats.ballsFaced})</span>
                        </div>
                    `;
                }
            });
            
            // Add extras
            if (extras.total > 0) {
                let extrasBreakdown = [];
                if (extras.wides > 0) extrasBreakdown.push(`${extras.wides}w`);
                if (extras.noballs > 0) extrasBreakdown.push(`${extras.noballs}nb`);
                if (extras.legbyes > 0) extrasBreakdown.push(`${extras.legbyes}lb`);
                if (extras.byes > 0) extrasBreakdown.push(`${extras.byes}b`);
                
                html += `
                    <div class="flex justify-between border-t pt-1 mt-2">
                        <span class="flex-1">Extras ${extrasBreakdown.join(', ')}</span>
                        <span class="font-bold w-12 text-right">${extras.total}</span>
                        <span class="w-12"></span>
                    </div>
                `;
            }
            
            // Total score
            html += `
                    <div class="flex justify-between border-t-2 pt-2 mt-2 font-bold">
                        <span class="flex-1">TOTAL</span>
                        <span class="w-12 text-right">${score.runs}/${score.wickets}</span>
                        <span class="w-12 text-right text-xs">(${score.overs}.0 ov)</span>
                    </div>
                </div>
            `;
            
            // Bowling figures
            html += `
                    <!-- Bowling Performance -->
                    <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                        <h5 class="font-medium mb-3">Bowling</h5>
                        <div class="space-y-1 font-mono text-sm">
                            <div class="flex justify-between font-medium text-xs text-gray-500 mb-2">
                                <span class="flex-1">Bowler</span>
                                <span class="w-12 text-center">O</span>
                                <span class="w-12 text-center">R</span>
                                <span class="w-12 text-center">W</span>
                                <span class="w-12 text-center">Econ</span>
                            </div>
            `;
            
            // Display bowling figures for bowlers who bowled
            fielders.forEach(player => {
                if (player.matchStats.ballsBowled > 0) {
                    const lastName = player.name.split(' ').pop();
                    const overs = Math.floor(player.matchStats.ballsBowled / 6);
                    const balls = player.matchStats.ballsBowled % 6;
                    const oversDisplay = balls > 0 ? `${overs}.${balls}` : `${overs}`;
                    const economy = overs > 0 ? (player.matchStats.runsConceded / overs).toFixed(1) : '0.0';
                    
                    html += `
                        <div class="flex justify-between">
                            <span class="flex-1">${lastName}</span>
                            <span class="w-12 text-center">${oversDisplay}</span>
                            <span class="w-12 text-center">${player.matchStats.runsConceded}</span>
                            <span class="w-12 text-center">${player.matchStats.wicketsTaken}</span>
                            <span class="w-12 text-center">${economy}</span>
                        </div>
                    `;
                }
            });
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }

        // Simulate match between two teams (basic version)
        function simulateMatch(team1, team2) {
            // Simple simulation - will be expanded with proper cricket mechanics
            const team1Strength = team1.getTeamStrength ? team1.getTeamStrength() : 50;
            const team2Strength = team2.getTeamStrength ? team2.getTeamStrength() : 50;
            
            const team1Score = Math.floor(Math.random() * 100) + team1Strength + 120;
            const team2Score = Math.floor(Math.random() * 100) + team2Strength + 120;
            
            const winner = team1Score > team2Score ? team1 : team2;
            const loser = winner === team1 ? team2 : team1;
            const margin = Math.abs(team1Score - team2Score);
            
            return {
                team1: team1.name,
                team2: team2.name,
                score1: team1Score,
                score2: team2Score,
                winner: winner.name,
                margin: `${margin} runs`
            };
        }

        // Match day state
        const matchState = {
            opponent: null,
            isHomeGame: true,
            pitchType: 'Fast Pitch',
            weather: 'Sunny & Clear',
            selectedXI: [],
            opponentXI: [],
            roundNumber: 1
        };

        // Set captain
        function setCaptain(playerName) {
            gameState.players.forEach(player => {
                player.isCaptain = player.name === playerName;
            });
            displayPlayers();
            updatePlayerSelector();
            
            // CRITICAL: Update training dropdown immediately when captain changes
            populateTrainingSelector();
        }

        // Set wicket keeper
        function setWicketKeeper(playerName) {
            gameState.players.forEach(player => {
                player.isWicketKeeper = player.name === playerName;
            });
            displayPlayers();
            updatePlayerSelector();
            
            // CRITICAL: Update training dropdown immediately when WK changes
            populateTrainingSelector();
        }

        // Schedule next match automatically (no user control)
        function scheduleNextMatch() {
            // Use proper round-robin logic with home/away alternation
            const allTeams = [gameState.teamName, ...gameState.aiTeams.map(t => t.name)];
            const roundMatches = generateRoundMatches(allTeams, matchState.roundNumber);
            
            // Find the player's match for this round
            const playerMatch = roundMatches.find(match => 
                match.team1 === gameState.teamName || match.team2 === gameState.teamName
            );
            
            if (playerMatch) {
                // Determine opponent and home/away based on proper round-robin positioning
                const opponentName = playerMatch.team1 === gameState.teamName ? playerMatch.team2 : playerMatch.team1;
                matchState.opponent = gameState.aiTeams.find(team => team.name === opponentName);
                
                // CRITICAL: Player is home when they are team1 in the match
                matchState.isHomeGame = playerMatch.team1 === gameState.teamName;
                
                console.log(`Round ${matchState.roundNumber}: ${playerMatch.team1} vs ${playerMatch.team2}`);
                console.log(`Player (${gameState.teamName}) is ${matchState.isHomeGame ? 'HOME' : 'AWAY'}`);
            } else {
                // Fallback if no match found (shouldn't happen with proper round-robin)
                const teamIndex = (matchState.roundNumber - 1) % gameState.aiTeams.length;
                matchState.opponent = gameState.aiTeams[teamIndex];
                // Simple alternation for fallback
                matchState.isHomeGame = matchState.roundNumber % 2 === 1;
                
                console.log(`FALLBACK Round ${matchState.roundNumber}: Player vs ${matchState.opponent.name}`);
                console.log(`Player is ${matchState.isHomeGame ? 'HOME' : 'AWAY'} (fallback logic)`);
            }
            
            // Random pitch conditions
            const pitchTypes = ['Fast Pitch', 'Slow Pitch', 'Bouncy Pitch', 'Spinning Pitch', 'Green Pitch'];
            matchState.pitchType = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];
            
            // Random weather conditions - cricket is summer sport, rain is rare
            const weatherConditions = [
                { condition: 'Sunny & Clear', risk: 'none', effect: 'Perfect playing conditions', weight: 40 },
                { condition: 'Partly Cloudy', risk: 'none', effect: 'Good for all players', weight: 25 },
                { condition: 'Overcast', risk: 'none', effect: 'Favors swing bowlers', weight: 20 },
                { condition: 'Hot & Humid', risk: 'injury', effect: 'Swing bowling conditions, injury risk', weight: 12 },
                { condition: 'Threatening Rain', risk: 'rain', effect: 'Match may be interrupted', weight: 2 },
                { condition: 'Light Drizzle', risk: 'cancellation', effect: 'High chance of cancellation', weight: 1 }
            ];
            
            // Weighted random selection for weather - cricket is summer sport, rain is rare
            const totalWeight = weatherConditions.reduce((sum, weather) => sum + weather.weight, 0);
            let randomWeight = Math.random() * totalWeight;
            let selectedWeather = weatherConditions[0];
            
            for (const weather of weatherConditions) {
                randomWeight -= weather.weight;
                if (randomWeight <= 0) {
                    selectedWeather = weather;
                    break;
                }
            }
            
            matchState.weather = selectedWeather.condition;
            
            // Update UI
            updateMatchDayReport();
            generateOpponentXI();
        }

        // Simulate detailed match with player stat updates
        function simulateDetailedMatch(team1, team2, pitchType, weather, isHomeGame = false) {
            // Enhanced match simulation that updates individual player stats
            const team1Players = team1.isPlayer ? 
                matchState.selectedXI.map(name => gameState.players.find(p => p.name === name)) :
                team1.selectXI(pitchType);
            
            const team2Players = team2.isPlayer ? 
                matchState.selectedXI.map(name => gameState.players.find(p => p.name === name)) :
                team2.selectXI(pitchType);
            
            // Calculate team strengths with conditions
            let team1Strength = calculateTeamStrength(team1Players, pitchType, weather, isHomeGame);
            let team2Strength = calculateTeamStrength(team2Players, pitchType, weather, false);
            
            // Simulate scores
            const team1Score = Math.floor(Math.random() * 100) + team1Strength + 120;
            const team2Score = Math.floor(Math.random() * 100) + team2Strength + 120;
            
            const winner = team1Score > team2Score ? team1 : team2;
            const margin = Math.abs(team1Score - team2Score);
            
            // Update player statistics for both teams
            updatePlayerStatsAfterMatch(team1Players, team1Score, team1Score > team2Score);
            updatePlayerStatsAfterMatch(team2Players, team2Score, team2Score > team1Score);
            
            // Auto-save after match simulation
            autoSave();
            
            return {
                team1: team1.name || 'Your Team',
                team2: team2.name || 'Your Team', 
                score1: team1Score,
                score2: team2Score,
                winner: winner.name || 'Your Team',
                margin: `${margin} runs`
            };
        }

        // Calculate team strength with conditions
        function calculateTeamStrength(players, pitchType, weather, isHomeGame) {
            let strength = 0;
            players.forEach(player => {
                let playerStrength = player.battingAverage + (player.strikeRate / 3);
                
                if (player.type === 'Bowler' || player.type === 'All-rounder') {
                    playerStrength += (player.totalWickets / 2) + (10 - player.economyRate) * 2;
                }
                
                // Apply pitch conditions
                if (player.hiddenTraits.includes(`${pitchType.split(' ')[0]} Pitch Specialist`)) {
                    playerStrength *= 1.15; // 15% boost for specialists
                }
                
                // Apply weather conditions
                if (weather === 'Overcast' && player.bowlingType === 'Swing') {
                    playerStrength *= 1.1;
                }
                
                // Home advantage
                if (isHomeGame) {
                    playerStrength *= 1.05;
                }
                
                strength += playerStrength;
            });
            
            return strength / players.length;
        }

        // Update individual player statistics after match
        function updatePlayerStatsAfterMatch(players, teamScore, won) {
            players.forEach((player, index) => {
                // Update games played
                player.gamesPlayed++;
                
                // Simulate individual performance based on team score and position
                const battingOrder = index + 1;
                const expectedRuns = Math.floor(teamScore / 11) + Math.random() * 20 - 10;
                const actualRuns = Math.max(0, Math.floor(expectedRuns * (0.7 + Math.random() * 0.6)));
                
                // Update batting stats
                player.totalRuns += actualRuns;
                player.battingAverage = Math.floor(player.totalRuns / player.gamesPlayed);
                
                // Update high score occasionally
                if (actualRuns > player.highScore && Math.random() < 0.05) {
                    player.highScore = actualRuns;
                }
                
                // Update 50s and 100s
                if (actualRuns >= 50) player.fifties++;
                if (actualRuns >= 100) player.hundreds++;
                
                // Update bowling stats for bowlers
                if (player.type === 'Bowler' || player.type === 'All-rounder') {
                    const wicketsTaken = Math.floor(Math.random() * 4); // 0-3 wickets
                    player.totalWickets += wicketsTaken;
                    
                    // Update best bowling occasionally
                    if (wicketsTaken >= 3 && Math.random() < 0.2) {
                        const runsGiven = Math.floor(wicketsTaken * player.economyRate * 6 * 0.8);
                        player.bestBowling = `${wicketsTaken}/${runsGiven}`;
                    }
                    
                    // Update 5-wicket hauls
                    if (wicketsTaken >= 5) player.fiveWicketHauls++;
                }
            });
        }

        // Process full round of matches for entire league - COMPREHENSIVE FIX
        function processLeagueRound() {
            const roundResults = [];
            
            // CRITICAL: Ensure we're using the CURRENT round number (before incrementing)
            const currentRound = matchState.roundNumber;
            
            console.log(`\n=== PROCESSING LEAGUE ROUND ${currentRound} ===`);
            console.log(`AI Teams before round processing:`);
            gameState.aiTeams.forEach(team => {
                console.log(`  ${team.name}: ${team.gamesPlayed}GP, ${team.wins}W, ${team.losses}L, ${team.points}P`);
            });
            
            // Get ALL matches for this round using the same logic as the schedule
            const allTeams = [gameState.teamName, ...gameState.aiTeams.map(t => t.name)];
            const allRoundMatches = generateRoundMatches(allTeams, currentRound);
            
            console.log(`\nAll matches for Round ${currentRound}:`);
            allRoundMatches.forEach(match => {
                console.log(`  ${match.team1} vs ${match.team2}`);
            });
            
            // CRITICAL: Process ALL AI vs AI matches (not just filtered ones)
            const aiMatches = allRoundMatches.filter(match => 
                match.team1 !== gameState.teamName && match.team2 !== gameState.teamName
            );
            
            console.log(`\nAI matches to simulate: ${aiMatches.length}`);
            aiMatches.forEach(match => {
                console.log(`  AI Match: ${match.team1} vs ${match.team2}`);
            });
            
            // CRITICAL: Before simulating matches, create a backup of current AI team states
            const aiTeamBackup = gameState.aiTeams.map(team => ({
                name: team.name,
                gamesPlayed: team.gamesPlayed,
                wins: team.wins,
                losses: team.losses,
                points: team.points,
                netRunRate: team.netRunRate
            }));
            
            // Simulate each AI vs AI match for this round
            aiMatches.forEach(match => {
                const team1 = gameState.aiTeams.find(t => t.name === match.team1);
                const team2 = gameState.aiTeams.find(t => t.name === match.team2);
                
                if (team1 && team2) {
                    console.log(`\nSimulating: ${team1.name} (${team1.gamesPlayed}GP) vs ${team2.name} (${team2.gamesPlayed}GP)`);
                    
                    // Random pitch and weather for each match
                    const pitchTypes = ['Fast Pitch', 'Slow Pitch', 'Bouncy Pitch', 'Spinning Pitch', 'Green Pitch'];
                    const randomPitch = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];
                    const weatherTypes = ['Sunny & Clear', 'Partly Cloudy', 'Overcast', 'Hot & Humid'];
                    const randomWeather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                    
                    const result = simulateDetailedMatch(team1, team2, randomPitch, randomWeather);
                    roundResults.push(result);
                    
                    console.log(`Result: ${result.winner} won by ${result.margin}`);
                    
                    // Update team records
                    if (result.winner === team1.name) {
                        team1.wins++;
                        team1.points += 2;
                        team2.losses++;
                    } else if (result.winner === team2.name) {
                        team2.wins++;
                        team2.points += 2;
                        team1.losses++;
                    } else {
                        // Handle ties
                        team1.points += 1;
                        team2.points += 1;
                    }
                    
                    // CRITICAL: ALWAYS increment games played for both teams
                    team1.gamesPlayed++;
                    team2.gamesPlayed++;
                    
                    // Update net run rate (simplified)
                    team1.netRunRate = (team1.wins - team1.losses) + Math.random() * 2 - 1;
                    team2.netRunRate = (team2.wins - team2.losses) + Math.random() * 2 - 1;
                    
                    console.log(`After match: ${team1.name} ${team1.gamesPlayed}GP ${team1.wins}W ${team1.losses}L ${team1.points}P`);
                    console.log(`After match: ${team2.name} ${team2.gamesPlayed}GP ${team2.wins}W ${team2.losses}L ${team2.points}P`);
                } else {
                    console.error(`ERROR: Could not find teams for match ${match.team1} vs ${match.team2}`);
                }
            });
            
            // Add all results to recent results
            gameState.recentResults.push(...roundResults);
            
            console.log(`\nAI Teams after round processing:`);
            gameState.aiTeams.forEach(team => {
                console.log(`  ${team.name}: ${team.gamesPlayed}GP, ${team.wins}W, ${team.losses}L, ${team.points}P`);
            });
            
            // CRITICAL: Comprehensive synchronization of league standings with ALL AI team data
            console.log(`\nSynchronizing league standings...`);
            gameState.leagueStandings = gameState.leagueStandings.map(standing => {
                if (!standing.isPlayer) {
                    const team = gameState.aiTeams.find(t => t.name === standing.name);
                    if (team) {
                        const oldData = `${standing.gamesPlayed}GP ${standing.wins}W ${standing.losses}L ${standing.points}P`;
                        const newData = `${team.gamesPlayed}GP ${team.wins}W ${team.losses}L ${team.points}P`;
                        console.log(`  ${team.name}: ${oldData} -> ${newData}`);
                        
                        return {
                            ...standing,
                            gamesPlayed: team.gamesPlayed,
                            wins: team.wins,
                            losses: team.losses,
                            points: team.points,
                            netRunRate: team.netRunRate
                        };
                    } else {
                        console.error(`ERROR: Could not find AI team ${standing.name} in gameState.aiTeams`);
                    }
                }
                return standing;
            });
            
            // CRITICAL: Verify that all AI teams have consistent game counts
            console.log(`\nPost-round verification:`);
            const playerGamesPlayed = gameState.leagueStandings.find(s => s.isPlayer).gamesPlayed;
            console.log(`Player games played: ${playerGamesPlayed}`);
            
            let inconsistentTeams = [];
            gameState.aiTeams.forEach(team => {
                if (Math.abs(team.gamesPlayed - playerGamesPlayed) > 1) {
                    inconsistentTeams.push(`${team.name}: ${team.gamesPlayed}GP (expected ~${playerGamesPlayed}GP)`);
                }
            });
            
            if (inconsistentTeams.length > 0) {
                console.error(`WARNING: Inconsistent game counts detected:`);
                inconsistentTeams.forEach(issue => console.error(`  ${issue}`));
            } else {
                console.log(`‚úÖ All teams have consistent game counts (¬±1 games)`);
            }
            
            // CRITICAL: Force save after league round processing
            autoSave();
            
            console.log(`=== ROUND ${currentRound} PROCESSING COMPLETE ===\n`);
        }

        // World Cup Tournament System - NEW WORLD CUP IMPLEMENTATION
        
        // World Cup tournament state
        const worldCupState = {
            phase: 'groups', // 'groups', 'round16', 'quarters', 'semis', 'final'
            groups: [],
            knockoutBracket: [],
            currentGroupStage: 1, // 1-3 for 3 group matches
            totalGroupMatches: 3,
            isWorldCupActive: false,
            seededTeams: ['Australia', 'India', 'England', 'South Africa', 'Sri Lanka', 'West Indies', 'New Zealand', 'Pakistan'],
            unseededTeams: []
        };
        
        // Initialize World Cup Tournament
        function initializeWorldCupTournament() {
            console.log("üèÜ INITIALIZING WORLD CUP TOURNAMENT");
            
            // Mark as active
            worldCupState.isWorldCupActive = true;
            worldCupState.phase = 'groups';
            worldCupState.currentGroupStage = 1;
            
            // CRITICAL FIX: Define proper World Cup teams instead of reusing National Cup teams
            const seededTeams = ['Australia', 'India', 'England', 'South Africa', 'Sri Lanka', 'West Indies', 'New Zealand', 'Pakistan'];
            const unseededTeams = ['Bangladesh', 'Kenya', 'Zimbabwe', 'Afghanistan', 'Canada', 'USA', 'Ireland', gameState.teamName];
            
            console.log("Seeded teams:", seededTeams);
            console.log("Unseeded teams:", unseededTeams);
            
            // CRITICAL: Generate fresh World Cup AI teams for all teams except the user
            const worldCupTeamNames = [...seededTeams, ...unseededTeams.filter(team => team !== gameState.teamName)];
            gameState.aiTeams = worldCupTeamNames.map(teamName => new AITeam(teamName, 'worldcup'));
            
            console.log(`Generated ${gameState.aiTeams.length} new World Cup AI teams`);
            
            worldCupState.seededTeams = seededTeams;
            worldCupState.unseededTeams = unseededTeams;
            
            console.log("Seeded teams:", seededTeams);
            console.log("Unseeded teams:", unseededTeams);
            
            // Form 4 groups with seeding system
            worldCupState.groups = [];
            for (let i = 0; i < 4; i++) {
                const group = {
                    name: String.fromCharCode(65 + i), // A, B, C, D
                    teams: [
                        seededTeams[i * 2], // First seeded team
                        seededTeams[i * 2 + 1], // Second seeded team
                        unseededTeams[i * 2], // First unseeded team
                        unseededTeams[i * 2 + 1] // Second unseeded team
                    ],
                    standings: []
                };
                
                // Initialize group standings
                group.standings = group.teams.map(teamName => ({
                    name: teamName,
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0,
                    points: 0,
                    netRunRate: 0,
                    isPlayer: teamName === gameState.teamName
                }));
                
                worldCupState.groups.push(group);
                console.log(`Group ${group.name}:`, group.teams);
            }
            
            // Update UI for World Cup
            updateWorldCupDisplay();
            
            // Schedule first group match for player
            scheduleNextWorldCupMatch();
        }
        
        // Schedule next World Cup match
        function scheduleNextWorldCupMatch() {
            if (!worldCupState.isWorldCupActive) return;
            
            console.log(`üèè SCHEDULING WORLD CUP MATCH - Phase: ${worldCupState.phase}, Group Stage: ${worldCupState.currentGroupStage}`);
            
            if (worldCupState.phase === 'groups') {
                scheduleGroupStageMatch();
            } else {
                scheduleKnockoutMatch();
            }
        }
        
        // Schedule group stage match
        function scheduleGroupStageMatch() {
            // Find which group the player is in
            const playerGroup = worldCupState.groups.find(group => 
                group.teams.includes(gameState.teamName)
            );
            
            if (!playerGroup) {
                console.error("Player not found in any group!");
                return;
            }
            
            console.log(`Player is in Group ${playerGroup.name}`);
            
            // Generate group stage matches for current stage
            const groupMatches = generateGroupStageMatches(playerGroup, worldCupState.currentGroupStage);
            
            // Find player's match
            const playerMatch = groupMatches.find(match => 
                match.team1 === gameState.teamName || match.team2 === gameState.teamName
            );
            
            if (playerMatch) {
                // Set opponent and match details
                const opponentName = playerMatch.team1 === gameState.teamName ? playerMatch.team2 : playerMatch.team1;
                matchState.opponent = gameState.aiTeams.find(team => team.name === opponentName);
                
                // World Cup matches are neutral venue (no home advantage)
                matchState.isHomeGame = false;
                
                // Random pitch and weather
                const pitchTypes = ['Fast Pitch', 'Slow Pitch', 'Bouncy Pitch', 'Spinning Pitch', 'Green Pitch'];
                matchState.pitchType = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];
                
                const weatherConditions = ['Sunny & Clear', 'Partly Cloudy', 'Overcast', 'Hot & Humid'];
                matchState.weather = weatherConditions[Math.floor(Math.random() * weatherConditions.length)];
                
                updateMatchDayReport();
                generateOpponentXI();
                
                console.log(`Group Stage ${worldCupState.currentGroupStage}: ${gameState.teamName} vs ${opponentName}`);
            }
        }
        
        // Generate group stage matches for a specific stage (1, 2, or 3)
        function generateGroupStageMatches(group, stage) {
            const teams = group.teams;
            let matches = [];
            
            // Group stage fixtures - each team plays 3 matches total
            if (stage === 1) {
                // Round 1: Team1 vs Team2, Team3 vs Team4
                matches = [
                    { team1: teams[0], team2: teams[1] },
                    { team1: teams[2], team2: teams[3] }
                ];
            } else if (stage === 2) {
                // Round 2: Team1 vs Team3, Team2 vs Team4
                matches = [
                    { team1: teams[0], team2: teams[2] },
                    { team1: teams[1], team2: teams[3] }
                ];
            } else if (stage === 3) {
                // Round 3: Team1 vs Team4, Team2 vs Team3
                matches = [
                    { team1: teams[0], team2: teams[3] },
                    { team1: teams[1], team2: teams[2] }
                ];
            }
            
            return matches;
        }
        
        // Process World Cup group stage round
        function processWorldCupGroupRound() {
            console.log(`üåè PROCESSING WORLD CUP GROUP STAGE ${worldCupState.currentGroupStage}`);
            
            // Process matches for all groups
            worldCupState.groups.forEach(group => {
                const groupMatches = generateGroupStageMatches(group, worldCupState.currentGroupStage);
                
                // Filter AI vs AI matches only
                const aiMatches = groupMatches.filter(match => 
                    match.team1 !== gameState.teamName && match.team2 !== gameState.teamName
                );
                
                // Simulate AI matches
                aiMatches.forEach(match => {
                    const team1 = gameState.aiTeams.find(t => t.name === match.team1);
                    const team2 = gameState.aiTeams.find(t => t.name === match.team2);
                    
                    if (team1 && team2) {
                        const result = simulateDetailedMatch(team1, team2, matchState.pitchType, matchState.weather);
                        
                        // Update group standings
                        updateGroupStandings(group, result);
                        
                        // Add to recent results
                        gameState.recentResults.push(result);
                    }
                });
            });
            
            console.log(`Group Stage ${worldCupState.currentGroupStage} AI matches completed`);
        }
        
        // Update group standings
        function updateGroupStandings(group, result) {
            const team1Standing = group.standings.find(s => s.name === result.team1);
            const team2Standing = group.standings.find(s => s.name === result.team2);
            
            if (team1Standing && team2Standing) {
                // Update games played
                team1Standing.gamesPlayed++;
                team2Standing.gamesPlayed++;
                
                // Update wins/losses/points
                if (result.winner === result.team1) {
                    team1Standing.wins++;
                    team1Standing.points += 2;
                    team2Standing.losses++;
                } else if (result.winner === result.team2) {
                    team2Standing.wins++;
                    team2Standing.points += 2;
                    team1Standing.losses++;
                } else {
                    // Tie
                    team1Standing.points += 1;
                    team2Standing.points += 1;
                }
                
                // Update net run rate (simplified)
                team1Standing.netRunRate = (team1Standing.wins - team1Standing.losses) + Math.random() * 2 - 1;
                team2Standing.netRunRate = (team2Standing.wins - team2Standing.losses) + Math.random() * 2 - 1;
            }
        }
        
        // Check if World Cup group stage is complete
        function checkWorldCupGroupStageComplete() {
            if (!worldCupState.isWorldCupActive || worldCupState.phase !== 'groups') return false;
            
            const playerGroup = worldCupState.groups.find(group => 
                group.teams.includes(gameState.teamName)
            );
            
            if (!playerGroup) return false;
            
            const playerStanding = playerGroup.standings.find(s => s.isPlayer);
            return playerStanding && playerStanding.gamesPlayed >= 3;
        }
        
        // Advance to knockout stage
        function advanceToKnockoutStage() {
            console.log("üèÜ ADVANCING TO WORLD CUP KNOCKOUT STAGE");
            
            worldCupState.phase = 'round16';
            
            // Get top 2 from each group
            const qualifiedTeams = [];
            worldCupState.groups.forEach(group => {
                // Sort by points, then by net run rate
                const sortedStandings = [...group.standings].sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    return b.netRunRate - a.netRunRate;
                });
                
                // Top 2 qualify
                qualifiedTeams.push(sortedStandings[0], sortedStandings[1]);
                
                console.log(`Group ${group.name} qualifiers:`, 
                    sortedStandings[0].name, sortedStandings[1].name);
            });
            
            // Check if player qualified
            const playerQualified = qualifiedTeams.some(team => team.isPlayer);
            
            if (!playerQualified) {
                // Player eliminated
                endWorldCupForPlayer(false);
                return;
            }
            
            // Create knockout bracket (Round of 16)
            worldCupState.knockoutBracket = createKnockoutBracket(qualifiedTeams);
            
            // Update UI
            updateWorldCupDisplay();
            
            // Schedule knockout match
            scheduleKnockoutMatch();
        }
        
        // Create knockout bracket
        function createKnockoutBracket(qualifiedTeams) {
            // Simple bracket: Group winners vs Group runners-up
            const groupWinners = [];
            const groupRunners = [];
            
            for (let i = 0; i < qualifiedTeams.length; i += 2) {
                groupWinners.push(qualifiedTeams[i]);      // 1st place
                groupRunners.push(qualifiedTeams[i + 1]);  // 2nd place
            }
            
            // Create Round of 16 matches
            const round16Matches = [
                { team1: groupWinners[0].name, team2: groupRunners[1].name },
                { team1: groupWinners[1].name, team2: groupRunners[0].name },
                { team1: groupWinners[2].name, team2: groupRunners[3].name },
                { team1: groupWinners[3].name, team2: groupRunners[2].name }
            ];
            
            return {
                round16: round16Matches,
                quarters: [],
                semis: [],
                final: null
            };
        }
        
        // Schedule knockout match
        function scheduleKnockoutMatch() {
            console.log(`ü•ä SCHEDULING KNOCKOUT MATCH - Phase: ${worldCupState.phase}`);
            
            let playerMatch = null;
            
            if (worldCupState.phase === 'round16') {
                playerMatch = worldCupState.knockoutBracket.round16.find(match => 
                    match.team1 === gameState.teamName || match.team2 === gameState.teamName
                );
            } else if (worldCupState.phase === 'quarters') {
                playerMatch = worldCupState.knockoutBracket.quarters.find(match => 
                    match.team1 === gameState.teamName || match.team2 === gameState.teamName
                );
            } else if (worldCupState.phase === 'semis') {
                playerMatch = worldCupState.knockoutBracket.semis.find(match => 
                    match.team1 === gameState.teamName || match.team2 === gameState.teamName
                );
            } else if (worldCupState.phase === 'final') {
                playerMatch = worldCupState.knockoutBracket.final;
            }
            
            if (playerMatch) {
                const opponentName = playerMatch.team1 === gameState.teamName ? playerMatch.team2 : playerMatch.team1;
                matchState.opponent = gameState.aiTeams.find(team => team.name === opponentName);
                
                // Knockout matches are neutral venue
                matchState.isHomeGame = false;
                
                updateMatchDayReport();
                generateOpponentXI();
                
                console.log(`${worldCupState.phase.toUpperCase()}: ${gameState.teamName} vs ${opponentName}`);
            }
        }
        
        // End World Cup for player
        function endWorldCupForPlayer(won) {
            worldCupState.isWorldCupActive = false;
            
            if (won) {
                showWorldCupVictoryModal();
            } else {
                showWorldCupEliminationModal();
            }
        }
        
        // Show World Cup victory modal
        function showWorldCupVictoryModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-lg w-full">
                    <div class="p-6 text-center">
                        <div class="text-6xl mb-4">üèÜ</div>
                        <h2 class="text-3xl font-bold mb-4 text-yellow-600">WORLD CUP CHAMPIONS!</h2>
                        <p class="text-lg mb-6">Incredible! You have won the World Cup! This is the ultimate achievement in cricket!</p>
                        
                        <div class="bg-yellow-50 dark:bg-yellow-900 rounded-lg p-4 mb-6">
                            <h3 class="font-bold mb-3">üéâ Victory Rewards:</h3>
                            <p>‚Ä¢ $100,000 prize money</p>
                            <p>‚Ä¢ Test World Series unlocked</p>
                            <p>‚Ä¢ Legendary status achieved</p>
                        </div>
                        
                        <div class="flex gap-3 justify-center">
                            <button onclick="claimWorldCupVictory(); this.closest('div.fixed').remove();" class="px-6 py-3 bg-yellow-600 text-white hover:bg-yellow-700 rounded-lg font-medium">
                                üèÜ Advance to Test Series
                            </button>
                            <button onclick="this.closest('div.fixed').remove(); startNewSeason();" class="px-6 py-3 bg-green-600 text-white hover:bg-green-700 rounded-lg font-medium">
                                üîÑ New World Cup
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Show World Cup elimination modal
        function showWorldCupEliminationModal() {
            const phase = worldCupState.phase;
            const phaseNames = {
                'groups': 'Group Stage',
                'round16': 'Round of 16',
                'quarters': 'Quarter-Finals',
                'semis': 'Semi-Finals',
                'final': 'Final'
            };
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-lg w-full">
                    <div class="p-6 text-center">
                        <div class="text-6xl mb-4">üíî</div>
                        <h2 class="text-2xl font-bold mb-4">World Cup Journey Ends</h2>
                        <p class="text-lg mb-6">Your World Cup campaign ended in the ${phaseNames[phase]}. Every champion has faced setbacks - learn and come back stronger!</p>
                        
                        <div class="bg-blue-50 dark:bg-blue-900 rounded-lg p-4 mb-6">
                            <h3 class="font-bold mb-3">üìà Experience Gained:</h3>
                            <p>‚Ä¢ World Cup experience valuable for future campaigns</p>
                            <p>‚Ä¢ Players gained international exposure</p>
                            <p>‚Ä¢ Training caps remain at World Cup level</p>
                        </div>
                        
                        <div class="flex gap-3 justify-center">
                            <button onclick="this.closest('div.fixed').remove(); startNewSeason();" class="px-6 py-3 bg-blue-600 text-white hover:bg-blue-700 rounded-lg font-medium">
                                üîÑ Try World Cup Again
                            </button>
                            <button onclick="this.closest('div.fixed').remove();" class="px-6 py-3 bg-gray-500 text-white hover:bg-gray-600 rounded-lg font-medium">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Claim World Cup victory
        function claimWorldCupVictory() {
            // Award prize money
            gameState.budget += 100000;
            document.getElementById('budget').textContent = gameState.budget;
            
            // Unlock Test World Series
            gameState.competitions.test.unlocked = true;
            document.getElementById('test-btn').disabled = false;
            document.getElementById('test-btn').classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400', 'cursor-not-allowed');
            document.getElementById('test-btn').classList.add('bg-purple-500', 'text-white');
            
            // Mark World Cup as completed
            gameState.competitions.worldcup.completed = true;
            
            // Age players and enhance their abilities
            gameState.players.forEach(player => {
                player.age++;
                // World Cup winners get extra training cap boost
                Object.keys(player.talentCeiling).forEach(skill => {
                    const increase = Math.floor(Math.random() * 6) + 5; // 5-10 increase
                    player.talentCeiling[skill] = Math.min(100, player.talentCeiling[skill] + increase);
                });
            });
            
            displayPlayers();
            autoSave();
            
            showCustomAlert('üèÜ Test World Series unlocked! Your players have reached legendary status with enhanced training potential!');
        }
        
        // Update World Cup display
        function updateWorldCupDisplay() {
            if (!worldCupState.isWorldCupActive) return;
            
            // Update competition title
            if (worldCupState.phase === 'groups') {
                document.getElementById('competition-title').textContent = `World Cup - Group Stage ${worldCupState.currentGroupStage}/3`;
                document.getElementById('league-title').textContent = 'World Cup Group Standings';
            } else {
                const phaseNames = {
                    'round16': 'Quarter-Finals',
                    'quarters': 'Semi-Finals', 
                    'semis': 'Final',
                    'final': 'World Cup Final'
                };
                document.getElementById('competition-title').textContent = `World Cup - ${phaseNames[worldCupState.phase]}`;
                document.getElementById('league-title').textContent = `World Cup ${phaseNames[worldCupState.phase]} Bracket`;
            }
            
            // Update standings display based on phase
            if (worldCupState.phase === 'groups') {
                updateWorldCupGroupStandings();
            } else if (worldCupState.phase === 'round16') {
                updateWorldCupQuarterFinalsDisplay();
            } else if (worldCupState.phase === 'quarters') {
                updateWorldCupSemiFinalsDisplay();
            } else if (worldCupState.phase === 'semis' || worldCupState.phase === 'final') {
                updateWorldCupFinalDisplay();
            }
        }
        
        // Update World Cup group standings display
        function updateWorldCupGroupStandings() {
            const standingsList = document.getElementById('standings-list');
            
            let standingsHTML = '';
            
            worldCupState.groups.forEach(group => {
                // Sort group standings
                const sortedStandings = [...group.standings].sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    return b.netRunRate - a.netRunRate;
                });
                
                standingsHTML += `
                    <div class="mb-6">
                        <h4 class="font-bold text-lg mb-3 text-blue-600 dark:text-blue-400">Group ${group.name}</h4>
                        
                        <!-- Group Header -->
                        <div class="grid grid-cols-6 gap-2 p-3 bg-gray-200 dark:bg-gray-700 text-xs font-medium">
                            <div>Team</div>
                            <div class="text-center">P</div>
                            <div class="text-center">W</div>
                            <div class="text-center">L</div>
                            <div class="text-center">Pts</div>
                            <div class="text-center">NRR</div>
                        </div>
                `;
                
                sortedStandings.forEach((team, index) => {
                    const position = index + 1;
                    const bgColor = team.isPlayer ? 'bg-blue-50 dark:bg-blue-900' : 'bg-white dark:bg-gray-800';
                    const textColor = team.isPlayer ? 'font-bold text-blue-800 dark:text-blue-200' : '';
                    const qualificationColor = position <= 2 ? 'border-l-4 border-green-500' : 'border-l-4 border-red-500';
                    
                    standingsHTML += `
                        <div class="grid grid-cols-6 gap-2 p-3 border-b border-gray-200 dark:border-gray-700 ${bgColor} ${qualificationColor}">
                            <div class="${textColor}">${position}. ${team.name}</div>
                            <div class="text-center text-xs">${team.gamesPlayed}</div>
                            <div class="text-center text-xs">${team.wins}</div>
                            <div class="text-center text-xs">${team.losses}</div>
                            <div class="text-center text-xs font-medium">${team.points}</div>
                            <div class="text-center text-xs">${team.netRunRate.toFixed(2)}</div>
                        </div>
                    `;
                });
                
                standingsHTML += '</div>';
            });
            
            // Add qualification legend
            standingsHTML += `
                <div class="mt-4 p-3 bg-gray-50 dark:bg-gray-800 rounded">
                    <h5 class="font-bold mb-2">Qualification Status:</h5>
                    <div class="flex items-center mb-1">
                        <div class="w-4 h-4 bg-green-500 mr-2"></div>
                        <span class="text-sm">Qualified for Quarter-Finals (Top 2)</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-4 h-4 bg-red-500 mr-2"></div>
                        <span class="text-sm">Eliminated (Bottom 2)</span>
                    </div>
                </div>
            `;
            
            standingsList.innerHTML = standingsHTML;
        }
        
        // Update World Cup Quarter-Finals display
        function updateWorldCupQuarterFinalsDisplay() {
            const standingsList = document.getElementById('standings-list');
            
            // Get qualified teams from groups
            const qualifiedTeams = getQualifiedTeams();
            
            let bracketsHTML = `
                <div class="space-y-6">
                    <div class="text-center mb-6">
                        <h3 class="text-xl font-bold text-blue-600 dark:text-blue-400">Quarter-Finals Bracket</h3>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Single elimination - one loss and you're out!</p>
                    </div>
            `;
            
            // Quarter-Finals format:
            // QF1: Group A 1st vs Group D 2nd
            // QF2: Group B 1st vs Group C 2nd
            // QF3: Group C 1st vs Group B 2nd
            // QF4: Group D 1st vs Group A 2nd
            
            const quarterFinals = [
                { 
                    game: 'Game 1', 
                    team1: qualifiedTeams.A ? qualifiedTeams.A[0] : 'Group A 1st',
                    team2: qualifiedTeams.D ? qualifiedTeams.D[1] : 'Group D 2nd',
                    description: 'Group A Winner vs Group D Runner-up'
                },
                { 
                    game: 'Game 2', 
                    team1: qualifiedTeams.B ? qualifiedTeams.B[0] : 'Group B 1st',
                    team2: qualifiedTeams.C ? qualifiedTeams.C[1] : 'Group C 2nd',
                    description: 'Group B Winner vs Group C Runner-up'
                },
                { 
                    game: 'Game 3', 
                    team1: qualifiedTeams.C ? qualifiedTeams.C[0] : 'Group C 1st',
                    team2: qualifiedTeams.B ? qualifiedTeams.B[1] : 'Group B 2nd',
                    description: 'Group C Winner vs Group B Runner-up'
                },
                { 
                    game: 'Game 4', 
                    team1: qualifiedTeams.D ? qualifiedTeams.D[0] : 'Group D 1st',
                    team2: qualifiedTeams.A ? qualifiedTeams.A[1] : 'Group A 2nd',
                    description: 'Group D Winner vs Group A Runner-up'
                }
            ];
            
            quarterFinals.forEach(qf => {
                const isPlayerMatch = qf.team1 === gameState.teamName || qf.team2 === gameState.teamName;
                const highlightClass = isPlayerMatch ? 'border-2 border-blue-500 bg-blue-50 dark:bg-blue-900' : 'bg-white dark:bg-gray-800';
                
                bracketsHTML += `
                    <div class="p-4 rounded-lg border ${highlightClass}">
                        <h4 class="font-bold text-lg mb-2">${qf.game}: Quarter-Final</h4>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mb-3">${qf.description}</p>
                        <div class="flex items-center justify-center space-x-4">
                            <div class="flex-1 text-center p-3 bg-gray-100 dark:bg-gray-700 rounded">
                                <span class="font-medium">${qf.team1}</span>
                            </div>
                            <div class="text-xl font-bold">VS</div>
                            <div class="flex-1 text-center p-3 bg-gray-100 dark:bg-gray-700 rounded">
                                <span class="font-medium">${qf.team2}</span>
                            </div>
                        </div>
                        ${isPlayerMatch ? '<div class="text-center mt-2 text-blue-600 dark:text-blue-400 font-medium">üèè Your Match!</div>' : ''}
                    </div>
                `;
            });
            
            bracketsHTML += '</div>';
            
            standingsList.innerHTML = bracketsHTML;
        }
        
        // Update World Cup Semi-Finals display
        function updateWorldCupSemiFinalsDisplay() {
            const standingsList = document.getElementById('standings-list');
            
            let bracketsHTML = `
                <div class="space-y-6">
                    <div class="text-center mb-6">
                        <h3 class="text-xl font-bold text-blue-600 dark:text-blue-400">Semi-Finals Bracket</h3>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Four teams remain - two steps from glory!</p>
                    </div>
            `;
            
            // Semi-Finals format:
            // SF1: QF1 winner vs QF2 winner
            // SF2: QF3 winner vs QF4 winner
            
            const semiFinals = [
                { 
                    game: 'Game 5', 
                    team1: 'Game 1 Winner',
                    team2: 'Game 2 Winner',
                    description: 'Semi-Final 1'
                },
                { 
                    game: 'Game 6', 
                    team1: 'Game 3 Winner',
                    team2: 'Game 4 Winner',
                    description: 'Semi-Final 2'
                }
            ];
            
            // Try to get actual team names if available
            if (worldCupState.knockoutBracket.semis && worldCupState.knockoutBracket.semis.length > 0) {
                semiFinals[0].team1 = worldCupState.knockoutBracket.semis[0].team1;
                semiFinals[0].team2 = worldCupState.knockoutBracket.semis[0].team2;
            }
            if (worldCupState.knockoutBracket.semis && worldCupState.knockoutBracket.semis.length > 1) {
                semiFinals[1].team1 = worldCupState.knockoutBracket.semis[1].team1;
                semiFinals[1].team2 = worldCupState.knockoutBracket.semis[1].team2;
            }
            
            semiFinals.forEach(sf => {
                const isPlayerMatch = sf.team1 === gameState.teamName || sf.team2 === gameState.teamName;
                const highlightClass = isPlayerMatch ? 'border-2 border-blue-500 bg-blue-50 dark:bg-blue-900' : 'bg-white dark:bg-gray-800';
                
                bracketsHTML += `
                    <div class="p-4 rounded-lg border ${highlightClass}">
                        <h4 class="font-bold text-lg mb-2">${sf.game}: ${sf.description}</h4>
                        <div class="flex items-center justify-center space-x-4">
                            <div class="flex-1 text-center p-3 bg-gray-100 dark:bg-gray-700 rounded">
                                <span class="font-medium">${sf.team1}</span>
                            </div>
                            <div class="text-xl font-bold">VS</div>
                            <div class="flex-1 text-center p-3 bg-gray-100 dark:bg-gray-700 rounded">
                                <span class="font-medium">${sf.team2}</span>
                            </div>
                        </div>
                        ${isPlayerMatch ? '<div class="text-center mt-2 text-blue-600 dark:text-blue-400 font-medium">üèè Your Match!</div>' : ''}
                    </div>
                `;
            });
            
            bracketsHTML += '</div>';
            
            standingsList.innerHTML = bracketsHTML;
        }
        
        // Update World Cup Final display
        function updateWorldCupFinalDisplay() {
            const standingsList = document.getElementById('standings-list');
            
            let bracketsHTML = `
                <div class="space-y-6">
                    <div class="text-center mb-6">
                        <h3 class="text-xl font-bold text-yellow-600 dark:text-yellow-400">üèÜ WORLD CUP FINAL üèÜ</h3>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">The ultimate showdown - one match for eternal glory!</p>
                    </div>
            `;
            
            // Final format:
            // Final: SF1 winner vs SF2 winner
            let finalTeam1 = 'Game 5 Winner';
            let finalTeam2 = 'Game 6 Winner';
            
            // Try to get actual team names if available
            if (worldCupState.knockoutBracket.final) {
                finalTeam1 = worldCupState.knockoutBracket.final.team1;
                finalTeam2 = worldCupState.knockoutBracket.final.team2;
            }
            
            const isPlayerMatch = finalTeam1 === gameState.teamName || finalTeam2 === gameState.teamName;
            const highlightClass = isPlayerMatch ? 'border-2 border-yellow-500 bg-yellow-50 dark:bg-yellow-900' : 'bg-white dark:bg-gray-800';
            
            bracketsHTML += `
                <div class="p-6 rounded-lg border ${highlightClass}">
                    <h4 class="font-bold text-2xl mb-4 text-center">Game 7: World Cup Final</h4>
                    <div class="flex items-center justify-center space-x-6">
                        <div class="flex-1 text-center p-4 bg-gray-100 dark:bg-gray-700 rounded-lg">
                            <span class="font-bold text-lg">${finalTeam1}</span>
                        </div>
                        <div class="text-3xl font-bold text-yellow-600">VS</div>
                        <div class="flex-1 text-center p-4 bg-gray-100 dark:bg-gray-700 rounded-lg">
                            <span class="font-bold text-lg">${finalTeam2}</span>
                        </div>
                    </div>
                    ${isPlayerMatch ? '<div class="text-center mt-4 text-yellow-600 dark:text-yellow-400 font-bold text-lg">üèÜ YOU ARE IN THE FINAL! üèÜ</div>' : ''}
                </div>
            `;
            
            // Add tournament path summary
            bracketsHTML += `
                <div class="mt-8 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
                    <h5 class="font-bold mb-3">Tournament Path to Final:</h5>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-2 text-center">
                        <div class="p-2 bg-green-100 dark:bg-green-900 rounded">
                            <div class="font-medium">Group Stage</div>
                            <div class="text-sm">Top 2 from 4 groups</div>
                        </div>
                        <div class="p-2 bg-blue-100 dark:bg-blue-900 rounded">
                            <div class="font-medium">Quarter-Finals</div>
                            <div class="text-sm">8 teams ‚Üí 4 teams</div>
                        </div>
                        <div class="p-2 bg-purple-100 dark:bg-purple-900 rounded">
                            <div class="font-medium">Semi-Finals</div>
                            <div class="text-sm">4 teams ‚Üí 2 teams</div>
                        </div>
                        <div class="p-2 bg-yellow-100 dark:bg-yellow-900 rounded">
                            <div class="font-medium">Final</div>
                            <div class="text-sm">2 teams ‚Üí 1 Champion</div>
                        </div>
                    </div>
                </div>
            `;
            
            bracketsHTML += '</div>';
            
            standingsList.innerHTML = bracketsHTML;
        }
        
        // Get qualified teams from groups
        function getQualifiedTeams() {
            const qualified = {};
            
            worldCupState.groups.forEach(group => {
                const sortedStandings = [...group.standings].sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    return b.netRunRate - a.netRunRate;
                });
                
                qualified[group.name] = [
                    sortedStandings[0].name, // 1st place
                    sortedStandings[1].name  // 2nd place
                ];
            });
            
            return qualified;
        }
        
        // Generate round-robin matches for a specific round with proper home/away alternation
        function generateRoundRobinMatches(teams, roundNumber) {
            const matches = [];
            const numTeams = teams.length;
            
            if (numTeams % 2 === 1) {
                // Odd number of teams - one team gets a bye
                const activeTeams = [...teams];
                // Rotate teams for round-robin
                if (roundNumber > 1) {
                    const rotated = activeTeams.slice(1, (roundNumber - 1) % (numTeams - 1) + 1);
                    const remaining = activeTeams.slice((roundNumber - 1) % (numTeams - 1) + 1);
                    activeTeams.splice(1, numTeams - 1, ...remaining, ...rotated);
                }
                
                // Pair teams (skip last one for bye)
                for (let i = 0; i < activeTeams.length - 1; i += 2) {
                    if (i + 1 < activeTeams.length) {
                        // Alternate home/away based on round and team pairing
                        const isHomeFirst = (roundNumber + i) % 2 === 0;
                        matches.push({
                            team1: isHomeFirst ? activeTeams[i] : activeTeams[i + 1],
                            team2: isHomeFirst ? activeTeams[i + 1] : activeTeams[i]
                        });
                    }
                }
            } else {
                // Even number of teams - everyone plays
                const activeTeams = [...teams];
                
                // Round-robin rotation: keep first team fixed, rotate others
                if (roundNumber > 1) {
                    const firstTeam = activeTeams[0];
                    const otherTeams = activeTeams.slice(1);
                    
                    // Rotate other teams
                    const rotations = (roundNumber - 1) % (numTeams - 1);
                    for (let r = 0; r < rotations; r++) {
                        otherTeams.push(otherTeams.shift());
                    }
                    
                    activeTeams.splice(0, numTeams, firstTeam, ...otherTeams);
                }
                
                // Generate matches with proper home/away allocation
                for (let i = 0; i < numTeams / 2; i++) {
                    const team1Index = i;
                    const team2Index = numTeams - 1 - i;
                    
                    if (team1Index !== team2Index) {
                        // Alternate home/away: team1 is home in odd rounds, away in even rounds
                        const team1IsHome = (roundNumber + i) % 2 === 1;
                        matches.push({
                            team1: team1IsHome ? activeTeams[team1Index] : activeTeams[team2Index],
                            team2: team1IsHome ? activeTeams[team2Index] : activeTeams[team1Index]
                        });
                    }
                }
            }
            
            return matches;
        }

        // Update match day report display
        function updateMatchDayReport() {
            document.getElementById('opponent-name').textContent = matchState.opponent.name;
            document.getElementById('opponent-team-name').textContent = matchState.opponent.name;
            document.getElementById('home-away').textContent = matchState.isHomeGame ? 'Home Match' : 'Away Match';
            document.getElementById('pitch-type').textContent = matchState.pitchType;
            document.getElementById('weather-conditions').textContent = matchState.weather;
            
            // CRITICAL: Enable scouting for first away game after local games
            if (!matchState.isHomeGame && marketState.gamesPlayedSinceScouts >= 1) {
                marketState.scoutingEnabled = true;
                updateScoutButtonState();
            }
            
            // Update advantages/effects
            const homeAdvantage = document.getElementById('home-advantage');
            if (matchState.isHomeGame) {
                homeAdvantage.textContent = 'üè† Home crowd advantage: +5% motivation boost';
                homeAdvantage.className = 'text-sm text-green-600 dark:text-green-400 text-xs mt-1';
            } else {
                homeAdvantage.textContent = '‚úàÔ∏è Away match: -3% motivation, +2% experience';
                homeAdvantage.className = 'text-sm text-orange-600 dark:text-orange-400 text-xs mt-1';
            }
            
            // Update pitch effects
            const conditionsEffect = document.getElementById('conditions-effect');
            const pitchEffects = {
                'Fast Pitch': '‚ö° Favors fast bowlers and power hitters',
                'Slow Pitch': 'üêå Favors spin bowlers and patient batters',
                'Bouncy Pitch': 'üèÄ Favors tall bowlers and pull shots',
                'Spinning Pitch': 'üå™Ô∏è Heavily favors spin bowlers',
                'Green Pitch': 'üå± Favors seam and swing bowlers'
            };
            
            conditionsEffect.textContent = pitchEffects[matchState.pitchType] || 'Standard playing conditions';
        }

        // Generate opponent XI with strategic bowling composition based on pitch
        function generateOpponentXI() {
            // Separate players by type
            const batters = matchState.opponent.players.filter(p => p.type === 'Batter');
            const bowlers = matchState.opponent.players.filter(p => p.type === 'Bowler');
            const allRounders = matchState.opponent.players.filter(p => p.type === 'All-rounder');
            
            // Sort batters by batting average (best first)
            batters.sort((a, b) => (b.battingAverage || 0) - (a.battingAverage || 0));
            
            // Strategic bowling selection based on pitch conditions
            const pitchBowlingPreference = {
                'Fast Pitch': ['Fast', 'Medium'],
                'Slow Pitch': ['Off-spin', 'Leg-spin', 'Medium'],
                'Bouncy Pitch': ['Fast', 'Medium'],
                'Spinning Pitch': ['Off-spin', 'Leg-spin'],
                'Green Pitch': ['Swing', 'Medium', 'Fast']
            };
            
            const preferredBowlingTypes = pitchBowlingPreference[matchState.pitchType] || ['Fast', 'Medium', 'Off-spin'];
            
            // Score bowlers and all-rounders based on pitch suitability
            const scoreBowler = (player) => {
                let score = (player.totalWickets || 0) - (player.economyRate || 10);
                // Bonus for preferred bowling types on this pitch
                if (preferredBowlingTypes.includes(player.bowlingType)) {
                    score += 20;
                }
                return score;
            };
            
            // Sort bowlers by pitch suitability and skill
            bowlers.sort((a, b) => scoreBowler(b) - scoreBowler(a));
            
            // Sort all-rounders by combined value (batting + bowling + pitch suitability)
            allRounders.sort((a, b) => {
                const aStrength = (a.battingAverage || 0) + scoreBowler(a);
                const bStrength = (b.battingAverage || 0) + scoreBowler(b);
                return bStrength - aStrength;
            });
            
            // Build XI strategically: minimum 4 bowlers, maximum 6
            const selectedXI = [];
            const bowlingCapableCount = (player) => player.type === 'Bowler' || player.type === 'All-rounder';
            
            // Always select best 3 batters for top order
            selectedXI.push(...batters.slice(0, 3));
            
            // Select 1-2 best all-rounders for middle order
            selectedXI.push(...allRounders.slice(0, 2));
            
            // Count current bowlers
            let bowlerCount = selectedXI.filter(bowlingCapableCount).length;
            
            // Add remaining players to reach 11, ensuring 4-6 bowlers
            const remainingSlots = 11 - selectedXI.length;
            const remainingPlayers = [
                ...batters.slice(3),
                ...allRounders.slice(2),
                ...bowlers
            ].sort((a, b) => {
                // Prioritize bowlers if we need more
                if (bowlerCount < 4) {
                    if (bowlingCapableCount(a) && !bowlingCapableCount(b)) return -1;
                    if (!bowlingCapableCount(a) && bowlingCapableCount(b)) return 1;
                }
                // Otherwise select by overall strength
                const aStrength = (a.battingAverage || 0) + scoreBowler(a);
                const bStrength = (b.battingAverage || 0) + scoreBowler(b);
                return bStrength - aStrength;
            });
            
            // Fill remaining slots
            for (let i = 0; i < remainingSlots && i < remainingPlayers.length; i++) {
                const player = remainingPlayers[i];
                selectedXI.push(player);
                if (bowlingCapableCount(player)) {
                    bowlerCount++;
                }
                // Don't exceed 6 bowlers
                if (bowlerCount >= 6 && remainingSlots - i > 1) {
                    // Fill remaining with best available batters
                    const remainingBatters = remainingPlayers.slice(i + 1).filter(p => !bowlingCapableCount(p));
                    selectedXI.push(...remainingBatters.slice(0, remainingSlots - i - 1));
                    break;
                }
            }
            
            // Ensure exactly 11 players
            matchState.opponentXI = selectedXI.slice(0, 11);
            
            // Reorder for proper batting order: batters first, all-rounders middle, bowlers last
            const finalXI = [];
            const xiByType = {
                batters: matchState.opponentXI.filter(p => p.type === 'Batter'),
                allRounders: matchState.opponentXI.filter(p => p.type === 'All-rounder'),
                bowlers: matchState.opponentXI.filter(p => p.type === 'Bowler')
            };
            
            // Build batting order: batters (1-6), all-rounders (7-9), bowlers (10-11)
            finalXI.push(...xiByType.batters);
            finalXI.push(...xiByType.allRounders);
            finalXI.push(...xiByType.bowlers);
            
            matchState.opponentXI = finalXI;
            
            // Select captain (usually top batter or experienced all-rounder)
            const captain = matchState.opponentXI[0] || matchState.opponentXI.find(p => p.type === 'All-rounder');
            if (captain) captain.isCaptain = true;
            
            // Select wicket keeper (prefer designated WK, otherwise middle-order player)
            let wicketKeeper = matchState.opponentXI.find(p => p.isWicketKeeper);
            if (!wicketKeeper) {
                // Select from middle order (positions 4-7)
                wicketKeeper = matchState.opponentXI.slice(3, 7).find(p => p.type === 'All-rounder') || matchState.opponentXI[4];
                if (wicketKeeper) wicketKeeper.isWicketKeeper = true;
            }
            
            displayOpponentXI();
        }

        // Display opponent XI
        function displayOpponentXI() {
            const opponentXIDiv = document.getElementById('opponent-team-xi');
            
            opponentXIDiv.innerHTML = matchState.opponentXI.map((player, index) => {
                const battingStats = (player.type === 'Batter' || player.type === 'All-rounder') 
                    ? `Runs: ${player.totalRuns} | Avg: ${player.battingAverage} | S/R: ${player.strikeRate}`
                    : `${player.bowlingType} | Best: ${player.bestBowling} | Econ: ${player.economyRate.toFixed(1)}`;
                
                let playerRole = '';
                if (player.isCaptain) playerRole += ' (C)';
                if (player.isWicketKeeper) playerRole += ' (WK)';
                
                return `
                    <div class="text-sm p-2 bg-white dark:bg-gray-700 rounded border">
                        <div class="font-medium">${index + 1}. ${player.name}${playerRole}</div>
                        <div class="text-xs text-gray-600 dark:text-gray-400">${battingStats}</div>
                    </div>
                `;
            }).join('');
        }

        // Update player selector for XI selection
        function updatePlayerSelector() {
            const selector = document.getElementById('player-selector');
            
            // Auto-add captain to XI if not already selected
            const captain = gameState.players.find(p => p.isCaptain);
            if (captain && !matchState.selectedXI.includes(captain.name) && matchState.selectedXI.length < 11) {
                matchState.selectedXI.push(captain.name);
                displayYourXI();
            }
            
            // Filter available players - exclude injured, already selected, AND the captain
            const availablePlayers = gameState.players.filter(p => 
                !p.isInjured && 
                !matchState.selectedXI.includes(p.name) &&
                !p.isCaptain  // Remove captain from dropdown since they're auto-added
            );
            
            selector.innerHTML = '<option value="">Choose a player...</option>' +
                availablePlayers.map(player => {
                    let playerStats = '';
                    if (player.type === 'Batter') {
                        playerStats = `HS: ${player.highScore} | Avg: ${player.battingAverage} | S/R: ${player.strikeRate}`;
                    } else if (player.type === 'Bowler') {
                        playerStats = `${player.bowlingType} | Best: ${player.bestBowling} | Econ: ${player.economyRate.toFixed(1)} | Wkts: ${player.totalWickets}`;
                    } else if (player.type === 'All-rounder') {
                        playerStats = `Avg: ${player.battingAverage} | Best: ${player.bestBowling} | ${player.bowlingType}`;
                    }
                    
                    // Add (WK) tag for wicket keepers in dropdown
                    const playerDisplayName = player.isWicketKeeper ? `${player.name} (WK)` : player.name;
                    
                    return `<option value="${player.name}">${playerDisplayName} - ${playerStats}</option>`;
                }).join('');
        }

        // Select player for XI
        function selectPlayerForXI() {
            const selector = document.getElementById('player-selector');
            const playerName = selector.value;
            
            if (playerName && matchState.selectedXI.length < 11) {
                matchState.selectedXI.push(playerName);
                displayYourXI();
                updatePlayerSelector();
                selector.value = '';
            }
        }

        // Display your XI with drag and drop support
        function displayYourXI() {
            const yourXIDiv = document.getElementById('your-team-xi');
            
            if (matchState.selectedXI.length === 0) {
                yourXIDiv.innerHTML = '<p class="text-gray-500 text-sm">No players selected</p>';
                return;
            }
            
            yourXIDiv.innerHTML = matchState.selectedXI.map((playerName, index) => {
                const player = gameState.players.find(p => p.name === playerName);
                const battingStats = (player.type === 'Batter' || player.type === 'All-rounder') 
                    ? `HS: ${player.highScore} | Avg: ${player.battingAverage} | S/R: ${player.strikeRate}`
                    : `${player.bowlingType} | Best: ${player.bestBowling} | Econ: ${player.economyRate.toFixed(1)}`;
                
                let playerRole = '';
                if (player.isCaptain) playerRole += ' (C)';
                if (player.isWicketKeeper) playerRole += ' (WK)';
                
                // Player type indicator with color coding
                const playerTypeColor = player.type === 'Batter' ? 'bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200' :
                                       player.type === 'Bowler' ? 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200' :
                                       'bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200';
                
                return `
                    <div class="xi-player-item text-sm p-2 bg-white dark:bg-gray-700 rounded border hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors select-none" 
                         data-player-name="${playerName}"
                         data-position="${index}"
                         style="touch-action: none; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;">
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-2 flex-1">
                                <div class="text-gray-500 dark:text-gray-400 font-mono text-xs w-6">
                                    ${index + 1}.
                                </div>
                                <!-- Mobile-friendly reorder buttons -->
                                <div class="flex flex-col gap-1">
                                    <button onclick="movePlayerUp(${index})" 
                                            class="text-blue-500 hover:text-blue-700 text-xs w-4 h-4 flex items-center justify-center ${index === 0 ? 'invisible' : ''}"
                                            title="Move up">
                                        ‚ñ≤
                                    </button>
                                    <button onclick="movePlayerDown(${index})" 
                                            class="text-blue-500 hover:text-blue-700 text-xs w-4 h-4 flex items-center justify-center ${index === matchState.selectedXI.length - 1 ? 'invisible' : ''}"
                                            title="Move down">
                                        ‚ñº
                                    </button>
                                </div>
                                <div class="flex-1 min-w-0">
                                    <div class="font-medium flex items-center gap-2 flex-wrap">
                                        <span class="truncate">${player.name}${playerRole}</span>
                                        <span class="text-xs px-2 py-1 rounded ${playerTypeColor} flex-shrink-0">${player.type}</span>
                                    </div>
                                    <div class="text-xs text-gray-600 dark:text-gray-400 truncate">${battingStats}</div>
                                </div>
                            </div>
                            <button onclick="removeFromXI('${playerName}')" 
                                    class="text-red-500 hover:text-red-700 text-xs ml-2 px-2 py-1 rounded hover:bg-red-50 dark:hover:bg-red-900 flex-shrink-0">
                                Remove
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add drag and drop event listeners
            addDragAndDropListeners();
        }
        
        // Add drag and drop functionality
        function addDragAndDropListeners() {
            const playerItems = document.querySelectorAll('.xi-player-item');
            
            playerItems.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
            });
        }
        
        let draggedElement = null;
        
        function handleDragStart(e) {
            draggedElement = this;
            this.style.opacity = '0.5';
            
            // Add visual feedback
            this.classList.add('border-2', 'border-blue-400', 'border-dashed');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            
            // Add visual feedback for drop zones
            if (this !== draggedElement) {
                this.classList.add('border-t-4', 'border-green-400');
            }
        }
        
        function handleDrop(e) {
            e.preventDefault();
            
            if (this !== draggedElement) {
                const draggedPlayerName = draggedElement.dataset.playerName;
                const targetPosition = parseInt(this.dataset.position);
                
                // Reorder the selectedXI array
                reorderSelectedXI(draggedPlayerName, targetPosition);
                
                // Refresh the display
                displayYourXI();
            }
            
            // Remove visual feedback
            document.querySelectorAll('.xi-player-item').forEach(item => {
                item.classList.remove('border-t-4', 'border-green-400');
            });
        }
        
        function handleDragEnd(e) {
            this.style.opacity = '';
            this.classList.remove('border-2', 'border-blue-400', 'border-dashed');
            
            // Remove all visual feedback
            document.querySelectorAll('.xi-player-item').forEach(item => {
                item.classList.remove('border-t-4', 'border-green-400');
            });
            
            draggedElement = null;
        }
        
        // Reorder selected XI array based on drag and drop
        function reorderSelectedXI(playerName, newPosition) {
            // Find current position of dragged player
            const currentPosition = matchState.selectedXI.indexOf(playerName);
            
            if (currentPosition === -1) return;
            
            // Remove player from current position
            const player = matchState.selectedXI.splice(currentPosition, 1)[0];
            
            // Insert at new position
            matchState.selectedXI.splice(newPosition, 0, player);
            
            console.log(`Moved ${playerName} from position ${currentPosition + 1} to position ${newPosition + 1}`);
        }
        
        // Mobile-friendly move player up function
        function movePlayerUp(index) {
            if (index <= 0) return; // Already at top
            
            // Swap with player above
            const temp = matchState.selectedXI[index];
            matchState.selectedXI[index] = matchState.selectedXI[index - 1];
            matchState.selectedXI[index - 1] = temp;
            
            // Refresh display
            displayYourXI();
        }
        
        // Mobile-friendly move player down function  
        function movePlayerDown(index) {
            if (index >= matchState.selectedXI.length - 1) return; // Already at bottom
            
            // Swap with player below
            const temp = matchState.selectedXI[index];
            matchState.selectedXI[index] = matchState.selectedXI[index + 1];
            matchState.selectedXI[index + 1] = temp;
            
            // Refresh display
            displayYourXI();
        }

        // Remove player from XI
        function removeFromXI(playerName) {
            matchState.selectedXI = matchState.selectedXI.filter(name => name !== playerName);
            displayYourXI();
            updatePlayerSelector();
        }

        // Start match
        function startMatch() {
            if (matchState.selectedXI.length !== 11) {
                showCustomAlert('Please select exactly 11 players for your team!');
                return;
            }
            
            if (!gameState.players.some(p => p.isCaptain)) {
                showCustomAlert('Please select a team captain from the Roster tab!');
                return;
            }
            
            // CRITICAL: Reset training tab to overview when match starts
            resetTrainingTabToOverview();
            
            // Show live match details
            document.getElementById('live-match-details').style.display = 'block';
            
            // Start match simulation
            simulateMatchPlay();
        }

        // Cricket match simulation system
        let currentMatch = null;
        let matchInterval = null;

        class CricketMatch {
            constructor(team1, team2, pitchType, weather, isHomeGame) {
                this.team1 = team1;
                this.team2 = team2;
                this.pitchType = pitchType;
                this.weather = weather;
                this.isHomeGame = isHomeGame;
                
                // Get playing XIs
                this.team1Players = team1.isPlayer ? 
                    matchState.selectedXI.map(name => gameState.players.find(p => p.name === name)) :
                    team1.selectXI(pitchType);
                this.team2Players = team2.isPlayer ? 
                    matchState.selectedXI.map(name => gameState.players.find(p => p.name === name)) :
                    team2.selectXI(pitchType);
                
                // Initialize match stats
                this.tossWinner = Math.random() < 0.5 ? team1 : team2;
                this.battingFirst = this.decideBattingFirst();
                this.fieldingFirst = this.battingFirst === team1 ? team2 : team1;
                
                this.innings = 1;
                this.currentOver = 1;
                this.currentBall = 1;
                this.totalOvers = 50;
                this.powerplayOvers = 10;
                
                this.team1Score = { runs: 0, wickets: 0, overs: 0, balls: 0 };
                this.team2Score = { runs: 0, wickets: 0, overs: 0, balls: 0 };
                this.currentScore = this.battingFirst === team1 ? this.team1Score : this.team2Score;
                
                // Current partnership
                this.striker = 0; // Index in batting order
                this.nonStriker = 1;
                this.currentBowler = null;
                this.bowlerEnd = 'A'; // A or B end
                this.previousBowler = null;
                this.bowlerOverCount = 0;
                
                // Initialize batting and bowling stats for this match
                this.initializeMatchStats();
                
                // Weather interruption chance
                this.rainDelay = false;
                this.oversReduced = 50;
                
                this.overHistory = [];
                this.commentary = [];
            }
            
            decideBattingFirst() {
                const strategy = document.getElementById('toss-strategy').value;
                const tossChoice = strategy === 'captain-choice' ? (Math.random() < 0.5) :
                                 strategy === 'bat-first' ? true :
                                 strategy === 'field-first' ? false :
                                 Math.random() < 0.5;
                
                return (this.tossWinner === this.team1) === tossChoice ? this.team1 : this.team2;
            }
            
            initializeMatchStats() {
                // Initialize match-specific stats for all players
                [...this.team1Players, ...this.team2Players].forEach(player => {
                    player.matchStats = {
                        runs: 0,
                        ballsFaced: 0,
                        fours: 0,
                        sixes: 0,
                        strikeRate: 0,
                        runsConceded: 0,
                        oversBowled: 0,
                        ballsBowled: 0,
                        wicketsTaken: 0,
                        economyRate: 0,
                        // Additional detailed tracking
                        dismissalType: null, // 'bowled', 'caught', 'lbw', 'runout', 'stumped'
                        caughtBy: null,
                        bowlerWhoGotWicket: null,
                        isOut: false,
                        wicketsOfBowler: [] // Array of {batsman, dismissalType, caughtBy}
                    };
                });
                
                // Initialize extras tracking
                this.team1Extras = { wides: 0, noballs: 0, byes: 0, legbyes: 0, total: 0 };
                this.team2Extras = { wides: 0, noballs: 0, byes: 0, legbyes: 0, total: 0 };
            }
            
            getCurrentBattingTeam() {
                return this.innings === 1 ? this.battingFirst : this.fieldingFirst;
            }
            
            getCurrentFieldingTeam() {
                return this.innings === 1 ? this.fieldingFirst : this.battingFirst;
            }
            
            getCurrentBattingOrder() {
                return this.getCurrentBattingTeam() === this.team1 ? this.team1Players : this.team2Players;
            }
            
            getCurrentBowlingTeam() {
                return this.getCurrentFieldingTeam() === this.team1 ? this.team1Players : this.team2Players;
            }
            
            simulateOver() {
                const battingTeam = this.getCurrentBattingOrder();
                const bowlingTeam = this.getCurrentBowlingTeam();
                
                // Select bowler for this over - must change if hitting 10-over limit or other conditions
                if (this.currentOver === 1 || this.shouldChangeBowler()) {
                    this.selectNewBowler(bowlingTeam);
                }
                
                let overRuns = 0;
                let overBalls = [];
                let overWickets = 0;
                let extraBalls = 0;
                
                // Check for weather interruption
                if (this.checkWeatherInterruption()) {
                    return this.handleWeatherInterruption();
                }
                
                // Simulate 6 balls (plus extras)
                for (let ball = 1; ball <= 6 + extraBalls; ball++) {
                    if (this.currentScore.wickets >= 10) break;
                    
                    const result = this.simulateBall(battingTeam, bowlingTeam);
                    overBalls.push(result.display);
                    overRuns += result.runs;
                    
                    if (result.wicket) overWickets++;
                    if (result.extra) extraBalls++;
                    
                    // Handle batting rotation
                    if (!result.extra && result.runs % 2 === 1) {
                        [this.striker, this.nonStriker] = [this.nonStriker, this.striker];
                    }
                }
                
                // End of over - rotate strike
                [this.striker, this.nonStriker] = [this.nonStriker, this.striker];
                
                // Update over count and bowler stats
                this.currentScore.overs++;
                this.bowlerOverCount++;
                this.bowlerEnd = this.bowlerEnd === 'A' ? 'B' : 'A';
                
                // CRITICAL: Update total overs bowled for this bowler (cumulative across match)
                this.currentBowler.matchStats.oversBowled++;
                
                // Create over summary
                const overSummary = {
                    number: this.currentOver,
                    balls: overBalls.join(' '),
                    runs: overRuns,
                    wickets: overWickets,
                    bowler: this.currentBowler.name,
                    commentary: this.generateOverCommentary(overBalls, overRuns, overWickets)
                };
                
                this.overHistory.push(overSummary);
                this.currentOver++;
                
                return overSummary;
            }
            
            simulateBall(battingTeam, bowlingTeam) {
                const striker = battingTeam[this.striker];
                const bowler = this.currentBowler;
                
                // CRITICAL: Get batting strategy and apply captain's choice logic
                const battingStrategy = this.getBattingStrategy(battingTeam);
                
                // Calculate realistic base probabilities (totaling ~1.0)
                let dotProb = 0.45;        // 45% - most common outcome
                let singleProb = 0.30;     // 30% - primary scoring method
                let doubleProb = 0.12;     // 12% - good running
                let tripleProb = 0.02;     // 2% - rare, good running
                let fourProb = 0.06;       // 6% - boundary hitting
                let sixProb = 0.02;        // 2% - aggressive hitting
                let wicketProb = 0.025;    // 2.5% - realistic wicket rate for 50 overs
                let wideProb = 0.015;      // 1.5% - bowling error
                let noBallProb = 0.005;    // 0.5% - rare bowling error
                let byeProb = 0.01;        // 1% - fielding/keeping error
                
                // CRITICAL: Apply batting strategy modifiers
                const strategyModifiers = this.getBattingStrategyModifiers(battingStrategy, battingTeam);
                
                // Apply modifiers to probabilities
                dotProb *= strategyModifiers.dotMultiplier;
                singleProb *= strategyModifiers.singleMultiplier;
                doubleProb *= strategyModifiers.doubleMultiplier;
                tripleProb *= strategyModifiers.tripleMultiplier;
                fourProb *= strategyModifiers.fourMultiplier;
                sixProb *= strategyModifiers.sixMultiplier;
                wicketProb *= strategyModifiers.wicketMultiplier;
                
                // Player skill factors
                const strikerSkill = this.calculateBattingSkill(striker);
                let bowlerSkill = this.calculateBowlingSkill(bowler);
                
                // Non-bowlers are less economical (captain has no choice situation)
                if (bowler.matchStats.emergencyBowler) {
                    bowlerSkill *= 0.6; // 40% reduction in bowling skill for non-bowlers
                }
                
                // Match situation factors
                const situationFactor = this.calculateSituationFactor();
                const powerplayFactor = this.currentOver <= this.powerplayOvers ? 1.2 : 1.0;
                
                // Adjust probabilities based on player skills and situation
                const skillDifferential = strikerSkill - bowlerSkill; // -1 to +1 range
                
                // Better batters: fewer dots, more scoring shots, fewer wickets
                if (skillDifferential > 0) {
                    const advantage = skillDifferential * 0.3; // Max 30% adjustment
                    dotProb *= (1 - advantage * 0.4);
                    singleProb *= (1 + advantage * 0.3);
                    doubleProb *= (1 + advantage * 0.4);
                    fourProb *= (1 + advantage * 0.5);
                    sixProb *= (1 + advantage * 0.6);
                    wicketProb *= (1 - advantage * 0.6);
                }
                // Better bowlers: more dots, fewer scoring shots, more wickets
                else if (skillDifferential < 0) {
                    const advantage = Math.abs(skillDifferential) * 0.3;
                    dotProb *= (1 + advantage * 0.3);
                    singleProb *= (1 - advantage * 0.2);
                    doubleProb *= (1 - advantage * 0.3);
                    fourProb *= (1 - advantage * 0.4);
                    sixProb *= (1 - advantage * 0.5);
                    wicketProb *= (1 + advantage * 0.4);
                }
                
                // Powerplay adjustments (field restrictions)
                if (this.currentOver <= this.powerplayOvers) {
                    fourProb *= 1.3;
                    sixProb *= 1.4;
                    dotProb *= 0.9;
                    singleProb *= 1.1;
                }
                
                // Late innings pressure (last 10 overs)
                if (this.currentOver > 40) {
                    fourProb *= 1.2;
                    sixProb *= 1.3;
                    wicketProb *= 1.1;
                    dotProb *= 0.95;
                }
                
                // Normalize probabilities to ensure they sum to ~1
                const totalProb = dotProb + singleProb + doubleProb + tripleProb + fourProb + sixProb + wicketProb + wideProb + noBallProb + byeProb;
                const normalizeFactor = 1.0 / totalProb;
                
                dotProb *= normalizeFactor;
                singleProb *= normalizeFactor;
                doubleProb *= normalizeFactor;
                tripleProb *= normalizeFactor;
                fourProb *= normalizeFactor;
                sixProb *= normalizeFactor;
                wicketProb *= normalizeFactor;
                wideProb *= normalizeFactor;
                noBallProb *= normalizeFactor;
                byeProb *= normalizeFactor;
                
                // Generate outcome using cumulative probabilities
                const rand = Math.random();
                let cumulative = 0;
                let result = { runs: 0, wicket: false, extra: false, display: '.' };
                
                cumulative += wicketProb;
                if (rand < cumulative) {
                    result = { runs: 0, wicket: true, extra: false, display: 'X' };
                    this.handleWicket(striker, bowler);
                    
                } else {
                    cumulative += wideProb;
                    if (rand < cumulative) {
                        const wideRuns = Math.random() < 0.8 ? 1 : (1 + Math.floor(Math.random() * 2));
                        result = { runs: wideRuns, wicket: false, extra: true, display: `W${wideRuns > 1 ? wideRuns : ''}` };
                        
                    } else {
                        cumulative += noBallProb;
                        if (rand < cumulative) {
                            const noBallRuns = Math.floor(Math.random() * 3); // 0-2 additional runs
                            result = { runs: 1 + noBallRuns, wicket: false, extra: true, display: `nb${noBallRuns > 0 ? noBallRuns : ''}` };
                            
                        } else {
                            cumulative += byeProb;
                            if (rand < cumulative) {
                                const byeRuns = Math.random() < 0.7 ? 1 : (1 + Math.floor(Math.random() * 2));
                                result = { runs: byeRuns, wicket: false, extra: false, display: `lb${byeRuns}` };
                                
                            } else {
                                cumulative += sixProb;
                                if (rand < cumulative) {
                                    result = { runs: 6, wicket: false, extra: false, display: '6' };
                                    striker.matchStats.sixes++;
                                    
                                } else {
                                    cumulative += fourProb;
                                    if (rand < cumulative) {
                                        result = { runs: 4, wicket: false, extra: false, display: '4' };
                                        striker.matchStats.fours++;
                                        
                                    } else {
                                        cumulative += tripleProb;
                                        if (rand < cumulative) {
                                            result = { runs: 3, wicket: false, extra: false, display: '3' };
                                            
                                        } else {
                                            cumulative += doubleProb;
                                            if (rand < cumulative) {
                                                result = { runs: 2, wicket: false, extra: false, display: '2' };
                                                
                                            } else {
                                                cumulative += singleProb;
                                                if (rand < cumulative) {
                                                    result = { runs: 1, wicket: false, extra: false, display: '1' };
                                                } 
                                                // Else dot ball (default)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Update scores and stats
                this.currentScore.runs += result.runs;
                if (!result.extra) {
                    striker.matchStats.ballsFaced++;
                    striker.matchStats.runs += result.runs;
                    bowler.matchStats.ballsBowled++;
                }
                bowler.matchStats.runsConceded += result.runs;
                
                // Update extras tracking
                const currentExtras = this.innings === 1 ? this.team1Extras : this.team2Extras;
                if (result.extra) {
                    if (result.display.startsWith('W')) {
                        currentExtras.wides += result.runs;
                    } else if (result.display.startsWith('nb')) {
                        currentExtras.noballs += result.runs;
                    }
                } else if (result.display.startsWith('lb')) {
                    currentExtras.legbyes += result.runs;
                } else if (result.display.startsWith('b')) {
                    currentExtras.byes += result.runs;
                }
                currentExtras.total = currentExtras.wides + currentExtras.noballs + currentExtras.legbyes + currentExtras.byes;
                
                return result;
            }
            
            // Calculate normalized batting skill (0 to 1)
            calculateBattingSkill(player) {
                // Base skill from batting average (normalized to 0-1)
                let skill = Math.min(player.battingAverage / 60, 1.0); // 60+ average = skill 1.0
                
                // Adjust for strike rate (aggressive vs defensive)
                const strikeRateNorm = Math.min(player.strikeRate / 150, 1.0);
                skill = (skill * 0.7) + (strikeRateNorm * 0.3); // 70% average, 30% strike rate
                
                // Experience factor based on games played
                const experienceFactor = Math.min(player.gamesPlayed / 50, 1.0);
                skill = (skill * 0.8) + (experienceFactor * 0.2);
                
                // Age factor (peak at 26-30, decline after 32)
                let ageFactor = 1.0;
                if (player.age < 22) ageFactor = 0.85; // Young, inexperienced
                else if (player.age < 26) ageFactor = 0.95; // Developing
                else if (player.age <= 30) ageFactor = 1.0; // Prime
                else if (player.age <= 34) ageFactor = 0.95; // Veteran
                else ageFactor = 0.85; // Declining
                
                skill *= ageFactor;
                
                return Math.max(0.1, Math.min(skill, 1.0)); // Clamp between 0.1 and 1.0
            }
            
            // Calculate normalized bowling skill (0 to 1)
            calculateBowlingSkill(player) {
                // Base skill from economy rate (lower is better)
                let skill = Math.max(0, (8 - player.economyRate) / 5); // Economy 3 = skill 1.0, Economy 8 = skill 0
                
                // Adjust for wicket-taking ability
                const wicketRate = Math.min(player.totalWickets / Math.max(player.gamesPlayed, 1) / 3, 1.0); // 3+ wickets per game = 1.0
                skill = (skill * 0.6) + (wicketRate * 0.4); // 60% economy, 40% wickets
                
                // Experience factor
                const experienceFactor = Math.min(player.gamesPlayed / 50, 1.0);
                skill = (skill * 0.8) + (experienceFactor * 0.2);
                
                // Age factor (similar to batting)
                let ageFactor = 1.0;
                if (player.age < 22) ageFactor = 0.85;
                else if (player.age < 26) ageFactor = 0.95;
                else if (player.age <= 30) ageFactor = 1.0;
                else if (player.age <= 34) ageFactor = 0.95;
                else ageFactor = 0.85;
                
                skill *= ageFactor;
                
                return Math.max(0.1, Math.min(skill, 1.0));
            }
            
            // Calculate situation factor (pressure, required run rate, etc.)
            calculateSituationFactor() {
                if (this.innings === 1) {
                    // First innings - consistent batting
                    return 1.0;
                } else {
                    // Second innings - chasing target
                    const target = this.getTarget();
                    const needed = target - this.currentScore.runs;
                    const ballsLeft = (this.oversReduced - this.currentOver + 1) * 6;
                    
                    if (ballsLeft <= 0) return 1.0;
                    
                    const requiredRate = needed / (ballsLeft / 6); // Required run rate per over
                    const currentRate = this.currentScore.runs / Math.max(this.currentOver - 1, 1);
                    
                    // More pressure = more risky shots
                    if (requiredRate > currentRate + 2) {
                        return 1.3; // High pressure - more boundaries, more wickets
                    } else if (requiredRate < currentRate - 2) {
                        return 0.8; // Comfortable chase - more conservative
                    }
                    
                    return 1.0;
                }
            }
            
            handleWicket(striker, bowler) {
                this.currentScore.wickets++;
                bowler.matchStats.wicketsTaken++;
                
                // Generate dismissal type and details
                const dismissalTypes = ['bowled', 'caught', 'lbw', 'runout', 'stumped'];
                const dismissalType = dismissalTypes[Math.floor(Math.random() * dismissalTypes.length)];
                
                // Set dismissal details
                striker.matchStats.isOut = true;
                striker.matchStats.dismissalType = dismissalType;
                striker.matchStats.bowlerWhoGotWicket = bowler.name;
                
                // For caught dismissals, randomly select fielder
                if (dismissalType === 'caught') {
                    const fieldingTeam = this.getCurrentBowlingTeam();
                    const fielders = fieldingTeam.filter(p => p !== bowler);
                    if (fielders.length > 0) {
                        striker.matchStats.caughtBy = fielders[Math.floor(Math.random() * fielders.length)].name;
                    }
                }
                
                // Add to bowler's wickets list
                bowler.matchStats.wicketsOfBowler.push({
                    batsman: striker.name,
                    dismissalType: dismissalType,
                    caughtBy: striker.matchStats.caughtBy || null
                });
                
                // Bring in next batsman
                const nextBatsmanIndex = this.findNextBatsman();
                if (nextBatsmanIndex !== -1) {
                    this.striker = nextBatsmanIndex;
                }
            }
            
            findNextBatsman() {
                const battingOrder = this.getCurrentBattingOrder();
                for (let i = 2; i < battingOrder.length; i++) {
                    if (i !== this.striker && i !== this.nonStriker && battingOrder[i].matchStats.ballsFaced === 0) {
                        return i;
                    }
                }
                return -1;
            }
            
            selectNewBowler(bowlingTeam) {
                this.previousBowler = this.currentBowler;
                
                // CRITICAL: Get available bowlers (excludes current AND previous to prevent consecutive overs)
                let availableBowlers = this.getAvailableBowlers(bowlingTeam);
                
                // Captain's bowling selection logic
                if (availableBowlers.length > 0) {
                    // Sort by bowling skill and form
                    availableBowlers.sort((a, b) => {
                        // Calculate current match economy (if bowled in this match)
                        const aMatchEcon = a.matchStats.ballsBowled > 0 ? 
                            (a.matchStats.runsConceded / Math.max(1, Math.floor(a.matchStats.ballsBowled / 6))) : a.economyRate;
                        const bMatchEcon = b.matchStats.ballsBowled > 0 ? 
                            (b.matchStats.runsConceded / Math.max(1, Math.floor(b.matchStats.ballsBowled / 6))) : b.economyRate;
                        
                        // Prefer bowlers with better current form
                        const aScore = (a.totalWickets / Math.max(a.gamesPlayed, 1)) * 10 - aMatchEcon;
                        const bScore = (b.totalWickets / Math.max(b.gamesPlayed, 1)) * 10 - bMatchEcon;
                        
                        return bScore - aScore;
                    });
                    
                    this.currentBowler = availableBowlers[0];
                }
                // CRITICAL: If no valid bowlers, we have a serious problem - emergency protocol
                else {
                    // Last resort: find ANY player who can bowl (even if violates 10-over limit)
                    // This should only happen in extreme circumstances
                    const emergencyBowlers = bowlingTeam.filter(p => 
                        p !== this.currentBowler &&
                        p !== this.previousBowler // Still can't bowl consecutive overs
                    );
                    
                    if (emergencyBowlers.length > 0) {
                        // Pick best available emergency option
                        emergencyBowlers.sort((a, b) => {
                            // Prefer bowlers/all-rounders over batters
                            const aIsBowler = (a.type === 'Bowler' || a.type === 'All-rounder') ? 1 : 0;
                            const bIsBowler = (b.type === 'Bowler' || b.type === 'All-rounder') ? 1 : 0;
                            
                            if (aIsBowler !== bIsBowler) return bIsBowler - aIsBowler;
                            
                            // Then by experience
                            return b.gamesPlayed - a.gamesPlayed;
                        });
                        
                        this.currentBowler = emergencyBowlers[0];
                        
                        // Mark as emergency bowler if not a natural bowler
                        if (this.currentBowler.type === 'Batter') {
                            this.currentBowler.matchStats.emergencyBowler = true;
                        }
                        

                    }
                }
                
                // Update bowler's match stats
                if (this.currentBowler) {
                    this.bowlerOverCount = 0;
                    // Ensure overs bowled is initialized
                    this.currentBowler.matchStats.oversBowled = this.currentBowler.matchStats.oversBowled || 0;
                }
            }
            
            shouldChangeBowler() {
                if (!this.currentBowler) return true;
                
                // CRITICAL: Check 10-over limit using TOTAL match overs, not consecutive
                if (this.currentBowler.matchStats.oversBowled >= 10) return true;
                
                // CRITICAL: Bowler alternation - same bowler cannot bowl consecutive overs (alternating ends rule)
                if (this.previousBowler && this.currentBowler === this.previousBowler) return true;
                
                // Must bowl minimum 1 over before captain can make changes
                if (this.bowlerOverCount < 1) return false;
                
                // Captain logic for bowling changes after minimum 1 over
                if (this.bowlerOverCount >= 1) {
                    const currentEconomy = this.currentBowler.matchStats.runsConceded / Math.max(1, this.bowlerOverCount);
                    
                    // More aggressive bowling changes based on match situation
                    let economyThreshold = 8.0; // Base threshold
                    
                    // Adjust threshold based on match situation
                    if (this.currentOver <= this.powerplayOvers) {
                        economyThreshold = 9.0; // More lenient during powerplay
                    } else if (this.currentOver > 40) {
                        economyThreshold = 7.0; // More strict in death overs
                    }
                    
                    // Consider changing bowler if economy is poor
                    if (currentEconomy > economyThreshold) {
                        // But only if we have better bowling options available
                        const bowlingTeam = this.getCurrentBowlingTeam();
                        const availableBowlers = this.getAvailableBowlers(bowlingTeam);
                        
                        if (availableBowlers.length > 0) {
                            return Math.random() < 0.7; // 70% chance to change if poor economy
                        }
                    }
                    
                    // Random bowling changes for tactical reasons (every 3-5 overs)
                    if (this.bowlerOverCount >= 3 && Math.random() < 0.3) {
                        const bowlingTeam = this.getCurrentBowlingTeam();
                        const availableBowlers = this.getAvailableBowlers(bowlingTeam);
                        return availableBowlers.length > 0;
                    }
                }
                
                return false;
            }
            
            // Get available bowlers for captain's selection
            getAvailableBowlers(bowlingTeam) {
                // CRITICAL: Exclude previous bowler to prevent consecutive overs (alternating ends rule)
                let availableBowlers = bowlingTeam.filter(p => 
                    (p.type === 'Bowler' || p.type === 'All-rounder') &&
                    p !== this.currentBowler &&
                    p !== this.previousBowler && // CRITICAL: Cannot bowl consecutive overs
                    p.matchStats.oversBowled < 10
                );
                
                // If no specialized bowlers available, allow any player (except current and previous)
                if (availableBowlers.length === 0) {
                    availableBowlers = bowlingTeam.filter(p => 
                        p !== this.currentBowler &&
                        p !== this.previousBowler && // CRITICAL: Cannot bowl consecutive overs
                        p.matchStats.oversBowled < 10
                    );
                }
                
                return availableBowlers;
            }
            
            checkWeatherInterruption() {
                if (this.weather === 'Light Drizzle') {
                    return Math.random() < 0.3; // 30% chance
                } else if (this.weather === 'Threatening Rain') {
                    return Math.random() < 0.15; // 15% chance
                }
                return false;
            }
            
            handleWeatherInterruption() {
                if (this.weather === 'Light Drizzle' && Math.random() < 0.6) {
                    // Match abandoned
                    return { abandoned: true, reason: 'Match abandoned due to rain' };
                } else {
                    // Rain delay - reduce overs
                    const oversLost = Math.floor(Math.random() * 10) + 5;
                    this.oversReduced = Math.max(20, this.oversReduced - oversLost);
                    this.rainDelay = true;
                    return { 
                        delay: true, 
                        reason: `Rain delay! Match reduced to ${this.oversReduced} overs per side`,
                        oversLost: oversLost
                    };
                }
            }
            
            generateOverCommentary(balls, runs, wickets) {
                const comments = [];
                
                if (wickets > 0) {
                    const wicketComments = [
                        "Bowled him! Straight through the bat and pad.",
                        "Caught brilliantly in the slips!",
                        "LBW! That was plumb in front.",
                        "There's a mix-up! Terrible running between the wickets.",
                        "Stumped! The keeper was lightning quick.",
                        "Edge taken! The fielder makes no mistake."
                    ];
                    comments.push(wicketComments[Math.floor(Math.random() * wicketComments.length)]);
                }
                
                if (balls.includes('6')) {
                    const sixComments = [
                        "Smashed it! That's a long way over the boundary for 6!",
                        "What a shot! Clean as a whistle over the rope!",
                        "Maximum! The crowd erupts as the ball sails into the stands!",
                        "Brutal hitting! That ball is still rising as it clears the fence!"
                    ];
                    comments.push(sixComments[Math.floor(Math.random() * sixComments.length)]);
                }
                
                if (balls.includes('4')) {
                    const fourComments = [
                        "Brilliant cover-drive to the fence.",
                        "Sublime timing! The ball races away to the boundary.",
                        "Cracking shot! No fielder in the world could have stopped that.",
                        "Pierced the gap perfectly! Four runs all the way."
                    ];
                    comments.push(fourComments[Math.floor(Math.random() * fourComments.length)]);
                }
                
                if (runs === 0 && wickets === 0) {
                    const economicalComments = [
                        "Tight bowling! Not giving anything away.",
                        "Maiden over! Excellent bowling discipline.",
                        "The pressure is building with dot balls.",
                        "Superb line and length from the bowler."
                    ];
                    if (Math.random() < 0.3) comments.push(economicalComments[Math.floor(Math.random() * economicalComments.length)]);
                }
                
                if (runs >= 15) {
                    const expensiveComments = [
                        "Expensive over! The batsmen are on the attack.",
                        "The bowling is under pressure here!",
                        "Runs flowing freely this over!",
                        "The captain needs to think about a bowling change."
                    ];
                    comments.push(expensiveComments[Math.floor(Math.random() * expensiveComments.length)]);
                }
                
                return comments.join(' ');
            }
            
            isInningsComplete() {
                return this.currentScore.wickets >= 10 || this.currentOver > this.oversReduced;
            }
            
            getTarget() {
                return this.innings === 2 ? (this.battingFirst === this.team1 ? this.team1Score.runs : this.team2Score.runs) + 1 : 0;
            }
            
            isMatchComplete() {
                if (this.innings === 1) return false;
                const target = this.getTarget();
                return this.currentScore.runs >= target || this.isInningsComplete();
            }
            
            getMatchResult() {
                const team1Name = this.team1.name || 'Your Team';
                const team2Name = this.team2.name || 'Your Team';
                
                let winnerName, margin;
                if (this.team1Score.runs > this.team2Score.runs) {
                    winnerName = team1Name;
                    margin = `${this.team1Score.runs - this.team2Score.runs} runs`;
                } else if (this.team2Score.runs > this.team1Score.runs) {
                    winnerName = team2Name;
                    margin = `${10 - this.team2Score.wickets} wickets`;
                } else {
                    winnerName = 'Tie';
                    margin = 'Match tied';
                }
                
                return {
                    team1: team1Name,
                    team2: team2Name,
                    score1: `${this.team1Score.runs}/${this.team1Score.wickets}`,
                    score2: `${this.team2Score.runs}/${this.team2Score.wickets}`,
                    winner: winnerName,
                    margin: margin
                };
            }
            
            // Get batting strategy for current match
            getBattingStrategy(battingTeam) {
                // Determine current batting strategy based on user selection and captain logic
                const strategy = document.getElementById('batting-strategy').value;
                
                if (strategy === 'captain-choice') {
                    // Captain makes decision based on match situation and captaincy skill
                    return this.captainChooseBattingStrategy(battingTeam);
                } else {
                    return strategy;
                }
            }
            
            // Captain chooses batting strategy based on match situation and skill
            captainChooseBattingStrategy(battingTeam) {
                // Find captain
                const captain = battingTeam.find(player => player.isCaptain);
                if (!captain || !captain.trainingSkills) {
                    // No captain or no training skills - random choice
                    const strategies = ['conservative', 'aggressive', 'balanced'];
                    return strategies[Math.floor(Math.random() * strategies.length)];
                }
                
                // Captain's decision making based on captaincy skill (0-100)
                const captaincySkill = captain.trainingSkills.captaincy || 20;
                const skillFactor = captaincySkill / 100; // 0.0 to 1.0
                
                // Analyze match situation
                const matchSituation = this.analyzeMatchSituation();
                
                let recommendedStrategy = 'balanced'; // Default fallback
                
                // SMART CAPTAIN DECISION MAKING
                if (this.innings === 1) {
                    // First innings logic
                    if (this.currentOver <= 10) {
                        // Powerplay - good captains are more aggressive
                        recommendedStrategy = skillFactor > 0.6 ? 'aggressive' : 'balanced';
                    } else if (this.currentOver <= 35) {
                        // Middle overs - steady approach
                        recommendedStrategy = 'balanced';
                    } else {
                        // Death overs - go for runs
                        recommendedStrategy = skillFactor > 0.5 ? 'aggressive' : 'balanced';
                    }
                } else {
                    // Second innings - chasing
                    const target = this.getTarget();
                    const needed = target - this.currentScore.runs;
                    const ballsLeft = (this.oversReduced - this.currentOver + 1) * 6;
                    
                    if (ballsLeft <= 0) {
                        recommendedStrategy = 'aggressive'; // Last resort
                    } else {
                        const requiredRate = needed / (ballsLeft / 6);
                        const currentRate = this.currentScore.runs / Math.max(this.currentOver - 1, 1);
                        
                        // Better captains make more nuanced decisions
                        if (skillFactor > 0.7) {
                            // Skilled captain - detailed analysis
                            if (requiredRate > currentRate + 3) {
                                recommendedStrategy = 'aggressive'; // Need to catch up
                            } else if (requiredRate < currentRate - 1) {
                                recommendedStrategy = 'conservative'; // Ahead of required rate
                            } else {
                                recommendedStrategy = 'balanced'; // On track
                            }
                        } else if (skillFactor > 0.4) {
                            // Average captain - basic analysis
                            if (requiredRate > currentRate + 2) {
                                recommendedStrategy = 'aggressive';
                            } else {
                                recommendedStrategy = 'balanced';
                            }
                        } else {
                            // Poor captain - often makes wrong choices
                            const randomChoice = Math.random();
                            if (randomChoice < 0.4) {
                                recommendedStrategy = 'aggressive'; // Often too aggressive
                            } else if (randomChoice < 0.7) {
                                recommendedStrategy = 'balanced';
                            } else {
                                recommendedStrategy = 'conservative'; // Sometimes too conservative
                            }
                        }
                    }
                }
                
                // Factor in wickets lost - good captains adjust for team situation
                if (skillFactor > 0.6) {
                    if (this.currentScore.wickets >= 6) {
                        // Many wickets lost - be more conservative
                        if (recommendedStrategy === 'aggressive') recommendedStrategy = 'balanced';
                        else if (recommendedStrategy === 'balanced') recommendedStrategy = 'conservative';
                    } else if (this.currentScore.wickets <= 2) {
                        // Few wickets lost - can be more aggressive
                        if (recommendedStrategy === 'conservative') recommendedStrategy = 'balanced';
                        else if (recommendedStrategy === 'balanced' && this.innings === 2) recommendedStrategy = 'aggressive';
                    }
                }
                
                // Add some randomness for lower-skilled captains
                if (skillFactor < 0.5 && Math.random() < 0.3) {
                    const alternatives = ['conservative', 'aggressive', 'balanced'].filter(s => s !== recommendedStrategy);
                    recommendedStrategy = alternatives[Math.floor(Math.random() * alternatives.length)];
                }
                
                return recommendedStrategy;
            }
            
            // Analyze current match situation
            analyzeMatchSituation() {
                return {
                    overs: this.currentOver,
                    wickets: this.currentScore.wickets,
                    runs: this.currentScore.runs,
                    innings: this.innings,
                    target: this.innings === 2 ? this.getTarget() : null,
                    runRate: this.currentScore.runs / Math.max(this.currentOver - 1, 1)
                };
            }
            
            // Get batting strategy modifiers based on chosen strategy
            getBattingStrategyModifiers(strategy, battingTeam) {
                switch (strategy) {
                    case 'conservative':
                        return {
                            dotMultiplier: 1.3,     // More dot balls
                            singleMultiplier: 1.4,  // More singles
                            doubleMultiplier: 1.1,  // Slightly more running
                            tripleMultiplier: 0.8,  // Fewer risky runs
                            fourMultiplier: 0.7,    // Fewer boundaries
                            sixMultiplier: 0.4,     // Much fewer sixes
                            wicketMultiplier: 0.7   // Fewer wickets lost
                        };
                    
                    case 'aggressive':
                        return {
                            dotMultiplier: 0.7,     // Fewer dot balls
                            singleMultiplier: 0.8,  // Fewer singles
                            doubleMultiplier: 1.1,  // More running
                            tripleMultiplier: 1.3,  // More risky runs
                            fourMultiplier: 1.5,    // More boundaries
                            sixMultiplier: 2.0,     // Much more sixes
                            wicketMultiplier: 1.4   // More wickets lost
                        };
                    
                    case 'balanced':
                    default:
                        return {
                            dotMultiplier: 1.0,
                            singleMultiplier: 1.0,
                            doubleMultiplier: 1.0,
                            tripleMultiplier: 1.0,
                            fourMultiplier: 1.0,
                            sixMultiplier: 1.0,
                            wicketMultiplier: 1.0
                        };
                }
            }
        }

        // Enhanced match simulation that processes entire league round
        function simulateMatchPlay() {
            const commentary = document.getElementById('match-commentary');
            
            // Show/hide buttons
            document.getElementById('start-match-btn').style.display = 'none';
            document.getElementById('auto-complete-btn').style.display = 'inline-block';
            
            // Create new match
            const playerTeam = { isPlayer: true, name: gameState.teamName };
            currentMatch = new CricketMatch(playerTeam, matchState.opponent, matchState.pitchType, matchState.weather, matchState.isHomeGame);
            
            // Initial setup
            commentary.innerHTML = `
                <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded">
                    <p><strong>üèè ${gameState.teamName} vs ${currentMatch.team2.name}</strong></p>
                    <p>Toss: ${currentMatch.tossWinner.name || gameState.teamName} won and elected to ${currentMatch.battingFirst === currentMatch.tossWinner ? 'bat' : 'field'} first</p>
                    <p>Conditions: ${matchState.pitchType}, ${matchState.weather}</p>
                    ${currentMatch.powerplayOvers > 0 ? '<p><span class="text-yellow-600">Powerplay:</span> First 10 overs (fielding restrictions)</p>' : ''}
                </div>
            `;
            
            // Start over-by-over simulation
            matchInterval = setInterval(() => {
                if (currentMatch.isMatchComplete()) {
                    completeMatch();
                    return;
                }
                
                if (currentMatch.isInningsComplete() && currentMatch.innings === 1) {
                    // Switch innings
                    currentMatch.innings = 2;
                    currentMatch.currentOver = 1;
                    currentMatch.currentScore = currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team2Score : currentMatch.team1Score;
                    currentMatch.striker = 0;
                    currentMatch.nonStriker = 1;
                    currentMatch.currentBowler = null;
                    currentMatch.bowlerOverCount = 0;
                    
                    const target = currentMatch.getTarget();
                    commentary.innerHTML += `
                        <div class="mb-2 p-2 bg-gray-50 dark:bg-gray-700 rounded">
                            <p><strong>End of First Innings</strong></p>
                            <p>${currentMatch.battingFirst.name || gameState.teamName}: ${currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team1Score.runs : currentMatch.team2Score.runs}/${currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team1Score.wickets : currentMatch.team2Score.wickets}</p>
                            <p><strong>Target: ${target} runs</strong></p>
                        </div>
                    `;
                }
                
                const overResult = currentMatch.simulateOver();
                
                if (overResult.abandoned) {
                    commentary.innerHTML += `<div class="mb-2 p-2 bg-red-50 dark:bg-red-900 rounded"><p><strong>${overResult.reason}</strong></p></div>`;
                    completeAbandonedMatch();
                    return;
                }
                
                if (overResult.delay) {
                    commentary.innerHTML += `<div class="mb-2 p-2 bg-yellow-50 dark:bg-yellow-900 rounded"><p><strong>${overResult.reason}</strong></p></div>`;
                }
                
                // Display over
                const isPowerplay = currentMatch.currentOver <= currentMatch.powerplayOvers && currentMatch.innings === 1;
                const overClass = isPowerplay ? 'text-yellow-600 dark:text-yellow-400' : 'text-gray-500 dark:text-gray-400';
                
                commentary.innerHTML += `
                    <div class="mb-2">
                        <p><span class="${overClass}">Over ${overResult.number}${isPowerplay ? ' (PP)' : ''}:</span> ${overResult.balls}</p>
                        ${overResult.commentary ? `<p class="text-sm italic text-gray-600 dark:text-gray-400">"${overResult.commentary}"</p>` : ''}
                    </div>
                `;
                
                // Show current score and target (if chasing)
                if (currentMatch.innings === 2) {
                    const target = currentMatch.getTarget();
                    const needed = target - currentMatch.currentScore.runs;
                    const ballsLeft = (currentMatch.oversReduced - currentMatch.currentOver + 1) * 6;
                    
                    if (needed > 0 && ballsLeft > 0) {
                        commentary.innerHTML += `<p class="text-xs text-blue-600 dark:text-blue-400">Need ${needed} runs from ${ballsLeft} balls</p>`;
                    }
                }
                
                // Auto scroll to bottom
                commentary.scrollTop = commentary.scrollHeight;
                
            }, 1000); // 1 second per over
        }



        // Update team name function
        function updateTeamName() {
            const teamNameInput = document.getElementById('team-name-input');
            gameState.teamName = teamNameInput.value || 'Your Team';
            
            // Update player team standing
            const playerStanding = gameState.leagueStandings.find(s => s.isPlayer);
            if (playerStanding) {
                playerStanding.name = gameState.teamName;
            }
            
            // Update all references throughout the app
            updateTeamNameDisplay();
        }

        // Update team name display throughout app
        function updateTeamNameDisplay() {
            // Update standings
            updateStandings();
            
            // Update recent results
            updateRecentResults();
            
            // Update any match displays that reference team name
            const yourTeamLabels = document.querySelectorAll('[data-team-name]');
            yourTeamLabels.forEach(label => {
                label.textContent = gameState.teamName;
            });
        }

        // Auto-complete match function
        function autoCompleteMatch() {
            if (matchState.selectedXI.length !== 11) {
                showCustomAlert('Please select exactly 11 players for your team!');
                return;
            }
            
            if (!gameState.players.some(p => p.isCaptain)) {
                showCustomAlert('Please select a team captain from the Roster tab!');
                return;
            }
            
            // Show live match details
            document.getElementById('live-match-details').style.display = 'block';
            document.getElementById('auto-complete-btn').style.display = 'none';
            
            // Create and complete match instantly
            const playerTeam = { isPlayer: true, name: gameState.teamName };
            currentMatch = new CricketMatch(playerTeam, matchState.opponent, matchState.pitchType, matchState.weather, matchState.isHomeGame);
            
            const commentary = document.getElementById('match-commentary');
            
            // Initial setup
            commentary.innerHTML = `
                <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded">
                    <p><strong>üèè ${gameState.teamName} vs ${currentMatch.team2.name}</strong></p>
                    <p>Toss: ${currentMatch.tossWinner.name || gameState.teamName} won and elected to ${currentMatch.battingFirst === currentMatch.tossWinner ? 'bat' : 'field'} first</p>
                    <p>Conditions: ${matchState.pitchType}, ${matchState.weather}</p>
                    ${currentMatch.powerplayOvers > 0 ? '<p><span class="text-yellow-600">Powerplay:</span> First 10 overs (fielding restrictions)</p>' : ''}
                </div>
            `;
            
            // Simulate complete match instantly
            while (!currentMatch.isMatchComplete()) {
                if (currentMatch.isInningsComplete() && currentMatch.innings === 1) {
                    // Switch innings
                    currentMatch.innings = 2;
                    currentMatch.currentOver = 1;
                    currentMatch.currentScore = currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team2Score : currentMatch.team1Score;
                    currentMatch.striker = 0;
                    currentMatch.nonStriker = 1;
                    currentMatch.currentBowler = null;
                    currentMatch.bowlerOverCount = 0;
                    
                    const target = currentMatch.getTarget();
                    commentary.innerHTML += `
                        <div class="mb-2 p-2 bg-gray-50 dark:bg-gray-700 rounded">
                            <p><strong>End of First Innings</strong></p>
                            <p>${currentMatch.battingFirst.name || gameState.teamName}: ${currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team1Score.runs : currentMatch.team2Score.runs}/${currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team1Score.wickets : currentMatch.team2Score.wickets}</p>
                            <p><strong>Target: ${target} runs</strong></p>
                        </div>
                    `;
                }
                
                const overResult = currentMatch.simulateOver();
                
                if (overResult.abandoned) {
                    commentary.innerHTML += `<div class="mb-2 p-2 bg-red-50 dark:bg-red-900 rounded"><p><strong>${overResult.reason}</strong></p></div>`;
                    break;
                }
                
                if (overResult.delay) {
                    commentary.innerHTML += `<div class="mb-2 p-2 bg-yellow-50 dark:bg-yellow-900 rounded"><p><strong>${overResult.reason}</strong></p></div>`;
                }
                
                // Display over
                const isPowerplay = currentMatch.currentOver <= currentMatch.powerplayOvers && currentMatch.innings === 1;
                const overClass = isPowerplay ? 'text-yellow-600 dark:text-yellow-400' : 'text-gray-500 dark:text-gray-400';
                
                commentary.innerHTML += `
                    <div class="mb-2">
                        <p><span class="${overClass}">Over ${overResult.number}${isPowerplay ? ' (PP)' : ''}:</span> ${overResult.balls}</p>
                        ${overResult.commentary ? `<p class="text-sm italic text-gray-600 dark:text-gray-400">"${overResult.commentary}"</p>` : ''}
                    </div>
                `;
                
                // Show current score and target (if chasing)
                if (currentMatch.innings === 2) {
                    const target = currentMatch.getTarget();
                    const needed = target - currentMatch.currentScore.runs;
                    const ballsLeft = (currentMatch.oversReduced - currentMatch.currentOver + 1) * 6;
                    
                    if (needed > 0 && ballsLeft > 0) {
                        commentary.innerHTML += `<p class="text-xs text-blue-600 dark:text-blue-400">Need ${needed} runs from ${ballsLeft} balls</p>`;
                    }
                }
            }
            
            // Complete the match
            completeMatch();
        }

        // Complete abandoned match (rain abandoned)
        function completeAbandonedMatch() {
            if (!currentMatch) return;
            
            // Clear the match interval immediately to prevent continued execution
            if (matchInterval) {
                clearInterval(matchInterval);
                matchInterval = null;
            }
            
            const commentary = document.getElementById('match-commentary');
            
            // Display final result for abandoned match
            commentary.innerHTML += `
                <div class="mt-4 p-4 bg-orange-50 dark:bg-orange-900 rounded border-2 border-orange-200 dark:border-orange-700">
                    <p class="text-lg font-bold text-center">Match Abandoned - Rain</p>
                    <div class="mt-2 text-center">
                        <p>Both teams receive 1 point</p>
                        <p><strong>${gameState.teamName}:</strong> ${currentMatch.team1Score.runs}/${currentMatch.team1Score.wickets}</p>
                        <p><strong>${currentMatch.team2.name}:</strong> ${currentMatch.team2Score.runs}/${currentMatch.team2Score.wickets}</p>
                    </div>
                </div>
            `;
            
            // Create abandoned match result
            const result = {
                team1: gameState.teamName,
                team2: currentMatch.team2.name,
                score1: `${currentMatch.team1Score.runs}/${currentMatch.team1Score.wickets}`,
                score2: `${currentMatch.team2Score.runs}/${currentMatch.team2Score.wickets}`,
                winner: 'Match Abandoned',
                margin: 'Rain',
                transcript: commentary.innerHTML
            };
            
            // Update league standings - both teams get 1 point, no win/loss
            const playerStanding = gameState.leagueStandings.find(s => s.isPlayer);
            playerStanding.gamesPlayed++;
            playerStanding.points += 1; // 1 point for abandoned match
            // NRR remains unchanged for abandoned matches
            
            // Update opponent standings
            const opponentStanding = gameState.leagueStandings.find(s => s.name === matchState.opponent.name);
            if (opponentStanding) {
                opponentStanding.gamesPlayed++;
                opponentStanding.points += 1; // 1 point for abandoned match
            }
            
            // Update AI team records
            matchState.opponent.gamesPlayed++;
            matchState.opponent.points += 1;
            // No win/loss update for abandoned matches
            
            // FAN BASE AND INCOME SYSTEM FOR ABANDONED MATCHES
            
            // Calculate income for abandoned match (reduced amount)
            const incomeData = calculateMatchIncome(
                { isPlayer: true, name: gameState.teamName }, 
                matchState.opponent, 
                matchState.isHomeGame
            );
            
            // Reduced income for abandoned matches (50% of normal)
            const reducedIncome = Math.floor(incomeData.playerIncome * 0.5);
            gameState.budget += reducedIncome;
            document.getElementById('budget').textContent = gameState.budget;
            
            // No fan base change for abandoned matches (neutral result)
            // Win/loss streaks remain unchanged
            
            // Add result to recent results with transcript
            gameState.recentResults.push(result);
            
            // Process AI matches and update displays
            processLeagueRound();
            
            // Update AI team fan bases after their matches
            updateAITeamFanBases();
            
            updateStandings();
            updateRecentResults();
            displayPlayers();
            
            // Schedule next match
            matchState.roundNumber++;
            scheduleNextMatch();
            
            // Auto-close match display and reset buttons
            setTimeout(() => {
                document.getElementById('start-match-btn').style.display = 'inline-block';
                document.getElementById('auto-complete-btn').style.display = 'none';
                document.getElementById('live-match-details').style.display = 'none';
                currentMatch = null;
            }, 5000);
        }

        // Complete match (shared logic)
        function completeMatch() {
            if (!currentMatch) return;
            
            // Clear the match interval immediately to prevent continued execution
            if (matchInterval) {
                clearInterval(matchInterval);
                matchInterval = null;
            }
            
            const commentary = document.getElementById('match-commentary');
            const result = currentMatch.getMatchResult();
            
            // CRITICAL: Check for injuries for both teams after match
            checkForInjuries(currentMatch.team1Players, currentMatch.team1.name || gameState.teamName);
            checkForInjuries(currentMatch.team2Players, currentMatch.team2.name || gameState.teamName);
            
            // CRITICAL FIX: Determine batting order for proper result format
            const battingFirstTeam = currentMatch.battingFirst.name || gameState.teamName;
            const battingSecondTeam = currentMatch.fieldingFirst.name || gameState.teamName;
            
            // CRITICAL FIX: Update result margin format based on batting order
            if (result.winner !== 'Tie') {
                if (result.winner === battingFirstTeam) {
                    // Team batting first won - show runs margin
                    result.margin = `${currentMatch.team1Score.runs - currentMatch.team2Score.runs} runs`;
                } else {
                    // Team batting second won - show wickets margin
                    const wicketsRemaining = 10 - (result.winner === result.team1 ? currentMatch.team1Score.wickets : currentMatch.team2Score.wickets);
                    result.margin = `${wicketsRemaining} wickets`;
                }
            }
            
            // Store the complete match transcript
            const matchTranscript = commentary.innerHTML;
            
            // Display final result with unique ID for scrolling
            commentary.innerHTML += `
                <div id="final-match-result" class="mt-4 p-4 bg-green-50 dark:bg-green-900 rounded border-2 border-green-200 dark:border-green-700">
                    <p class="text-lg font-bold text-center">${result.winner} won by ${result.margin}</p>
                    <div class="mt-2 text-center">
                        <p><strong>${result.team1}:</strong> ${result.score1}</p>
                        <p><strong>${result.team2}:</strong> ${result.score2}</p>
                    </div>
                </div>
            `;
            
            // CRITICAL: Scroll the final result to the top of the match-commentary container
            setTimeout(() => {
                const finalResult = document.getElementById('final-match-result');
                const commentary = document.getElementById('match-commentary');
                if (finalResult && commentary) {
                    // Calculate the position of the final result relative to the commentary container
                    const commentaryRect = commentary.getBoundingClientRect();
                    const resultRect = finalResult.getBoundingClientRect();
                    const relativeTop = finalResult.offsetTop - commentary.offsetTop;
                    
                    // Scroll the commentary container so the final result appears at the top
                    commentary.scrollTo({
                        top: relativeTop,
                        behavior: 'smooth'
                    });
                }
            }, 100); // Small delay to ensure DOM is updated
            
            // Add final transcript to result
            result.transcript = commentary.innerHTML;
            
            // Update league standings for BOTH player and opponent
            const playerStanding = gameState.leagueStandings.find(s => s.isPlayer);
            const opponentStanding = gameState.leagueStandings.find(s => s.name === matchState.opponent.name);
            
            // Update player standings
            playerStanding.gamesPlayed++;
            if (result.winner === gameState.teamName) {
                playerStanding.wins++;
                playerStanding.points += 2;
            } else if (result.winner !== 'Tie') {
                playerStanding.losses++;
            } else {
                playerStanding.points += 1; // Tie
            }
            playerStanding.netRunRate = (playerStanding.wins - playerStanding.losses) + Math.random() * 2 - 1;
            
            // Update opponent standings 
            if (opponentStanding) {
                opponentStanding.gamesPlayed++;
                if (result.winner === matchState.opponent.name) {
                    opponentStanding.wins++;
                    opponentStanding.points += 2;
                } else if (result.winner !== 'Tie') {
                    opponentStanding.losses++;
                } else {
                    opponentStanding.points += 1; // Tie
                }
                opponentStanding.netRunRate = (opponentStanding.wins - opponentStanding.losses) + Math.random() * 2 - 1;
            }
            
            // Also update the AI team object to keep it in sync
            if (result.winner === matchState.opponent.name) {
                matchState.opponent.wins++;
                matchState.opponent.points += 2;
            } else if (result.winner !== 'Tie') {
                matchState.opponent.losses++;
            } else {
                matchState.opponent.points += 1;
            }
            matchState.opponent.gamesPlayed++;
            matchState.opponent.netRunRate = (matchState.opponent.wins - matchState.opponent.losses) + Math.random() * 2 - 1;
            
            // Update player stats
            currentMatch.team1Players.concat(currentMatch.team2Players).forEach(player => {
                if (player.matchStats.ballsFaced > 0) {
                    player.totalRuns += player.matchStats.runs;
                    player.gamesPlayed++;
                    player.battingAverage = Math.floor(player.totalRuns / player.gamesPlayed);
                    
                    // Update high score
                    if (player.matchStats.runs > player.highScore) {
                        player.highScore = player.matchStats.runs;
                    }
                    
                    // Update 50s and 100s
                    if (player.matchStats.runs >= 50) player.fifties++;
                    if (player.matchStats.runs >= 100) player.hundreds++;
                    
                    // FIXED: Update strike rate properly
                    // Calculate career strike rate: (total runs / total balls faced) * 100
                    // We need to track total balls faced across career
                    if (!player.totalBallsFaced) player.totalBallsFaced = player.gamesPlayed * 30; // Estimate initial
                    player.totalBallsFaced += player.matchStats.ballsFaced;
                    player.strikeRate = Math.floor((player.totalRuns / player.totalBallsFaced) * 100);
                }
                
                if (player.matchStats.ballsBowled > 0) {
                    player.totalWickets += player.matchStats.wicketsTaken;
                    const newEconomy = player.matchStats.runsConceded / Math.max(1, player.matchStats.oversBowled);
                    player.economyRate = (player.economyRate + newEconomy) / 2; // Average with previous
                    
                    // FIXED: Update best bowling figures when performance is better
                    if (player.matchStats.wicketsTaken > 0) {
                        const currentBestWickets = parseInt((player.bestBowling && player.bestBowling.includes('/') ? player.bestBowling.split('/')[0] : '0'));
                        const currentBestRuns = parseInt(player.bestBowling.split('/')[1]);
                        
                        // Better bowling: more wickets, or same wickets with fewer runs
                        const isBetterBowling = player.matchStats.wicketsTaken > currentBestWickets ||
                            (player.matchStats.wicketsTaken === currentBestWickets && 
                             player.matchStats.runsConceded < currentBestRuns);
                        
                        if (isBetterBowling) {
                            player.bestBowling = `${player.matchStats.wicketsTaken}/${player.matchStats.runsConceded}`;
                        }
                    }
                    
                    // FIXED: Update 5-wicket and 10-wicket hauls
                    if (player.matchStats.wicketsTaken >= 5) player.fiveWicketHauls++;
                    if (player.matchStats.wicketsTaken >= 10) player.tenWicketHauls++;
                }
            });
            
            // CRITICAL: Process training queue after each match
            processTrainingQueue();
            
            // CRITICAL: Update scouting timing after each match
            updateScoutingTiming();
            
            // CRITICAL: Display pending training notifications 1 second after match UI resets
            setTimeout(() => {
                displayPendingTrainingNotifications();
            }, 6000); // 6 seconds (match UI resets at 5 seconds, then 1 second delay)
            
            // FAN BASE AND INCOME SYSTEM INTEGRATION
            
            // Check if any player scored 100+ runs for fan base bonus
            let playerScored100 = false;
            currentMatch.team1Players.concat(currentMatch.team2Players).forEach(player => {
                if (player.matchStats.runs >= 100) {
                    playerScored100 = true;
                }
            });
            
            // Calculate match income
            const incomeData = calculateMatchIncome(
                { isPlayer: true, name: gameState.teamName }, 
                matchState.opponent, 
                matchState.isHomeGame
            );
            
            // FINANCIAL TRACKING: Record match income
            recordMatchIncome(incomeData.playerIncome, matchState.isHomeGame);
            
            // Update fan base based on match result
            const playerWon = result.winner === gameState.teamName;
            calculateFanBaseChange(playerWon, playerScored100);
            
            // Update budget display
            gameState.budget += incomeData.playerIncome;
            document.getElementById('budget').textContent = gameState.budget;
            
            // Add result to recent results with transcript and match data for scorecard persistence
            result.matchData = currentMatch; // Store the complete match object for scorecard access
            gameState.recentResults.push(result);
            
            // Process AI matches and update displays
            processLeagueRound();
            
            // Update AI team fan bases after their matches
            updateAITeamFanBases();
            
            updateStandings();
            updateRecentResults();
            displayPlayers();
            
            // Check if season is complete before scheduling next match
            if (checkSeasonComplete()) {
                // Auto-close match display immediately when season ends
                document.getElementById('start-match-btn').style.display = 'inline-block';
                document.getElementById('auto-complete-btn').style.display = 'none';
                document.getElementById('live-match-details').style.display = 'none';
                currentMatch = null;
                endSeason();
                return;
            }
            
            // CRITICAL: Update injury recovery after each match
            updateInjuryRecovery();
            
            // Schedule next match
            matchState.roundNumber++;
            scheduleNextMatch();
            
            // Auto-close match display and reset buttons
            setTimeout(() => {
                document.getElementById('start-match-btn').style.display = 'inline-block';
                document.getElementById('auto-complete-btn').style.display = 'none';
                document.getElementById('live-match-details').style.display = 'none';
                currentMatch = null;
            }, 5000);
        }
        
        // Check for injuries for both teams after match
        function checkForInjuries(teamPlayers, teamName) {
            teamPlayers.forEach(player => {
                // Small chance for injury (2% base chance per player per match)
                const injuryChance = 0.02;
                
                // Weather can increase injury risk
                let adjustedChance = injuryChance;
                if (matchState.weather === 'Hot & Humid') {
                    adjustedChance = injuryChance * 1.5; // 3% chance in hot weather
                }
                
                if (Math.random() < adjustedChance) {
                    // Player gets injured
                    player.isInjured = true;
                    player.injuryDaysLeft = Math.floor(Math.random() * 3) + 2; // 2-4 matches
                    
                    console.log(`üè• INJURY: ${player.name} from ${teamName} injured for ${player.injuryDaysLeft} matches`);
                    
                    // If this is a player team player, remove from current XI
                    if (teamName === gameState.teamName && matchState.selectedXI.includes(player.name)) {
                        matchState.selectedXI = matchState.selectedXI.filter(name => name !== player.name);
                        updatePlayerSelector();
                        displayYourXI();
                        
                        showCustomAlert(`‚ö†Ô∏è ${player.name} has been injured and removed from your XI! They will be out for ${player.injuryDaysLeft} matches.`);
                    }
                }
            });
        }
        
        // Update injury recovery after each match
        function updateInjuryRecovery() {
            let anyRecoveries = false;
            
            gameState.players.forEach(player => {
                if (player.isInjured && player.injuryDaysLeft > 0) {
                    player.injuryDaysLeft--;
                    
                    if (player.injuryDaysLeft <= 0) {
                        player.isInjured = false;
                        player.injuryDaysLeft = 0;
                        anyRecoveries = true;
                        
                        console.log(`‚úÖ RECOVERY: ${player.name} has recovered from injury`);
                        
                        // Show recovery notification
                        setTimeout(() => {
                            showCustomAlert(`üéâ ${player.name} has recovered from injury and is available for selection!`);
                        }, 1000);
                    }
                }
            });
            
            // Update UI if any players recovered
            if (anyRecoveries) {
                displayPlayers();
                updatePlayerSelector();
                populateTrainingSelector();
            }
        }

        // FINANCIAL TRACKING FUNCTIONS
        
        // Record training expense in current season
        function recordTrainingExpense(skillName, cost) {
            const skillCategories = {
                'battingDefense': 'batting',
                'battingAggression': 'batting',
                'battingConsistency': 'batting',
                'bowlingDefense': 'bowling',
                'bowlingAggression': 'bowling',
                'bowlingConsistency': 'bowling',
                'fieldingCatching': 'fielding',
                'fieldingAgility': 'fielding',
                'wicketKeeping': 'specialist',
                'captaincy': 'specialist'
            };
            
            const category = skillCategories[skillName] || 'fielding';
            gameState.finances.currentSeason.training[category] -= cost;
        }
        
        // Record match income in current season
        function recordMatchIncome(income, isHomeGame) {
            if (isHomeGame) {
                gameState.finances.currentSeason.fanIncome.home += income;
            } else {
                gameState.finances.currentSeason.fanIncome.away += income;
            }
        }
        
        // Calculate total current season finances
        function calculateCurrentSeasonTotal() {
            const current = gameState.finances.currentSeason;
            const totalIncome = current.fanIncome.home + current.fanIncome.away;
            const totalExpenses = current.training.batting + current.training.bowling + 
                                 current.training.fielding + current.training.specialist + 
                                 current.transfers;
            return totalIncome + totalExpenses; // expenses are negative, so we add them
        }
        
        // Show financial modal with tabs
        function showFinancialModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg w-full max-w-sm sm:max-w-lg md:max-w-2xl lg:max-w-4xl mx-4 max-h-[95vh] sm:max-h-[90vh] overflow-hidden">
                    <div class="flex justify-between items-center p-3 sm:p-4 border-b border-gray-200 dark:border-gray-700">
                        <h3 class="text-lg font-bold pr-2">Financial Report</h3>
                        <button onclick="this.closest('.fixed').remove()" 
                                class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-xl min-w-[32px] h-8 flex items-center justify-center">
                            ‚úï
                        </button>
                    </div>
                    
                    <!-- Tab Navigation -->
                    <div class="flex border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800">
                        <button onclick="showFinancialTab('current')" id="current-tab-btn" 
                                class="financial-tab-btn flex-1 px-2 sm:px-4 py-3 text-xs sm:text-sm font-medium border-b-2 border-blue-500 text-blue-600 dark:text-blue-400 bg-white dark:bg-gray-700">
                            Current Season
                        </button>
                        <button onclick="showFinancialTab('previous')" id="previous-tab-btn" 
                                class="financial-tab-btn flex-1 px-2 sm:px-4 py-3 text-xs sm:text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                            Last Season
                        </button>
                        <button onclick="showFinancialTab('summary')" id="summary-tab-btn" 
                                class="financial-tab-btn flex-1 px-2 sm:px-4 py-3 text-xs sm:text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                            Summary
                        </button>
                    </div>
                    
                    <div class="overflow-y-auto" style="max-height: calc(95vh - 160px);">
                        ${generateFinancialTabContent()}
                    </div>
                    
                    <div class="p-3 sm:p-4 border-t border-gray-200 dark:border-gray-700 text-center">
                        <button onclick="this.closest('.fixed').remove()" 
                                class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Show financial tab
        function showFinancialTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.financial-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Remove active styles from all tabs
            document.querySelectorAll('.financial-tab-btn').forEach(btn => {
                btn.classList.remove('border-blue-500', 'text-blue-600', 'dark:text-blue-400', 'bg-white', 'dark:bg-gray-700');
                btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-200');
            });
            
            // Show selected tab content
            document.getElementById(tabName + '-content').style.display = 'block';
            
            // Add active styles to selected tab
            const activeBtn = document.getElementById(tabName + '-tab-btn');
            activeBtn.classList.add('border-blue-500', 'text-blue-600', 'dark:text-blue-400', 'bg-white', 'dark:bg-gray-700');
            activeBtn.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-200');
        }
        
        // Generate financial tab content
        function generateFinancialTabContent() {
            return `
                <!-- Current Season Tab -->
                <div id="current-content" class="financial-tab-content p-6">
                    ${generateCurrentSeasonContent()}
                </div>
                
                <!-- Previous Season Tab -->
                <div id="previous-content" class="financial-tab-content p-6" style="display: none;">
                    ${generatePreviousSeasonContent()}
                </div>
                
                <!-- Summary Tab -->
                <div id="summary-content" class="financial-tab-content p-6" style="display: none;">
                    ${generateSummaryContent()}
                </div>
            `;
        }
        
        // Generate current season financial content
        function generateCurrentSeasonContent() {
            const current = gameState.finances.currentSeason;
            const totalIncome = current.fanIncome.home + current.fanIncome.away;
            const totalTraining = current.training.batting + current.training.bowling + 
                                 current.training.fielding + current.training.specialist;
            const seasonTotal = calculateCurrentSeasonTotal();
            
            return `
                <h4 class="text-lg font-bold mb-4 text-blue-600 dark:text-blue-400">Current Season Financial Report</h4>
                
                <!-- Fan Income Section -->
                <div class="mb-6">
                    <h5 class="font-bold text-green-600 dark:text-green-400 mb-3 text-lg">Fan Income</h5>
                    <div class="bg-green-50 dark:bg-green-900 rounded-lg p-4 space-y-2">
                        <div class="flex justify-between">
                            <span>Home Games</span>
                            <span class="font-bold text-green-600 dark:text-green-400">+$${current.fanIncome.home.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Away Games</span>
                            <span class="font-bold text-green-600 dark:text-green-400">+$${current.fanIncome.away.toLocaleString()}</span>
                        </div>
                        <hr class="border-green-200 dark:border-green-700">
                        <div class="flex justify-between font-bold">
                            <span>Total Income</span>
                            <span class="text-green-600 dark:text-green-400">+$${totalIncome.toLocaleString()}</span>
                        </div>
                    </div>
                </div>
                
                <!-- Training Expenses Section -->
                <div class="mb-6">
                    <h5 class="font-bold text-red-600 dark:text-red-400 mb-3 text-lg">Training</h5>
                    <div class="bg-red-50 dark:bg-red-900 rounded-lg p-4 space-y-2">
                        <div class="flex justify-between">
                            <span>Batting</span>
                            <span class="font-bold text-red-600 dark:text-red-400">$${current.training.batting.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Bowling</span>
                            <span class="font-bold text-red-600 dark:text-red-400">$${current.training.bowling.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Fielding</span>
                            <span class="font-bold text-red-600 dark:text-red-400">$${current.training.fielding.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Specialist</span>
                            <span class="font-bold text-red-600 dark:text-red-400">$${current.training.specialist.toLocaleString()}</span>
                        </div>
                        <hr class="border-red-200 dark:border-red-700">
                        <div class="flex justify-between font-bold">
                            <span>Total Training</span>
                            <span class="text-red-600 dark:text-red-400">$${totalTraining.toLocaleString()}</span>
                        </div>
                    </div>
                </div>
                
                <!-- Player Transfers Section (Future) -->
                <div class="mb-6">
                    <h5 class="font-bold text-gray-600 dark:text-gray-400 mb-3 text-lg">Player Transfers</h5>
                    <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                        <div class="flex justify-between">
                            <span>Player Purchases/Sales</span>
                            <span class="font-bold text-gray-600 dark:text-gray-400">$${current.transfers.toLocaleString()}</span>
                        </div>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">Transfer market coming soon!</p>
                    </div>
                </div>
                
                <hr class="border-gray-300 dark:border-gray-600 my-6">
                
                <!-- Season Total -->
                <div class="bg-blue-50 dark:bg-blue-900 rounded-lg p-4">
                    <div class="flex justify-between text-lg font-bold">
                        <span>Season Total</span>
                        <span class="${seasonTotal >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}">
                            ${seasonTotal >= 0 ? '+' : ''}$${seasonTotal.toLocaleString()}
                        </span>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">
                        Net financial change for current season up to now
                    </p>
                </div>
            `;
        }
        
        // Generate previous season financial content
        function generatePreviousSeasonContent() {
            const previous = gameState.finances.previousSeason;
            const totalIncome = previous.fanIncome.home + previous.fanIncome.away;
            const totalTraining = previous.training.batting + previous.training.bowling + 
                                 previous.training.fielding + previous.training.specialist;
            const seasonTotal = totalIncome + totalTraining + previous.transfers;
            
            if (totalIncome === 0 && totalTraining === 0 && previous.transfers === 0) {
                return `
                    <div class="text-center text-gray-500 mt-8">
                        <div class="text-4xl mb-4">üìä</div>
                        <h4 class="text-lg font-bold mb-2">No Previous Season Data</h4>
                        <p>Complete your first season to see previous season financial data here.</p>
                    </div>
                `;
            }
            
            return `
                <h4 class="text-lg font-bold mb-4 text-blue-600 dark:text-blue-400">Previous Season Financial Report</h4>
                
                <!-- Fan Income Section -->
                <div class="mb-6">
                    <h5 class="font-bold text-green-600 dark:text-green-400 mb-3 text-lg">Fan Income</h5>
                    <div class="bg-green-50 dark:bg-green-900 rounded-lg p-4 space-y-2">
                        <div class="flex justify-between">
                            <span>Home Games</span>
                            <span class="font-bold text-green-600 dark:text-green-400">+$${previous.fanIncome.home.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Away Games</span>
                            <span class="font-bold text-green-600 dark:text-green-400">+$${previous.fanIncome.away.toLocaleString()}</span>
                        </div>
                        <hr class="border-green-200 dark:border-green-700">
                        <div class="flex justify-between font-bold">
                            <span>Total Income</span>
                            <span class="text-green-600 dark:text-green-400">+$${totalIncome.toLocaleString()}</span>
                        </div>
                    </div>
                </div>
                
                <!-- Training Expenses Section -->
                <div class="mb-6">
                    <h5 class="font-bold text-red-600 dark:text-red-400 mb-3 text-lg">Training</h5>
                    <div class="bg-red-50 dark:bg-red-900 rounded-lg p-4 space-y-2">
                        <div class="flex justify-between">
                            <span>Batting</span>
                            <span class="font-bold text-red-600 dark:text-red-400">$${previous.training.batting.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Bowling</span>
                            <span class="font-bold text-red-600 dark:text-red-400">$${previous.training.bowling.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Fielding</span>
                            <span class="font-bold text-red-600 dark:text-red-400">$${previous.training.fielding.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Specialist</span>
                            <span class="font-bold text-red-600 dark:text-red-400">$${previous.training.specialist.toLocaleString()}</span>
                        </div>
                        <hr class="border-red-200 dark:border-red-700">
                        <div class="flex justify-between font-bold">
                            <span>Total Training</span>
                            <span class="text-red-600 dark:text-red-400">$${totalTraining.toLocaleString()}</span>
                        </div>
                    </div>
                </div>
                
                <!-- Player Transfers Section -->
                <div class="mb-6">
                    <h5 class="font-bold text-gray-600 dark:text-gray-400 mb-3 text-lg">Player Transfers</h5>
                    <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                        <div class="flex justify-between">
                            <span>Player Purchases/Sales</span>
                            <span class="font-bold text-gray-600 dark:text-gray-400">$${previous.transfers.toLocaleString()}</span>
                        </div>
                    </div>
                </div>
                
                <hr class="border-gray-300 dark:border-gray-600 my-6">
                
                <!-- Season Total -->
                <div class="bg-blue-50 dark:bg-blue-900 rounded-lg p-4">
                    <div class="flex justify-between text-lg font-bold">
                        <span>Previous Season Total</span>
                        <span class="${seasonTotal >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}">
                            ${seasonTotal >= 0 ? '+' : ''}$${seasonTotal.toLocaleString()}
                        </span>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">
                        Net financial change for the previous complete season
                    </p>
                </div>
            `;
        }
        
        // Generate summary content
        function generateSummaryContent() {
            const history = gameState.finances.seasonHistory;
            
            if (history.length === 0) {
                return `
                    <div class="text-center text-gray-500 mt-8">
                        <div class="text-4xl mb-4">üìà</div>
                        <h4 class="text-lg font-bold mb-2">No Season History</h4>
                        <p>Complete seasons to see your financial history summary here.</p>
                        <p class="text-sm mt-2">End-of-season budget totals will be tracked over time.</p>
                    </div>
                `;
            }
            
            const historyHTML = history.map((season, index) => {
                const seasonNumber = history.length - index; // Newest first
                const isPositive = season.budgetChange >= 0;
                
                return `
                    <div class="flex justify-between items-center py-3 border-b border-gray-200 dark:border-gray-700">
                        <div>
                            <span class="font-medium">Season ${seasonNumber}</span>
                            <span class="text-sm text-gray-500 dark:text-gray-400 ml-2">(${season.competition})</span>
                        </div>
                        <div class="text-right">
                            <div class="font-bold">$${season.endingBudget.toLocaleString()}</div>
                            <div class="text-sm ${isPositive ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}">
                                ${isPositive ? '+' : ''}$${season.budgetChange.toLocaleString()}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            const totalChange = history.reduce((sum, season) => sum + season.budgetChange, 0);
            const avgChange = totalChange / history.length;
            
            return `
                <h4 class="text-lg font-bold mb-4 text-blue-600 dark:text-blue-400">Season Summary</h4>
                
                <div class="mb-6">
                    <h5 class="font-bold mb-3">Budget History</h5>
                    <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                        ${historyHTML}
                    </div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="bg-blue-50 dark:bg-blue-900 rounded-lg p-4">
                        <h6 class="font-bold text-blue-600 dark:text-blue-400 mb-2">Total Change</h6>
                        <div class="text-2xl font-bold ${totalChange >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}">
                            ${totalChange >= 0 ? '+' : ''}$${totalChange.toLocaleString()}
                        </div>
                        <p class="text-sm text-gray-600 dark:text-gray-400">Across ${history.length} season${history.length !== 1 ? 's' : ''}</p>
                    </div>
                    
                    <div class="bg-purple-50 dark:bg-purple-900 rounded-lg p-4">
                        <h6 class="font-bold text-purple-600 dark:text-purple-400 mb-2">Average Change</h6>
                        <div class="text-2xl font-bold ${avgChange >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}">
                            ${avgChange >= 0 ? '+' : ''}$${Math.round(avgChange).toLocaleString()}
                        </div>
                        <p class="text-sm text-gray-600 dark:text-gray-400">Per season</p>
                    </div>
                </div>
            `;
        }

        // Custom alert function (since alert() is not supported)
        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Toggle schedule visibility
        function toggleSchedule() {
            const scheduleDiv = document.getElementById('season-schedule');
            const toggleBtn = document.getElementById('schedule-toggle');
            
            if (scheduleDiv.style.display === 'none') {
                scheduleDiv.style.display = 'block';
                toggleBtn.textContent = 'Hide Schedule';
                generateSeasonSchedule();
            } else {
                scheduleDiv.style.display = 'none';
                toggleBtn.textContent = 'Show Schedule';
            }
        }

        // Generate complete season schedule - NATIONAL CUP UPDATE
        function generateSeasonSchedule() {
            const scheduleDiv = document.getElementById('season-schedule');
            const allTeams = [gameState.teamName, ...gameState.aiTeams.map(t => t.name)];
            
            // CRITICAL: Different total rounds for different competitions
            const totalRounds = gameState.currentCompetition === 'national' ? 18 : 14;
            const halfRounds = totalRounds / 2;
            
            // Split into two columns
            const firstHalf = [];
            const secondHalf = [];
            
            for (let round = 1; round <= halfRounds; round++) {
                firstHalf.push(generateRoundScheduleHTML(allTeams, round));
            }
            
            for (let round = halfRounds + 1; round <= totalRounds; round++) {
                secondHalf.push(generateRoundScheduleHTML(allTeams, round));
            }
            
            const competitionName = gameState.currentCompetition === 'national' ? 'National Cup' : 'Local Cup';
            
            scheduleDiv.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="font-bold text-lg mb-4 text-center text-gray-800 dark:text-gray-200">Rounds 1-${halfRounds} (Home/Away)</h3>
                        ${firstHalf.join('')}
                    </div>
                    <div>
                        <h3 class="font-bold text-lg mb-4 text-center text-gray-800 dark:text-gray-200">Rounds ${halfRounds + 1}-${totalRounds} (Return)</h3>
                        ${secondHalf.join('')}
                    </div>
                </div>
                <div class="mt-4 text-sm text-gray-600 dark:text-gray-400 text-center">
                    ${competitionName}: ${totalRounds} rounds total (double round-robin)
                </div>
            `;
        }

        // Generate HTML for a single round's schedule
        function generateRoundScheduleHTML(allTeams, round) {
            const roundMatches = generateRoundMatches(allTeams, round);
            
            let roundHTML = `
                <div class="mb-4">
                    <h4 class="font-bold text-md mb-2 text-blue-600 dark:text-blue-400">Round ${round}:</h4>
                    <div class="space-y-1">
            `;
            
            roundMatches.forEach(match => {
                const isPlayerMatch = match.team1 === gameState.teamName || match.team2 === gameState.teamName;
                const highlightClass = isPlayerMatch ? 'font-medium text-blue-800 dark:text-blue-200' : 'text-gray-700 dark:text-gray-300';
                
                roundHTML += `
                    <div class="text-sm ${highlightClass}">
                        ${match.team1} vs ${match.team2}
                    </div>
                `;
            });
            
            roundHTML += `
                    </div>
                </div>
            `;
            
            return roundHTML;
        }

        // Generate matches for a specific round with proper home/away alternation
        function generateRoundMatches(allTeams, round) {
            const matches = [];
            const numTeams = allTeams.length;
            
            // CRITICAL: Implement proper double round-robin (14 rounds total)
            // Rounds 1-7: First leg of fixtures
            // Rounds 8-14: Return leg with home/away swapped
            
            const isReturnLeg = round > 7;
            const actualRound = isReturnLeg ? round - 7 : round; // Convert round 8-14 to 1-7
            
            console.log(`\n=== GENERATING ROUND ${round} MATCHES ===`);
            console.log(`Is return leg: ${isReturnLeg}, Actual round: ${actualRound}`);
            
            if (numTeams % 2 === 1) {
                // Odd number of teams - one team gets a bye
                const activeTeams = [...allTeams];
                
                // Rotate teams for round-robin (standard algorithm)
                if (actualRound > 1) {
                    const rotated = activeTeams.slice(1, (actualRound - 1) % (numTeams - 1) + 1);
                    const remaining = activeTeams.slice((actualRound - 1) % (numTeams - 1) + 1);
                    activeTeams.splice(1, numTeams - 1, ...remaining, ...rotated);
                }
                
                // Pair teams (skip last one for bye)
                for (let i = 0; i < activeTeams.length - 1; i += 2) {
                    if (i + 1 < activeTeams.length) {
                        const team1 = activeTeams[i];
                        const team2 = activeTeams[i + 1];
                        
                        // CRITICAL: Swap home/away for return leg
                        if (isReturnLeg) {
                            matches.push({ team1: team2, team2: team1 });
                            console.log(`Return leg: ${team2} (home) vs ${team1} (away)`);
                        } else {
                            matches.push({ team1: team1, team2: team2 });
                            console.log(`First leg: ${team1} (home) vs ${team2} (away)`);
                        }
                    }
                }
            } else {
                // Even number of teams - everyone plays
                const activeTeams = [...allTeams];
                
                // Round-robin rotation: keep first team fixed, rotate others
                if (actualRound > 1) {
                    const firstTeam = activeTeams[0];
                    const otherTeams = activeTeams.slice(1);
                    
                    // Rotate other teams
                    const rotations = (actualRound - 1) % (numTeams - 1);
                    for (let r = 0; r < rotations; r++) {
                        otherTeams.push(otherTeams.shift());
                    }
                    
                    activeTeams.splice(0, numTeams, firstTeam, ...otherTeams);
                }
                
                // Generate matches with proper home/away
                for (let i = 0; i < numTeams / 2; i++) {
                    const team1Index = i;
                    const team2Index = numTeams - 1 - i;
                    
                    if (team1Index !== team2Index) {
                        const team1 = activeTeams[team1Index];
                        const team2 = activeTeams[team2Index];
                        
                        // CRITICAL: Swap home/away for return leg
                        if (isReturnLeg) {
                            matches.push({ team1: team2, team2: team1 });
                            console.log(`Return leg: ${team2} (home) vs ${team1} (away)`);
                        } else {
                            matches.push({ team1: team1, team2: team2 });
                            console.log(`First leg: ${team1} (home) vs ${team2} (away)`);
                        }
                    }
                }
            }
            
            console.log(`Generated ${matches.length} matches for round ${round}`);
            console.log(`=== END ROUND ${round} MATCHES ===\n`);
            
            return matches;
        }

        // Check if season is complete - depends on competition level
        function checkSeasonComplete() {
            const playerStanding = gameState.leagueStandings.find(s => s.isPlayer);
            if (!playerStanding) return false;
            
            // CRITICAL: Different game counts for different competitions
            const requiredGames = gameState.currentCompetition === 'national' ? 18 : 14;
            return playerStanding.gamesPlayed >= requiredGames;
        }
        
        // Initialize season counter
        let currentSeason = 1;

        // End season and show results
        function endSeason() {
            // Sort standings to get final positions
            const finalStandings = [...gameState.leagueStandings].sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                return b.netRunRate - a.netRunRate;
            });
            
            // Find player's position
            const playerPosition = finalStandings.findIndex(s => s.isPlayer) + 1;
            
            let modalMessage, modalImage, shouldAdvance = false;
            
            if (playerPosition === 1) {
                modalMessage = "Congratulations! You have Won the Season! Try the next level.";
                modalImage = "üèÜ"; // Placeholder - trophy emoji
                shouldAdvance = true;
            } else if (playerPosition === 2 || playerPosition === 3) {
                const positionText = playerPosition === 2 ? "2nd" : "3rd";
                modalMessage = `${positionText} place! So close. Try for the Champions next season.`;
                modalImage = "ü•à"; // Placeholder - medal emoji
            } else {
                modalMessage = "A valiant effort. But it looks like the other teams were better this year.";
                modalImage = "‚öîÔ∏è"; // Placeholder - sword emoji
            }
            
            showEndSeasonModal(modalMessage, modalImage, playerPosition, finalStandings, shouldAdvance);
        }

        // Show end season modal
        function showEndSeasonModal(message, image, position, finalStandings, shouldAdvance) {
            // Update the Game Tab UI - replace Start Match with Start New Season
            updateGameTabForSeasonEnd(shouldAdvance);
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            
            // Create final standings HTML
            const standingsHTML = finalStandings.map((team, index) => {
                const pos = index + 1;
                const isPlayer = team.isPlayer;
                const highlightClass = isPlayer ? 'font-bold text-blue-600 dark:text-blue-400' : '';
                
                return `
                    <div class="flex justify-between items-center py-1 ${highlightClass}">
                        <span>${pos}. ${team.name}</span>
                        <span class="text-sm">${team.points} pts (${team.wins}W-${team.losses}L)</span>
                    </div>
                `;
            }).join('');
            
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-lg w-full max-h-[90vh] overflow-hidden">
                    <div class="p-6 text-center">
                        <div class="text-6xl mb-4">${image}</div>
                        <h2 class="text-2xl font-bold mb-4">Season Complete!</h2>
                        <p class="text-lg mb-6">${message}</p>
                        
                        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 mb-6">
                            <h3 class="font-bold mb-3">Final Standings:</h3>
                            <div class="space-y-1 text-sm">
                                ${standingsHTML}
                            </div>
                        </div>
                        
                        <div class="flex gap-3 justify-center">
                            ${shouldAdvance ? 
                                '<button onclick="advanceToNational()" class="px-6 py-3 bg-green-600 text-white hover:bg-green-700 rounded-lg font-medium">Next Level</button>' : 
                                ''
                            }
                            <button onclick="this.closest(\'div.fixed\').remove()" class="px-6 py-3 bg-gray-500 text-white hover:bg-gray-600 rounded-lg font-medium">Close</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // Update Game Tab UI for season end
        function updateGameTabForSeasonEnd(shouldAdvance) {
            const startMatchBtn = document.getElementById('start-match-btn');
            
            if (shouldAdvance) {
                // Show "Advance to Next Level" button
                startMatchBtn.textContent = 'üèÜ Advance to Next Level';
                startMatchBtn.className = 'bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg text-lg font-medium';
                startMatchBtn.onclick = () => advanceToNational();
            } else {
                // Show "Start New Season" button
                startMatchBtn.textContent = 'üîÑ Start New Season';
                startMatchBtn.className = 'bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg text-lg font-medium';
                startMatchBtn.onclick = () => startNewSeason();
            }
        }

        // Start new season from modal (same as startNewSeason but closes modal)
        function startNewSeasonFromModal() {
            startNewSeason();
            document.querySelector('div.fixed').remove();
        }

        // Advance to National Cup or World Cup
        function advanceToNational() {
            if (gameState.currentCompetition === 'local') {
                // Enable National Cup
                gameState.competitions.national.unlocked = true;
                document.getElementById('national-btn').disabled = false;
                document.getElementById('national-btn').classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400', 'cursor-not-allowed');
                document.getElementById('national-btn').classList.add('bg-yellow-500', 'text-white');
                
                // Age players
                agePlayers();
                
                // CRITICAL FIX: Automatically switch to National Cup and reset game state
                selectCompetition('national');
                
                // CRITICAL FIX: Reset the Start Match button to normal state
                const startMatchBtn = document.getElementById('start-match-btn');
                startMatchBtn.textContent = 'üèè Start Match';
                startMatchBtn.className = 'bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg text-lg font-medium';
                startMatchBtn.onclick = () => startMatch();
                
                // Close modal
                document.querySelector('div.fixed').remove();
                
                // Show success message
                showCustomAlert('National Cup unlocked! Your players have gained experience. The season has started - good luck in the next level!');
            }
            else if (gameState.currentCompetition === 'national') {
                // Enable World Cup
                gameState.competitions.worldcup.unlocked = true;
                document.getElementById('worldcup-btn').disabled = false;
                document.getElementById('worldcup-btn').classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400', 'cursor-not-allowed');
                document.getElementById('worldcup-btn').classList.add('bg-red-500', 'text-white');
                
                // Age players and unlock higher training potential
                agePlayersWorldCup();
                
                // CRITICAL FIX: Automatically switch to World Cup and reset game state
                selectCompetition('worldcup');
                
                // CRITICAL FIX: Reset the Start Match button to normal state
                const startMatchBtn = document.getElementById('start-match-btn');
                startMatchBtn.textContent = 'üèè Start Match';
                startMatchBtn.className = 'bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg text-lg font-medium';
                startMatchBtn.onclick = () => startMatch();
                
                // Close modal
                document.querySelector('div.fixed').remove();
                
                // Show success message
                showCustomAlert('üèÜ World Cup unlocked! Your players have evolved to international level with higher training caps! The tournament has started!');
            }
        }

        // Age players for World Cup level with enhanced training caps
        function agePlayersWorldCup() {
            gameState.players.forEach(player => {
                player.age++;
                
                // CRITICAL: Increase training caps for World Cup level
                Object.keys(player.talentCeiling).forEach(skill => {
                    // Increase ceiling by 10-20 points for World Cup level
                    const increase = Math.floor(Math.random() * 11) + 10; // 10-20 increase
                    player.talentCeiling[skill] = Math.min(100, player.talentCeiling[skill] + increase);
                });
            });
            displayPlayers();
        }

        // Unlock National Cup and World Cup for testing
        function unlockNationalCupTester() {
            // Enable National Cup instantly
            gameState.competitions.national.unlocked = true;
            
            // Update the National Cup button appearance
            const nationalBtn = document.getElementById('national-btn');
            nationalBtn.disabled = false;
            nationalBtn.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400', 'cursor-not-allowed');
            nationalBtn.classList.add('bg-yellow-500', 'text-white');
            
            // CRITICAL: Also enable World Cup for testing
            gameState.competitions.worldcup.unlocked = true;
            
            // Update the World Cup button appearance
            const worldcupBtn = document.getElementById('worldcup-btn');
            worldcupBtn.disabled = false;
            worldcupBtn.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400', 'cursor-not-allowed');
            worldcupBtn.classList.add('bg-red-500', 'text-white');
            
            // Age players and unlock higher training potential for World Cup testing
            agePlayersWorldCup();
            
            // CRITICAL FIX: Auto-switch to National Cup to enable market access
            selectCompetition('national');
            
            // Auto-save the change
            autoSave();
            
            // Show confirmation
            showCustomAlert('üèÜ National Cup and World Cup unlocked for testing! World Cup training caps enabled. The transfer market is now available.');
        }

        // Start new season
        function startNewSeason() {
            // Store current season total for history
            const currentSeasonTotal = calculateCurrentSeasonTotal();
            
            // Move current season data to previous season
            gameState.finances.previousSeason = {
                fanIncome: { ...gameState.finances.currentSeason.fanIncome },
                training: { ...gameState.finances.currentSeason.training },
                transfers: gameState.finances.currentSeason.transfers
            };
            
            // Add season to history
            gameState.finances.seasonHistory.push({
                endingBudget: gameState.budget,
                budgetChange: currentSeasonTotal,
                competition: gameState.currentCompetition
            });
            
            // Reset current season data
            gameState.finances.currentSeason = {
                fanIncome: { home: 0, away: 0 },
                training: { batting: 0, bowling: 0, fielding: 0, specialist: 0 },
                transfers: 0
            };
            
            // Increment season counter
            currentSeason++;
            document.getElementById('season-counter').textContent = currentSeason;
            
            // Age players
            agePlayers();
            
            // Reset competition
            initializeCompetition(gameState.currentCompetition);
            matchState.roundNumber = 1;
            scheduleNextMatch();
            
            // Reset the Game Tab button to original state
            const startMatchBtn = document.getElementById('start-match-btn');
            startMatchBtn.textContent = 'üèè Start Match';
            startMatchBtn.className = 'bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg text-lg font-medium';
            startMatchBtn.onclick = () => startMatch();
            
            // Close modal if it exists
            const modal = document.querySelector('div.fixed');
            if (modal) modal.remove();
            
            // Auto-save after season transition
            autoSave();
            
            // Show message
            showCustomAlert('New season started! Your players have aged and gained experience. Time to try again!');
        }

        // Age players by 1 year
        function agePlayers() {
            gameState.players.forEach(player => {
                player.age++;
                // Players maintain their stats but gain experience through aging
                // Could add future logic here for stat changes based on age
            });
            displayPlayers();
        }



        // TRAINING SYSTEM FUNCTIONS
        
        // Populate player selector for training
        function populateTrainingSelector() {
            const selector = document.getElementById('training-player-selector');
            
            selector.innerHTML = '<option value="">Choose a player...</option>' +
                gameState.players.map((player, index) => {
                    // Add captain and wicket-keeper tags
                    let playerTags = '';
                    if (player.isCaptain) playerTags += ' (C)';
                    if (player.isWicketKeeper) playerTags += ' (WK)';
                    
                    return `<option value="${index}">${player.name}${playerTags} - ${player.type} (Age: ${player.age})</option>`;
                }).join('');
        }
        
        // Select player for training
        function selectPlayerForTraining() {
            const selector = document.getElementById('training-player-selector');
            const playerIndex = parseInt(selector.value);
            
            if (isNaN(playerIndex)) {
                document.getElementById('player-training-panel').style.display = 'none';
                return;
            }
            
            const player = gameState.players[playerIndex];
            showTrainingPanel(player);
        }
        
        // BRILLIANT SOLUTION: Reset training tab to overview (your idea!)
        function resetTrainingTabToOverview() {
            // Hide individual player training panel
            document.getElementById('player-training-panel').style.display = 'none';
            
            // Show overview panel
            document.getElementById('training-overview-panel').style.display = 'block';
            
            // Reset player selector to default
            const selector = document.getElementById('training-player-selector');
            selector.value = '';
            
            // Update the training overview
            updateTrainingOverview();
        }
        
        // Update training overview with all active training
        function updateTrainingOverview() {
            // Clear all overview sections
            document.getElementById('batting-training-overview').innerHTML = '';
            document.getElementById('bowling-training-overview').innerHTML = '';
            document.getElementById('fielding-training-overview').innerHTML = '';
            
            let totalActiveTraining = 0;
            
            // Skill category mapping
            const skillCategories = {
                'battingDefense': 'batting',
                'battingAggression': 'batting', 
                'battingConsistency': 'batting',
                'bowlingDefense': 'bowling',
                'bowlingAggression': 'bowling',
                'bowlingConsistency': 'bowling',
                'fieldingCatching': 'fielding',
                'fieldingAgility': 'fielding',
                'wicketKeeping': 'fielding',
                'captaincy': 'fielding'
            };
            
            const skillNames = {
                'battingDefense': 'Defense',
                'battingAggression': 'Aggression', 
                'battingConsistency': 'Consistency',
                'bowlingDefense': 'Defensive Bowling',
                'bowlingAggression': 'Aggressive Bowling',
                'bowlingConsistency': 'Bowling Consistency',
                'fieldingCatching': 'Catching',
                'fieldingAgility': 'Agility',
                'wicketKeeping': 'Wicket-Keeping',
                'captaincy': 'Captaincy'
            };
            
            // Collect all active training by category
            const trainingByCategory = { batting: [], bowling: [], fielding: [] };
            
            gameState.players.forEach(player => {
                player.trainingQueue.forEach(training => {
                    const category = skillCategories[training.skill];
                    if (category) {
                        trainingByCategory[category].push({
                            playerName: player.name,
                            skillName: skillNames[training.skill],
                            gamesRemaining: training.gamesRemaining,
                            skill: training.skill
                        });
                        totalActiveTraining++;
                    }
                });
            });
            
            // Update each category
            updateCategoryOverview('batting-training-overview', trainingByCategory.batting, 'No batting training active');
            updateCategoryOverview('bowling-training-overview', trainingByCategory.bowling, 'No bowling training active');
            updateCategoryOverview('fielding-training-overview', trainingByCategory.fielding, 'No fielding/specialist training active');
            
            // Show/hide "no training" message
            const noTrainingDiv = document.getElementById('no-active-training');
            if (totalActiveTraining === 0) {
                noTrainingDiv.style.display = 'block';
            } else {
                noTrainingDiv.style.display = 'none';
            }
        }
        
        // Update individual category overview
        function updateCategoryOverview(elementId, trainings, emptyMessage) {
            const element = document.getElementById(elementId);
            
            if (trainings.length === 0) {
                element.innerHTML = `
                    <div class="text-center text-gray-500 text-sm py-2">
                        ${emptyMessage}
                    </div>
                `;
                return;
            }
            
            element.innerHTML = trainings.map(training => `
                <div class="bg-green-50 dark:bg-green-900 p-2 rounded border-l-4 border-green-400">
                    <div class="font-medium text-sm">${training.playerName}</div>
                    <div class="text-xs text-gray-600 dark:text-gray-400">${training.skillName}</div>
                    <div class="text-xs text-green-600 dark:text-green-400 mt-1">
                        ${training.gamesRemaining} games remaining
                    </div>
                </div>
            `).join('');
        }
        
        
        // Show individual training panel (hide overview)
        function showTrainingPanel(player) {
           /* console.log(`üéØ SHOWING TRAINING PANEL for ${player.name}`);
            console.log(`   Current queue length: ${player.trainingQueue.length}`);
            player.trainingQueue.forEach((item, index) => {
                console.log(`   Queue item ${index}: ${item.skill} - ${item.gamesRemaining} games remaining`);
            });
            */

            // Hide overview panel
            document.getElementById('training-overview-panel').style.display = 'none';
            
            // Show individual player panel
            document.getElementById('player-training-panel').style.display = 'block';
            
            // Update player details
            document.getElementById('training-player-name').textContent = player.name;
            document.getElementById('training-player-type').textContent = player.type;
            document.getElementById('training-player-age').textContent = player.age;
            document.getElementById('training-player-games').textContent = player.gamesPlayed;
            
            // Update active training queue
           /* console.log(`üîÑ CALLING updateTrainingQueue for ${player.name}`);*/
            updateTrainingQueue(player);
            
            // Update skill levels and costs
            updateTrainingUI(player);
            
            // Show/hide specialist sections
            updateSpecialistTraining(player);
            
            // Show/hide bowling training for batters
            const bowlingSection = document.getElementById('bowling-training-section');
            if (player.type === 'Batter') {
                bowlingSection.style.display = 'none';
            } else {
                bowlingSection.style.display = 'block';
            }
            
           /* console.log(`‚úÖ TRAINING PANEL REFRESH COMPLETE for ${player.name}`);*/
        }
        

        
        // Update training UI with current values
        function updateTrainingUI(player) {
            // Batting skills
            updateSkillDisplay('defense', 'battingDefense', player);
            updateSkillDisplay('aggression', 'battingAggression', player);
            updateSkillDisplay('consistency', 'battingConsistency', player);
            
            // Bowling skills (only for non-batters)
            if (player.type !== 'Batter') {
                updateSkillDisplay('bowl-defense', 'bowlingDefense', player);
                updateSkillDisplay('bowl-aggression', 'bowlingAggression', player);
                updateSkillDisplay('bowl-consistency', 'bowlingConsistency', player);
            }
            
            // Fielding skills
            updateSkillDisplay('catching', 'fieldingCatching', player);
            updateSkillDisplay('agility', 'fieldingAgility', player);
            
            // Specialist skills
            if (player.isWicketKeeper) {
                updateSkillDisplay('wicketkeeping', 'wicketKeeping', player);
            }
            if (player.isCaptain) {
                updateSkillDisplay('captaincy', 'captaincy', player);
            }
        }
        
        // Update individual skill display
        function updateSkillDisplay(elementPrefix, skillName, player) {
            const skill = player.trainingSkills[skillName];
            const ceiling = player.talentCeiling[skillName];
            const cost = calculateTrainingCost(player, skillName);
            const difficulty = player.trainingDifficulty[skillName];
            
            // Update level display
            const levelElement = document.getElementById(`${elementPrefix}-level`);
            if (levelElement) {
                levelElement.textContent = `${skill}/${ceiling}`;
                
                // Color-code based on how close to ceiling
                const progress = skill / ceiling;
                if (progress >= 0.9) {
                    levelElement.className = 'text-sm bg-red-200 dark:bg-red-700 px-2 py-1 rounded'; // Near max
                } else if (progress >= 0.7) {
                    levelElement.className = 'text-sm bg-yellow-200 dark:bg-yellow-700 px-2 py-1 rounded'; // Good
                } else {
                    levelElement.className = 'text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded'; // Room to grow
                }
            }
            
            // Update cost display
            const costElement = document.getElementById(`${elementPrefix}-cost`);
            if (costElement) {
                costElement.textContent = `$${cost}`;
                
                // Adjust cost color based on difficulty
                if (difficulty === 'hard') {
                    costElement.className = 'text-sm font-bold text-red-600 dark:text-red-400';
                } else if (difficulty === 'easy') {
                    costElement.className = 'text-sm font-bold text-green-600 dark:text-green-400';
                } else {
                    costElement.className = 'text-sm font-bold text-blue-600 dark:text-blue-400';
                }
            }
            
            // Update button state
            const buttonElement = document.getElementById(`${elementPrefix}-btn`);
            if (buttonElement) {
                const canTrain = canPlayerTrain(player, skillName, cost);
                
                if (!canTrain.allowed) {
                    buttonElement.disabled = true;
                    buttonElement.textContent = canTrain.reason;
                    buttonElement.className = buttonElement.className.replace(/bg-\w+-500/, 'bg-gray-400');
                } else {
                    buttonElement.disabled = false;
                    buttonElement.textContent = 'Train';
                    // Restore original color based on skill type
                    const originalClasses = {
                        'defense': 'bg-blue-500 hover:bg-blue-600',
                        'aggression': 'bg-blue-500 hover:bg-blue-600',
                        'consistency': 'bg-blue-500 hover:bg-blue-600',
                        'bowl-defense': 'bg-red-500 hover:bg-red-600',
                        'bowl-aggression': 'bg-red-500 hover:bg-red-600',
                        'bowl-consistency': 'bg-red-500 hover:bg-red-600',
                        'catching': 'bg-green-500 hover:bg-green-600',
                        'agility': 'bg-green-500 hover:bg-green-600',
                        'wicketkeeping': 'bg-purple-500 hover:bg-purple-600',
                        'captaincy': 'bg-purple-500 hover:bg-purple-600'
                    };
                    
                    const baseClass = 'px-3 py-1 text-white rounded text-sm';
                    buttonElement.className = `${baseClass} ${originalClasses[elementPrefix] || 'bg-blue-500 hover:bg-blue-600'}`;
                }
            }
        }
        
        // Calculate training cost with multipliers
        function calculateTrainingCost(player, skillName) {
            let baseCost = player.trainingCosts[skillName];
            const difficulty = player.trainingDifficulty[skillName];
            
            // Apply difficulty multiplier
            if (difficulty === 'hard') {
                baseCost = Math.floor(baseCost * 1.5);
            } else if (difficulty === 'easy') {
                baseCost = Math.floor(baseCost * 0.75);
            }
            
            return baseCost;
        }
        
        // Check if player can train a skill
        function canPlayerTrain(player, skillName, cost) {
            // Check budget
            if (gameState.budget < cost) {
                return { allowed: false, reason: 'No Budget' };
            }
            
            // Check if already at ceiling
            if (player.trainingSkills[skillName] >= player.talentCeiling[skillName]) {
                return { allowed: false, reason: 'Max Level' };
            }
            
            // Check if already training this skill
            if (player.trainingQueue.some(training => training.skill === skillName)) {
                return { allowed: false, reason: 'Training' };
            }
            
            // Check if player is injured
            if (player.isInjured) {
                return { allowed: false, reason: 'Injured' };
            }
            
            return { allowed: true };
        }
        
        // Start training a skill
        function startTraining(skillName) {
            const selector = document.getElementById('training-player-selector');
            const playerIndex = parseInt(selector.value);
            
            if (isNaN(playerIndex)) {
                showCustomAlert('Please select a player first!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            const cost = calculateTrainingCost(player, skillName);
            const canTrain = canPlayerTrain(player, skillName, cost);
            
            if (!canTrain.allowed) {
                showCustomAlert(`Cannot train this skill: ${canTrain.reason}`);
                return;
            }
            
            // Confirm training
            showTrainingConfirmDialog(player, skillName, cost);
        }
        
        // Show training confirmation dialog
        function showTrainingConfirmDialog(player, skillName, cost) {
            const skillNames = {
                'battingDefense': 'Batting Defense',
                'battingAggression': 'Batting Aggression', 
                'battingConsistency': 'Batting Consistency',
                'bowlingDefense': 'Bowling Defense',
                'bowlingAggression': 'Bowling Aggression',
                'bowlingConsistency': 'Bowling Consistency',
                'fieldingCatching': 'Fielding - Catching',
                'fieldingAgility': 'Fielding - Agility',
                'wicketKeeping': 'Wicket-Keeping',
                'captaincy': 'Captaincy'
            };
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <h3 class="text-lg font-bold mb-4">Confirm Training</h3>
                    <div class="mb-4">
                        <p><strong>Player:</strong> ${player.name}</p>
                        <p><strong>Skill:</strong> ${skillNames[skillName]}</p>
                        <p><strong>Cost:</strong> $${cost}</p>
                        <p><strong>Difficulty:</strong> ${player.trainingDifficulty[skillName]}</p>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">
                            Training will take effect after 2-3 games.
                        </p>
                    </div>
                    <div class="flex justify-end space-x-3">
                        <button class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded" onclick="this.closest('.fixed').remove()">
                            Cancel
                        </button>
                        <button class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded" onclick="confirmTraining('${skillName}', ${cost}); this.closest('.fixed').remove();">
                            Confirm
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // Confirm and process training
        function confirmTraining(skillName, cost) {
            const selector = document.getElementById('training-player-selector');
            const playerIndex = parseInt(selector.value);
            const player = gameState.players[playerIndex];
            
            // Deduct cost
            gameState.budget -= cost;
            document.getElementById('budget').textContent = gameState.budget;
            
            // FINANCIAL TRACKING: Record training expense
            recordTrainingExpense(skillName, cost);
            
            // Add to training queue
            const gamesUntilComplete = Math.floor(Math.random() * 2) + 2; // 2-3 games
            const trainingItem = {
                skill: skillName,
                gamesRemaining: gamesUntilComplete,
                improvement: calculateTrainingImprovement(player, skillName)
            };
            
            player.trainingQueue.push(trainingItem);
            
            // Increase cost for next training of this skill
            player.trainingCosts[skillName] = Math.floor(player.trainingCosts[skillName] * 1.5);
            
            // Update UI
            showTrainingPanel(player);
            
            // Auto-save after training purchase
            autoSave();
        }
        
        // Calculate training improvement amount
        function calculateTrainingImprovement(player, skillName) {
            const difficulty = player.trainingDifficulty[skillName];
            const currentSkill = player.trainingSkills[skillName];
            const ceiling = player.talentCeiling[skillName];
            
            let baseImprovement = 5; // Base improvement points
            
            // Adjust by difficulty
            if (difficulty === 'easy') {
                baseImprovement = 7;
            } else if (difficulty === 'hard') {
                baseImprovement = 3;
            }
            
            // Diminishing returns as you get closer to ceiling
            const progress = currentSkill / ceiling;
            if (progress > 0.8) {
                baseImprovement = Math.floor(baseImprovement * 0.5); // 50% improvement near ceiling
            } else if (progress > 0.6) {
                baseImprovement = Math.floor(baseImprovement * 0.75); // 75% improvement when advanced
            }
            
            // Add some randomness (¬±2 points)
            const randomVariation = Math.floor(Math.random() * 5) - 2; // -2 to +2
            
            return Math.max(1, baseImprovement + randomVariation); // Minimum 1 point improvement
        }
        
        // Update training queue display
        function updateTrainingQueue(player) {
            const queueSection = document.getElementById('training-queue-section');
            const queueList = document.getElementById('training-queue-list');
            
            // CRITICAL: Always clear the queue list first
            if (queueList) {
                queueList.innerHTML = '';
            }
            
            if (player.trainingQueue.length === 0) {
                queueSection.style.display = 'none';
                return;
            }
            
            queueSection.style.display = 'block';
            
            const skillNames = {
                'battingDefense': 'Batting Defense',
                'battingAggression': 'Batting Aggression', 
                'battingConsistency': 'Batting Consistency',
                'bowlingDefense': 'Bowling Defense',
                'bowlingAggression': 'Bowling Aggression',
                'bowlingConsistency': 'Bowling Consistency',
                'fieldingCatching': 'Fielding - Catching',
                'fieldingAgility': 'Fielding - Agility',
                'wicketKeeping': 'Wicket-Keeping',
                'captaincy': 'Captaincy'
            };
            
            const queueHTML = player.trainingQueue.map((training, index) => {
                return `
                    <div class="flex justify-between items-center p-2 bg-green-50 dark:bg-green-900 rounded border">
                        <span class="font-medium">${skillNames[training.skill]}</span>
                        <span class="text-sm text-green-600 dark:text-green-400">
                            ${training.gamesRemaining} games remaining
                        </span>
                    </div>
                `;
            }).join('');
            
            queueList.innerHTML = queueHTML;
        }
        
        // Update specialist training sections
        function updateSpecialistTraining(player) {
            const wicketkeepingSection = document.getElementById('wicketkeeping-training');
            const captaincySection = document.getElementById('captaincy-training');
            const noSpecialistSection = document.getElementById('no-specialist-training');
            
            let hasSpecialistRole = false;
            
            if (player.isWicketKeeper) {
                wicketkeepingSection.style.display = 'block';
                hasSpecialistRole = true;
            } else {
                wicketkeepingSection.style.display = 'none';
            }
            
            if (player.isCaptain) {
                captaincySection.style.display = 'block';
                hasSpecialistRole = true;
            } else {
                captaincySection.style.display = 'none';
            }
            
            noSpecialistSection.style.display = hasSpecialistRole ? 'none' : 'block';
        }
        
        // Process training queue after each game
        function processTrainingQueue() {
            let anyTrainingUpdated = false;
            let anyTrainingCompleted = false;
            
            console.log("=== PROCESSING TRAINING QUEUE ===");
            
            gameState.players.forEach(player => {
                if (player.trainingQueue.length > 0) {
                    console.log(`Processing training for ${player.name}, queue length: ${player.trainingQueue.length}`);
                    
                    // Process in reverse order to avoid index issues when splicing
                    for (let i = player.trainingQueue.length - 1; i >= 0; i--) {
                        const training = player.trainingQueue[i];
                        
                        console.log(`BEFORE: ${player.name} - ${training.skill}: ${training.gamesRemaining} games remaining`);
                        
                        // CRITICAL: Decrement games remaining
                        training.gamesRemaining--;
                        anyTrainingUpdated = true;
                        
                        console.log(`AFTER: ${player.name} - ${training.skill}: ${training.gamesRemaining} games remaining`);
                        
                        if (training.gamesRemaining <= 0) {
                            console.log(`COMPLETING TRAINING: ${player.name} - ${training.skill}`);
                            
                            // Verify skill exists in player's training skills
                            if (!player.trainingSkills.hasOwnProperty(training.skill)) {
                                console.error(`ERROR: Skill ${training.skill} not found in player.trainingSkills`);
                                console.log("Available skills:", Object.keys(player.trainingSkills));
                                // Remove invalid training item
                                player.trainingQueue.splice(i, 1);
                                anyTrainingCompleted = true;
                                continue;
                            }
                            
                            // Apply training improvement
                            const currentSkill = player.trainingSkills[training.skill];
                            const newSkill = Math.min(
                                currentSkill + training.improvement,
                                player.talentCeiling[training.skill]
                            );
                            
                            console.log(`Skill improvement: ${training.skill} ${currentSkill} -> ${newSkill} (+${training.improvement})`);
                            
                            player.trainingSkills[training.skill] = newSkill;
                            
                            // Show improvement notification
                            showTrainingCompleteNotification(player, training.skill, training.improvement);
                            
                            // Remove from queue (safe to splice when iterating backwards)
                            player.trainingQueue.splice(i, 1);
                            
                            anyTrainingCompleted = true;
                            console.log(`COMPLETED AND REMOVED: ${player.name} - ${training.skill}`);
                        }
                    }
                    
                    console.log(`Final queue length for ${player.name}: ${player.trainingQueue.length}`);
                }
            });
            
            console.log(`Training update summary: anyTrainingUpdated=${anyTrainingUpdated}, anyTrainingCompleted=${anyTrainingCompleted}`);
            
            // CRITICAL: Refresh UI if ANY training was updated (not just completed)
            if (anyTrainingUpdated) {
                console.log("Refreshing training UI...");
                
                // Refresh training selector dropdown (for completed training)
                if (anyTrainingCompleted) {
                    populateTrainingSelector();
                }
                
                // ALWAYS refresh the training panel if a player is currently selected
                const currentSelector = document.getElementById('training-player-selector');
                const currentPlayerIndex = parseInt(currentSelector.value);
                if (!isNaN(currentPlayerIndex)) {
                    const currentPlayer = gameState.players[currentPlayerIndex];
                    if (currentPlayer) {
                        console.log(`BEFORE REFRESH: ${currentPlayer.name} has ${currentPlayer.trainingQueue.length} training items in queue`);
                        
                        // Log each item before refresh
                        currentPlayer.trainingQueue.forEach((item, index) => {
                            console.log(`  Queue item ${index}: ${item.skill} - ${item.gamesRemaining} games remaining`);
                        });
                        
                        console.log(`Force refreshing training panel for ${currentPlayer.name}`);
                        // Force refresh the training panel to update everything
                        showTrainingPanel(currentPlayer);
                        
                        console.log(`AFTER REFRESH: UI should now reflect ${currentPlayer.trainingQueue.length} training items`);
                    }
                } else {
                    console.log("No player currently selected in training panel - skipping UI refresh");
                }
            }
            
            console.log("=== TRAINING QUEUE PROCESSING COMPLETE ===");
        }
        
        // Show training completion notification with delayed timing
        function showTrainingCompleteNotification(player, skillName, improvement) {
            const skillNames = {
                'battingDefense': 'Batting Defense',
                'battingAggression': 'Batting Aggression', 
                'battingConsistency': 'Batting Consistency',
                'bowlingDefense': 'Bowling Defense',
                'bowlingAggression': 'Bowling Aggression',
                'bowlingConsistency': 'Bowling Consistency',
                'fieldingCatching': 'Fielding - Catching',
                'fieldingAgility': 'Fielding - Agility',
                'wicketKeeping': 'Wicket-Keeping',
                'captaincy': 'Captaincy'
            };
            
            // CRITICAL: Store notification for delayed display instead of showing immediately
            const notification = {
                player: player,
                skillName: skillName,
                improvement: improvement,
                skillDisplayName: skillNames[skillName]
            };
            
            // Add to pending notifications queue
            if (!window.pendingTrainingNotifications) {
                window.pendingTrainingNotifications = [];
            }
            window.pendingTrainingNotifications.push(notification);
            
            // CRITICAL FIX: Refresh training UI if this player is currently selected
            const currentSelector = document.getElementById('training-player-selector');
            const currentPlayerIndex = parseInt(currentSelector.value);
            if (!isNaN(currentPlayerIndex)) {
                const currentPlayer = gameState.players[currentPlayerIndex];
                if (currentPlayer === player) {
                    // Refresh the training panel to update buttons
                    showTrainingPanel(player);
                }
            }
        }
        
        // NEW: Display pending training notifications after match completion
        function displayPendingTrainingNotifications() {
            if (!window.pendingTrainingNotifications || window.pendingTrainingNotifications.length === 0) {
                return;
            }
            
            // Show the first notification and remove it from queue
            const notification = window.pendingTrainingNotifications.shift();
            showTrainingNotificationModal(notification);
        }
        
        // NEW: Actually show the training notification modal
        function showTrainingNotificationModal(notification) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <div class="text-center">
                        <div class="text-4xl mb-4">üéØ</div>
                        <h3 class="text-lg font-bold mb-4">Training Complete!</h3>
                        <p class="mb-2"><strong>${notification.player.name}</strong></p>
                        <p class="mb-2">${notification.skillDisplayName} improved by <strong>+${notification.improvement}</strong> points!</p>
                        <p class="text-sm text-gray-600 dark:text-gray-400">
                            This improvement will help in future matches.
                        </p>
                    </div>
                    <div class="flex justify-center mt-6 space-x-3">
                        <button class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded" onclick="dismissTrainingModal(); ${window.pendingTrainingNotifications && window.pendingTrainingNotifications.length > 0 ? 'displayPendingTrainingNotifications();' : ''}">
                            ${window.pendingTrainingNotifications && window.pendingTrainingNotifications.length > 0 ? 'Next' : 'Great!'}
                        </button>
                        ${window.pendingTrainingNotifications && window.pendingTrainingNotifications.length > 0 ? 
                        '<button class="px-4 py-2 bg-gray-500 text-white hover:bg-gray-600 rounded" onclick="dismissAllTrainingModals()">Skip All</button>' : ''}
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Auto-close after 8 seconds
            setTimeout(() => {
                const stillExists = document.body.contains(modal);
                if (stillExists) {
                    modal.remove();
                    // Show next notification if any remain
                    if (window.pendingTrainingNotifications && window.pendingTrainingNotifications.length > 0) {
                        displayPendingTrainingNotifications();
                    }
                }
            }, 8000);
        }
        
        // Dismiss current training modal
        function dismissTrainingModal() {
            const modal = document.querySelector('.fixed');
            if (modal) modal.remove();
        }
        
        // Dismiss all training modals
        function dismissAllTrainingModals() {
            window.pendingTrainingNotifications = [];
            const modal = document.querySelector('.fixed');
            if (modal) modal.remove();
        }
        
        // Initialize training system on load
        function initializeTrainingSystem() {
            populateTrainingSelector();
        }
        
        // LOCAL STORAGE SAVE/LOAD SYSTEM
        
        // Save game state to localStorage
        function saveGameState() {
            try {
                // Create a comprehensive save data object
                const saveData = {
                    gameState: {
                        budget: gameState.budget,
                        level: gameState.level,
                        teamName: gameState.teamName,
                        players: gameState.players,
                        currentFilter: gameState.currentFilter,
                        currentCompetition: gameState.currentCompetition,
                        competitions: gameState.competitions,
                        leagueStandings: gameState.leagueStandings,
                        recentResults: gameState.recentResults,
                        fanBase: gameState.fanBase,
                        totalIncome: gameState.totalIncome,
                        winStreak: gameState.winStreak,
                        lossStreak: gameState.lossStreak,
                        // CRITICAL: Save financial tracking data
                        finances: gameState.finances,
                        // CRITICAL: Save AI teams with all their data
                        aiTeams: gameState.aiTeams.map(team => ({
                            name: team.name,
                            level: team.level,
                            players: team.players, // Full player roster
                            gamesPlayed: team.gamesPlayed,
                            wins: team.wins,
                            losses: team.losses,
                            points: team.points,
                            netRunRate: team.netRunRate,
                            budget: team.budget,
                            isPlayer: team.isPlayer,
                            fanBase: team.fanBase,
                            totalIncome: team.totalIncome,
                            winStreak: team.winStreak,
                            lossStreak: team.lossStreak
                        }))
                    },
                    matchState: {
                        opponent: matchState.opponent ? {
                            name: matchState.opponent.name,
                            level: matchState.opponent.level,
                            players: matchState.opponent.players,
                            gamesPlayed: matchState.opponent.gamesPlayed,
                            wins: matchState.opponent.wins,
                            losses: matchState.opponent.losses,
                            points: matchState.opponent.points,
                            netRunRate: matchState.opponent.netRunRate,
                            budget: matchState.opponent.budget,
                            fanBase: matchState.opponent.fanBase,
                            totalIncome: matchState.opponent.totalIncome,
                            winStreak: matchState.opponent.winStreak,
                            lossStreak: matchState.opponent.lossStreak
                        } : null,
                        isHomeGame: matchState.isHomeGame,
                        pitchType: matchState.pitchType,
                        weather: matchState.weather,
                        selectedXI: matchState.selectedXI,
                        opponentXI: matchState.opponentXI,
                        roundNumber: matchState.roundNumber
                    },
                    version: '1.2' // Updated version for financial tracking
                };
                
                localStorage.setItem('cricketManagerSave', JSON.stringify(saveData));
                console.log('Game saved successfully with AI teams, league data, and financial tracking');
            } catch (error) {
                console.error('Error saving game:', error);
            }
        }
        
        // Load game state from localStorage
        function loadGameState() {
            try {
                const savedData = localStorage.getItem('cricketManagerSave');
                if (savedData) {
                    const parsed = JSON.parse(savedData);
                    
                    // Restore basic game state
                    Object.assign(gameState, parsed.gameState);
                    
                    // CRITICAL: Reconstruct AI teams as proper AITeam objects
                    if (parsed.gameState.aiTeams && Array.isArray(parsed.gameState.aiTeams)) {
                        gameState.aiTeams = parsed.gameState.aiTeams.map(teamData => {
                            // Create new AITeam instance
                            const team = new AITeam(teamData.name, teamData.level);
                            
                            // Restore all the saved properties
                            team.players = teamData.players || team.players;
                            team.gamesPlayed = teamData.gamesPlayed || 0;
                            team.wins = teamData.wins || 0;
                            team.losses = teamData.losses || 0;
                            team.points = teamData.points || 0;
                            team.netRunRate = teamData.netRunRate || 0;
                            team.budget = teamData.budget || team.budget;
                            team.fanBase = teamData.fanBase || team.fanBase;
                            team.totalIncome = teamData.totalIncome || 0;
                            team.winStreak = teamData.winStreak || 0;
                            team.lossStreak = teamData.lossStreak || 0;
                            
                            return team;
                        });
                    }
                    
                    // CRITICAL: Reconstruct matchState.opponent as AITeam if it exists
                    if (parsed.matchState.opponent) {
                        const opponentData = parsed.matchState.opponent;
                        
                        // Find the opponent in the loaded AI teams first
                        let opponent = gameState.aiTeams.find(team => team.name === opponentData.name);
                        
                        if (!opponent) {
                            // If not found, create new AITeam instance
                            opponent = new AITeam(opponentData.name, opponentData.level);
                            
                            // Restore opponent properties
                            opponent.players = opponentData.players || opponent.players;
                            opponent.gamesPlayed = opponentData.gamesPlayed || 0;
                            opponent.wins = opponentData.wins || 0;
                            opponent.losses = opponentData.losses || 0;
                            opponent.points = opponentData.points || 0;
                            opponent.netRunRate = opponentData.netRunRate || 0;
                            opponent.budget = opponentData.budget || opponent.budget;
                            opponent.fanBase = opponentData.fanBase || opponent.fanBase;
                            opponent.totalIncome = opponentData.totalIncome || 0;
                            opponent.winStreak = opponentData.winStreak || 0;
                            opponent.lossStreak = opponentData.lossStreak || 0;
                        }
                        
                        matchState.opponent = opponent;
                    }
                    
                    // Restore other match state properties
                    matchState.isHomeGame = parsed.matchState.isHomeGame;
                    matchState.pitchType = parsed.matchState.pitchType;
                    matchState.weather = parsed.matchState.weather;
                    matchState.selectedXI = parsed.matchState.selectedXI || [];
                    matchState.opponentXI = parsed.matchState.opponentXI || [];
                    matchState.roundNumber = parsed.matchState.roundNumber || 1;
                    
                    // Update UI elements
                    document.getElementById('budget').textContent = gameState.budget;
                    document.getElementById('team-name-input').value = gameState.teamName;
                    
                    // CRITICAL: Update competition titles and buttons but DON'T initialize new competition
                    updateCompetitionButtons();
                    updateCompetitionTitles();
                    
                    // Refresh all displays with loaded data
                    displayPlayers();
                    updateStandings();
                    updateRecentResults();
                    updatePlayerSelector();
                    populateTrainingSelector();
                    updateMatchDayReport();
                    displayOpponentXI();
                    // CRITICAL FIX: Display the selected XI after loading
                    displayYourXI();
                    
                    console.log('Game loaded successfully with AI teams and league data');
                    console.log(`Loaded ${gameState.aiTeams.length} AI teams`);
                    console.log(`League standings has ${gameState.leagueStandings.length} teams`);
                    console.log(`Recent results: ${gameState.recentResults.length} matches`);
                    
                    return true; // Successfully loaded
                }
            } catch (error) {
                console.error('Error loading game:', error);
                // If there's an error, clear corrupted save data
                localStorage.removeItem('cricketManagerSave');
            }
            return false; // No save found or error
        }
        
        // Update competition button states after loading
        function updateCompetitionButtons() {
            Object.keys(gameState.competitions).forEach(comp => {
                const btn = document.getElementById(comp + '-btn');
                if (gameState.competitions[comp].unlocked) {
                    btn.disabled = false;
                    btn.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400', 'cursor-not-allowed');
                    
                    // Set appropriate color based on competition
                    if (comp === 'local') {
                        btn.classList.add('bg-green-500', 'text-white');
                    } else if (comp === 'national') {
                        btn.classList.add('bg-yellow-500', 'text-white');
                    } else {
                        btn.classList.add('bg-blue-500', 'text-white');
                    }
                }
            });
            
            // CRITICAL: Don't call selectCompetition during load as it would overwrite loaded data
            // Just update the UI to reflect the current competition
            const currentBtn = document.getElementById(gameState.currentCompetition + '-btn');
            if (currentBtn) {
                currentBtn.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400');
                currentBtn.classList.add('bg-green-500', 'text-white');
            }
        }
        
        // Update competition titles after loading (separate from button selection)
        function updateCompetitionTitles() {
            const competitionNames = {
                local: 'Local Cup',
                national: 'National Cup', 
                worldcup: 'World Cup',
                test: 'Test World Series'
            };
            
            document.getElementById('competition-title').textContent = competitionNames[gameState.currentCompetition];
            document.getElementById('league-title').textContent = competitionNames[gameState.currentCompetition] + ' Standings';
        }
        
        // Auto-save after important game events
        function autoSave() {
            saveGameState();
        }
        
        // Clear all saved data and restart game
        function resetGame() {
            localStorage.removeItem('cricketManagerSave');
            location.reload(); // Reload the page to restart completely
        }
        
        // Show reset confirmation dialog
        function showResetConfirmation() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <div class="text-center">
                        <div class="text-4xl mb-4">‚ö†Ô∏è</div>
                        <h3 class="text-lg font-bold mb-4">Reset Game?</h3>
                        <p class="text-gray-700 dark:text-gray-300 mb-6">
                            This will permanently delete all your progress and start a completely new game.
                        </p>
                        <p class="text-sm text-red-600 dark:text-red-400 mb-4">
                            This action cannot be undone!
                        </p>
                    </div>
                    <div class="flex justify-center space-x-3">
                        <button class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded" onclick="this.closest('.fixed').remove()">
                            Cancel
                        </button>
                        <button class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded" onclick="resetGame()">
                            Reset Game
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // Enhanced game initialization with save/load
        function initGame() {
            // Try to load saved game first
            const gameLoaded = loadGameState();
            
            if (!gameLoaded) {
                // No save found, start new game
                gameState.players = generateInitialRoster();
                
                // Set first player as captain by default
                if (gameState.players.length > 0) {
                    gameState.players[0].isCaptain = true;
                }
                
                displayPlayers();
                initializeCompetition('local');
                updatePlayerSelector();
                scheduleNextMatch();
                
                // Save initial game state
                autoSave();
            }
        }
        
        // MARKET SYSTEM IMPLEMENTATION
        
        // Market system state
        const marketState = {
            scouts: [], // Active scouts
            scoutReports: [], // Available scout reports
            contractNegotiations: [], // Active contract offers
            freeAgents: [], // Available free agents
            isMarketAvailable: false, // Based on competition
            transferWindowOpen: true, // Based on season timing
            scoutingCost: 500, // Cost to send scouts out
            scoutCooldown: false, // Prevent spam clicking
            scoutTimer: null, // Timer for scouting
            // CRITICAL: New scouting management
            scoutingEnabled: true, // Whether scouting is currently enabled (start true for season start)
            firstAwayGameScoutingEnabled: false, // Track if first away game scouting has been enabled
            scoutReportTimers: [] // Track when scout reports expire
        };
        
        // Scout class
        class Scout {
            constructor(tier) {
                this.tier = tier;
                this.name = this.generateScoutName();
                this.accuracy = this.getAccuracyByTier(tier);
                this.cost = this.getCostByTier(tier);
                this.specialization = this.generateSpecialization();
                this.contractLength = Math.floor(Math.random() * 2) + 2; // 2-3 seasons
                this.experience = Math.floor(Math.random() * 10) + 1; // 1-10 years
                this.seasonsRemaining = this.contractLength;
                this.isActive = false; // Whether currently scouting
                this.cooldownGames = 0; // Games until can scout again
            }
            
            generateScoutName() {
                const firstNames = ['Alex', 'Ben', 'Chris', 'Dan', 'Emma', 'Frank', 'Grace', 'Henry', 'Ian', 'Jane'];
                const lastNames = ['Smith', 'Jones', 'Brown', 'Davis', 'Wilson', 'Moore', 'Taylor', 'White', 'Hall', 'Lee'];
                return firstNames[Math.floor(Math.random() * firstNames.length)] + ' ' + 
                       lastNames[Math.floor(Math.random() * lastNames.length)];
            }
            
            getAccuracyByTier(tier) {
                const accuracyRanges = {
                    'Rookie': 0.6,     // 60% accuracy
                    'Professional': 0.75, // 75% accuracy
                    'Elite': 0.85,     // 85% accuracy
                    'Master': 0.95     // 95% accuracy
                };
                return accuracyRanges[tier] || 0.6;
            }
            
            getCostByTier(tier) {
                const costs = {
                    'Rookie': 8000,
                    'Professional': 20000,
                    'Elite': 45000,
                    'Master': 80000
                };
                return costs[tier] || 8000;
            }
            
            generateSpecialization() {
                const specializations = [
                    'Batting Analysis', 'Bowling Analysis', 'Star Recognition', 
                    'All-rounder Evaluation', 'Young Talent', 'Veteran Assessment'
                ];
                return specializations[Math.floor(Math.random() * specializations.length)];
            }
            
            // Scout evaluates a player and creates a report
            evaluatePlayer(player, competition) {
                const report = {
                    player: player,
                    scoutName: this.name,
                    scoutTier: this.tier,
                    confidence: this.calculateConfidence(player),
                    recommendation: this.generateRecommendation(player),
                    evaluatedSkills: this.evaluateSkills(player),
                    contractSuggestion: this.suggestContract(player, competition),
                    hiddenTraitsDetected: this.detectHiddenTraits(player),
                    timestamp: Date.now()
                };
                
                return report;
            }
            
            calculateConfidence(player) {
                // Base confidence on scout accuracy and player's performance consistency
                let confidence = this.accuracy;
                
                // Adjust based on specialization match
                if (this.specialization === 'Batting Analysis' && (player.type === 'Batter' || player.type === 'All-rounder')) {
                    confidence += 0.1;
                } else if (this.specialization === 'Bowling Analysis' && (player.type === 'Bowler' || player.type === 'All-rounder')) {
                    confidence += 0.1;
                } else if (this.specialization === 'Star Recognition' && player.isStar) {
                    confidence += 0.15;
                }
                
                // Random variation
                confidence += (Math.random() - 0.5) * 0.2; // ¬±10%
                
                return Math.max(0.3, Math.min(0.95, confidence));
            }
            
            generateRecommendation(player) {
                const confidence = this.calculateConfidence(player);
                const isAccurate = Math.random() < this.accuracy;
                
                let recommendation;
                
                if (isAccurate) {
                    // Accurate assessment
                    if (player.isStar) {
                        recommendation = 'STRONG BUY - Exceptional talent, will be a key player';
                    } else if (player.battingAverage > 40 || (player.totalWickets / Math.max(player.gamesPlayed, 1)) > 2) {
                        recommendation = 'BUY - Solid performer, good addition to squad';
                    } else {
                        recommendation = 'CONSIDER - Average player, may be worth a low offer';
                    }
                } else {
                    // Inaccurate assessment (scout makes mistake)
                    if (player.isStar) {
                        recommendation = Math.random() < 0.3 ? 'CONSIDER - Decent player but nothing special' : 'BUY - Good potential';
                    } else {
                        recommendation = Math.random() < 0.3 ? 'STRONG BUY - Hidden gem, exceptional value!' : 'BUY - Strong performer';
                    }
                }
                
                return recommendation;
            }
            
            evaluateSkills(player) {
                const isAccurate = Math.random() < this.accuracy;
                const skills = {};
                
                // Batting assessment
                if (player.type === 'Batter' || player.type === 'All-rounder') {
                    if (isAccurate) {
                        skills.batting = this.accurateSkillAssessment(player.battingAverage, 50);
                    } else {
                        skills.batting = this.inaccurateSkillAssessment();
                    }
                }
                
                // Bowling assessment
                if (player.type === 'Bowler' || player.type === 'All-rounder') {
                    if (isAccurate) {
                        const wicketsPerGame = player.totalWickets / Math.max(player.gamesPlayed, 1);
                        skills.bowling = this.accurateSkillAssessment(wicketsPerGame * 20, 50); // Scale to 0-100
                    } else {
                        skills.bowling = this.inaccurateSkillAssessment();
                    }
                }
                
                return skills;
            }
            
            accurateSkillAssessment(actualValue, baseline) {
                if (actualValue >= baseline * 1.5) return 'Excellent';
                if (actualValue >= baseline * 1.2) return 'Very Good';
                if (actualValue >= baseline) return 'Good';
                if (actualValue >= baseline * 0.8) return 'Average';
                return 'Below Average';
            }
            
            inaccurateSkillAssessment() {
                const assessments = ['Excellent', 'Very Good', 'Good', 'Average', 'Below Average'];
                return assessments[Math.floor(Math.random() * assessments.length)];
            }
            
            detectHiddenTraits(player) {
                const detected = [];
                const detectionChance = this.accuracy * 0.7; // Harder to detect hidden traits
                
                player.hiddenTraits.forEach(trait => {
                    if (Math.random() < detectionChance) {
                        detected.push(trait);
                    }
                });
                
                // Sometimes scouts incorrectly "detect" traits that don't exist
                if (Math.random() < (1 - this.accuracy) * 0.3) {
                    const fakeTraits = ['Big Match Player', 'Pressure Performer', 'Team Player', 'Injury Prone'];
                    detected.push(fakeTraits[Math.floor(Math.random() * fakeTraits.length)]);
                }
                
                return detected;
            }
            
            suggestContract(player, competition) {
                const level = competition;
                let signingBonus, perGameSalary, contractLength;
                
                if (player.isStar) {
                    signingBonus = level === 'national' ? 25000 : level === 'worldcup' ? 50000 : 15000;
                    perGameSalary = level === 'national' ? 1500 : level === 'worldcup' ? 2500 : 800;
                    contractLength = 3;
                } else if (player.battingAverage > 35 || (player.totalWickets / Math.max(player.gamesPlayed, 1)) > 1.5) {
                    signingBonus = level === 'national' ? 15000 : level === 'worldcup' ? 30000 : 8000;
                    perGameSalary = level === 'national' ? 1000 : level === 'worldcup' ? 1800 : 500;
                    contractLength = 2;
                } else {
                    signingBonus = level === 'national' ? 8000 : level === 'worldcup' ? 15000 : 4000;
                    perGameSalary = level === 'national' ? 600 : level === 'worldcup' ? 1200 : 300;
                    contractLength = 1;
                }
                
                // Scout accuracy affects contract suggestions
                if (Math.random() > this.accuracy) {
                    // Inaccurate scout might suggest wrong contract values
                    signingBonus = Math.floor(signingBonus * (0.7 + Math.random() * 0.6)); // 70-130% of actual
                    perGameSalary = Math.floor(perGameSalary * (0.7 + Math.random() * 0.6));
                }
                
                return {
                    signingBonus,
                    perGameSalary,
                    contractLength
                };
            }
        }
        
        // Check if market is available
        function checkMarketAvailability() {
            const competition = gameState.currentCompetition;
            const isAvailable = competition === 'national' || competition === 'worldcup' || competition === 'test';
            
            marketState.isMarketAvailable = isAvailable;
            
            const marketUnavailable = document.getElementById('market-unavailable');
            const marketAvailable = document.getElementById('market-available');
            
            if (isAvailable) {
                marketUnavailable.style.display = 'none';
                marketAvailable.style.display = 'block';
                updateMarketDisplay();
            } else {
                marketUnavailable.style.display = 'block';
                marketAvailable.style.display = 'none';
            }
        }
        
        // Update market display
        function updateMarketDisplay() {
            updateActiveScoutsList();
            updateScoutReportsList();
            updateContractNegotiationsList();
            updateFreeAgentsList();
            updateTransferWindowStatus();
        }
        
        // Show hire scout modal
        function showHireScoutModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            const scoutTiers = [
                { name: 'Rookie Scout', cost: 8000, accuracy: '60%', description: 'Basic analysis, frequent mistakes' },
                { name: 'Professional Scout', cost: 20000, accuracy: '75%', description: 'Good insights, occasional errors' },
                { name: 'Elite Scout', cost: 45000, accuracy: '85%', description: 'Detailed reports, rarely wrong' },
                { name: 'Master Scout', cost: 80000, accuracy: '95%', description: 'Expert analysis, almost never wrong' }
            ];
            
            const scoutHTML = scoutTiers.map(tier => `
                <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg border">
                    <div class="flex justify-between items-start mb-2">
                        <h4 class="font-bold">${tier.name}</h4>
                        <span class="text-lg font-bold text-green-600 dark:text-green-400">$${tier.cost.toLocaleString()}</span>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-2">Accuracy: ${tier.accuracy}</p>
                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-3">${tier.description}</p>
                    <button onclick="hireScout('${tier.name.split(' ')[0]}'); this.closest('.fixed').remove();" 
                            class="w-full px-3 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded text-sm">
                        Hire Scout
                    </button>
                </div>
            `).join('');
            
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-4xl w-full max-h-[90vh] overflow-hidden">
                    <div class="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700">
                        <h3 class="text-lg font-bold">Hire Scout</h3>
                        <button onclick="this.closest('.fixed').remove()" 
                                class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-xl">
                            ‚úï
                        </button>
                    </div>
                    
                    <div class="p-6 overflow-y-auto max-h-[calc(90vh-120px)]">
                        <div class="mb-4">
                            <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                                Scouts analyze players from other teams and recommend potential signings. 
                                Better scouts provide more accurate reports but cost more to hire.
                            </p>
                            <p class="text-sm text-blue-600 dark:text-blue-400 mb-6">
                                Scout contracts last 2-3 seasons before renewal is required.
                            </p>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            ${scoutHTML}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Hire scout
        function hireScout(tier) {
            const scout = new Scout(tier);
            
            if (gameState.budget < scout.cost) {
                showCustomAlert('Insufficient budget to hire this scout!');
                return;
            }
            
            gameState.budget -= scout.cost;
            document.getElementById('budget').textContent = gameState.budget;
            
            marketState.scouts.push(scout);
            
            // Record expense in financial tracking
            recordTransferExpense(scout.cost);
            
            updateActiveScoutsList();
            showCustomAlert(`${scout.name} hired as ${tier} Scout! Contract: ${scout.contractLength} seasons.`);
            
            autoSave();
        }
        
        // Record transfer expense
        function recordTransferExpense(cost) {
            gameState.finances.currentSeason.transfers -= cost;
        }
        
        // Send scouts out - CRITICAL FIX: Implement proper scout capacity limits and timing
        function sendScoutsOut() {
            if (marketState.scouts.length === 0) {
                showCustomAlert('You need to hire scouts first!');
                return;
            }
            
            // CRITICAL: Check scout hiring limits based on competition level
            const scoutLimits = {
                'local': 0,      // No scouts allowed at local level
                'national': 2,   // 2 scouts max at national
                'worldcup': 3,   // 3 scouts max at world cup
                'test': 3        // 3 scouts max at test
            };
            
            const maxScouts = scoutLimits[gameState.currentCompetition] || 0;
            if (marketState.scouts.length > maxScouts) {
                showCustomAlert(`Too many scouts! Maximum ${maxScouts} scouts allowed at ${gameState.currentCompetition} level.`);
                return;
            }
            
            // CRITICAL: Check if scouting is currently enabled (timing system)
            if (!marketState.scoutingEnabled) {
                showCustomAlert('Scouting is not available at this time. Play more matches to enable scouting.');
                return;
            }
            
            if (gameState.budget < marketState.scoutingCost) {
                showCustomAlert('Insufficient budget for scouting mission!');
                return;
            }
            
            if (marketState.scoutCooldown) {
                showCustomAlert('Scouts are still analyzing previous reports. Please wait.');
                return;
            }
            
            // Deduct cost
            gameState.budget -= marketState.scoutingCost;
            document.getElementById('budget').textContent = gameState.budget;
            recordTransferExpense(marketState.scoutingCost);
            
            // Set cooldown
            marketState.scoutCooldown = true;
            const sendButton = document.getElementById('send-scouts-btn');
            sendButton.disabled = true;
            sendButton.textContent = 'Scouting...';
            
            // CRITICAL: Disable scouting after use (will be re-enabled for first away game)
            marketState.scoutingEnabled = false;
            marketState.gamesPlayedSinceScouts = 0;
            
            // Start timer (3-5 games simulation time, here just 5 seconds for demo)
            setTimeout(() => {
                generateScoutReports();
                marketState.scoutCooldown = false;
                sendButton.disabled = false;
                sendButton.textContent = 'üîç Send Scouts Out ($500)';
                updateScoutButtonState(); // Update button state after timer
                showCustomAlert('Scout reports are ready! Check the Scout Reports section.');
            }, 5000);
            
            autoSave();
        }
        
        // Generate scout reports with skill-based capacity limits
        function generateScoutReports() {
            // Get players from other teams based on current competition
            const availablePlayers = [];
            
            gameState.aiTeams.forEach(team => {
                // Each scout finds 1-2 players from different teams
                const teamPlayers = team.players.slice(0, 3); // Top 3 players from each team
                availablePlayers.push(...teamPlayers.map(player => ({ player, team: team.name })));
            });
            
            // CRITICAL: Each scout can only find a limited number of players based on skill level
            const scoutCapacities = {
                'Rookie': 1,      // Can only find 1 player
                'Professional': 2, // Can find 2 players
                'Elite': 3,       // Can find 3 players
                'Master': 4       // Can find 4 players
            };
            
            // Clear existing scout reports before generating new ones
            marketState.scoutReports = [];
            
            // Each scout generates reports up to their capacity
            marketState.scouts.forEach(scout => {
                const capacity = scoutCapacities[scout.tier] || 1;
                
                for (let i = 0; i < capacity && availablePlayers.length > 0; i++) {
                    // Randomly select a player
                    const randomIndex = Math.floor(Math.random() * availablePlayers.length);
                    const { player, team } = availablePlayers[randomIndex];
                    availablePlayers.splice(randomIndex, 1); // Remove to avoid duplicates
                    
                    // Generate report
                    const report = scout.evaluatePlayer(player, gameState.currentCompetition);
                    report.teamName = team;
                    report.id = Date.now() + Math.random() + i; // Unique ID
                    
                    // CRITICAL: Add timer for when this report will expire (2-3 matches)
                    report.expiresAfterGames = Math.floor(Math.random() * 2) + 2; // 2-3 games
                    
                    marketState.scoutReports.push(report);
                }
            });
            
            updateScoutReportsList();
        }
        
        // Update active scouts list
        function updateActiveScoutsList() {
            const listElement = document.getElementById('active-scouts-list');
            
            if (marketState.scouts.length === 0) {
                listElement.innerHTML = `
                    <div class="text-center text-gray-500 py-2">
                        <p>No scouts hired.</p>
                        <p class="text-sm mt-1">Hire scouts to discover talent!</p>
                    </div>
                `;
                return;
            }
            
            listElement.innerHTML = marketState.scouts.map(scout => `
                <div class="bg-white dark:bg-gray-700 p-3 rounded border">
                    <div class="flex justify-between items-start">
                        <div>
                            <h4 class="font-medium">${scout.name}</h4>
                            <p class="text-sm text-gray-600 dark:text-gray-400">${scout.tier} Scout (${Math.round(scout.accuracy * 100)}% accuracy)</p>
                            <p class="text-xs text-gray-500 dark:text-gray-400">Specialization: ${scout.specialization}</p>
                        </div>
                        <div class="text-right">
                            <p class="text-sm">${scout.seasonsRemaining} seasons left</p>
                            <p class="text-xs text-gray-500">${scout.experience} years exp.</p>
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        // Update scout reports list
        function updateScoutReportsList() {
            const listElement = document.getElementById('scout-reports-list');
            const noReportsElement = document.getElementById('no-scout-reports');
            
            if (marketState.scoutReports.length === 0) {
                listElement.innerHTML = '';
                noReportsElement.style.display = 'block';
                return;
            }
            
            noReportsElement.style.display = 'none';
            
            listElement.innerHTML = marketState.scoutReports.map(report => `
                <div class="bg-white dark:bg-gray-700 p-4 rounded border">
                    <div class="flex justify-between items-start mb-3">
                        <div>
                            <h4 class="font-bold text-lg">${report.player.name}</h4>
                            <p class="text-sm text-gray-600 dark:text-gray-400">${report.player.type} ‚Ä¢ Age ${report.player.age} ‚Ä¢ ${report.teamName}</p>
                        </div>
                        <div class="text-right">
                            <p class="text-sm font-medium">Confidence: ${Math.round(report.confidence * 100)}%</p>
                            <p class="text-xs text-gray-500">by ${report.scoutName}</p>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <p class="font-medium text-sm ${getRecommendationColor(report.recommendation)}">${report.recommendation}</p>
                    </div>
                    
                    <!-- Player Stats -->
                    <div class="grid grid-cols-2 gap-4 mb-3 text-sm">
                        <div>
                            <p><strong>Batting:</strong> Avg ${report.player.battingAverage} | S/R ${report.player.strikeRate}</p>
                            <p><strong>High Score:</strong> ${report.player.highScore}</p>
                        </div>
                        ${(report.player.type === 'Bowler' || report.player.type === 'All-rounder') ? `
                        <div>
                            <p><strong>Bowling:</strong> ${report.player.totalWickets} wickets</p>
                            <p><strong>Economy:</strong> ${report.player.economyRate.toFixed(1)} | Best: ${report.player.bestBowling}</p>
                        </div>
                        ` : '<div></div>'}
                    </div>
                    
                    <!-- Scout Analysis -->
                    <div class="mb-3 text-sm">
                        ${Object.keys(report.evaluatedSkills).map(skill => 
                            `<span class="inline-block bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded mr-2 mb-1">${skill}: ${report.evaluatedSkills[skill]}</span>`
                        ).join('')}
                    </div>
                    
                    <!-- Hidden Traits -->
                    ${report.hiddenTraitsDetected.length > 0 ? `
                    <div class="mb-3 text-sm">
                        <p class="font-medium mb-1">Detected Traits:</p>
                        ${report.hiddenTraitsDetected.map(trait => 
                            `<span class="inline-block bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200 px-2 py-1 rounded mr-2 mb-1">${trait}</span>`
                        ).join('')}
                    </div>
                    ` : ''}
                    
                    <!-- Contract Suggestion -->
                    <div class="border-t pt-3 flex justify-between items-center">
                        <div class="text-sm">
                            <p><strong>Suggested Contract:</strong></p>
                            <p>Signing: $${report.contractSuggestion.signingBonus.toLocaleString()} | Per Game: $${report.contractSuggestion.perGameSalary.toLocaleString()} | ${report.contractSuggestion.contractLength} season(s)</p>
                        </div>
                        <button onclick="makeContractOffer('${report.id}')" 
                                class="px-4 py-2 bg-green-500 text-white hover:bg-green-600 rounded">
                            Make Offer
                        </button>
                    </div>
                </div>
            `).join('');
        }
        
        // Get recommendation color class
        function getRecommendationColor(recommendation) {
            if (recommendation.includes('STRONG BUY')) return 'text-green-600 dark:text-green-400';
            if (recommendation.includes('BUY')) return 'text-blue-600 dark:text-blue-400';
            return 'text-yellow-600 dark:text-yellow-400';
        }
        
        // Make contract offer
        function makeContractOffer(reportId) {
            const report = marketState.scoutReports.find(r => r.id == reportId);
            if (!report) return;
            
            showContractOfferModal(report);
        }
        
        // Show contract offer modal
        function showContractOfferModal(report) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            const suggested = report.contractSuggestion;
            
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-lg w-full max-h-[90vh] overflow-hidden">
                    <div class="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700">
                        <h3 class="text-lg font-bold">Contract Offer - ${report.player.name}</h3>
                        <button onclick="this.closest('.fixed').remove()" 
                                class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-xl">
                            ‚úï
                        </button>
                    </div>
                    
                    <div class="p-6 overflow-y-auto max-h-[calc(90vh-120px)]">
                        <div class="mb-4">
                            <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                                Make an offer to ${report.player.name} (${report.player.type}, Age ${report.player.age}) from ${report.teamName}.
                            </p>
                        </div>
                        
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium mb-2">Signing Bonus</label>
                                <input type="number" id="signing-bonus" value="${suggested.signingBonus}" min="0" 
                                       class="w-full text-base p-3 border rounded-lg dark:bg-gray-700 dark:border-gray-600">
                                <p class="text-xs text-gray-500 mt-1">Scout suggested: $${suggested.signingBonus.toLocaleString()}</p>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium mb-2">Per-Game Salary</label>
                                <input type="number" id="per-game-salary" value="${suggested.perGameSalary}" min="0"
                                       class="w-full text-base p-3 border rounded-lg dark:bg-gray-700 dark:border-gray-600">
                                <p class="text-xs text-gray-500 mt-1">Scout suggested: $${suggested.perGameSalary.toLocaleString()}</p>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium mb-2">Contract Length (seasons)</label>
                                <select id="contract-length" class="w-full text-base p-3 border rounded-lg dark:bg-gray-700 dark:border-gray-600">
                                    <option value="1" ${suggested.contractLength === 1 ? 'selected' : ''}>1 Season</option>
                                    <option value="2" ${suggested.contractLength === 2 ? 'selected' : ''}>2 Seasons</option>
                                    <option value="3" ${suggested.contractLength === 3 ? 'selected' : ''}>3 Seasons</option>
                                </select>
                                <p class="text-xs text-gray-500 mt-1">Scout suggested: ${suggested.contractLength} season(s)</p>
                            </div>
                        </div>
                        
                        <div class="mt-6 p-3 bg-yellow-50 dark:bg-yellow-900 rounded">
                            <p class="text-sm text-yellow-800 dark:text-yellow-200">
                                <strong>Note:</strong> Player decision depends on your offer competitiveness, team strength, and their current situation.
                                Higher offers increase acceptance chances but cost more money.
                            </p>
                        </div>
                    </div>
                    
                    <div class="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end space-x-3">
                        <button onclick="this.closest('.fixed').remove()" 
                                class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">
                            Cancel
                        </button>
                        <button onclick="submitContractOffer('${report.id}'); this.closest('.fixed').remove();" 
                                class="px-4 py-2 bg-green-500 text-white hover:bg-green-600 rounded">
                            Submit Offer
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Submit contract offer
        function submitContractOffer(reportId) {
            const report = marketState.scoutReports.find(r => r.id == reportId);
            if (!report) return;
            
            const signingBonus = parseInt(document.getElementById('signing-bonus').value) || 0;
            const perGameSalary = parseInt(document.getElementById('per-game-salary').value) || 0;
            const contractLength = parseInt(document.getElementById('contract-length').value) || 1;
            
            const totalCost = signingBonus + (perGameSalary * 14 * contractLength); // Estimate total cost
            
            if (gameState.budget < signingBonus) {
                showCustomAlert('Insufficient budget for signing bonus!');
                return;
            }
            
            // Create contract negotiation
            const negotiation = {
                id: Date.now() + Math.random(),
                player: report.player,
                teamName: report.teamName,
                offer: {
                    signingBonus,
                    perGameSalary,
                    contractLength
                },
                scoutReport: report,
                status: 'pending',
                responseTime: Date.now() + (Math.random() * 3000) + 2000, // 2-5 seconds response
                accepted: null
            };
            
            marketState.contractNegotiations.push(negotiation);
            
            // Remove from scout reports
            marketState.scoutReports = marketState.scoutReports.filter(r => r.id !== reportId);
            
            updateScoutReportsList();
            updateContractNegotiationsList();
            
            // Process response after delay
            setTimeout(() => {
                processContractResponse(negotiation.id);
            }, negotiation.responseTime - Date.now());
            
            showCustomAlert(`Contract offer submitted to ${report.player.name}. Awaiting response...`);
            autoSave();
        }
        
        // Process contract response
        function processContractResponse(negotiationId) {
            const negotiation = marketState.contractNegotiations.find(n => n.id === negotiationId);
            if (!negotiation) return;
            
            // Player decision logic
            const acceptanceChance = calculateAcceptanceChance(negotiation);
            const accepted = Math.random() < acceptanceChance;
            
            negotiation.status = accepted ? 'accepted' : 'rejected';
            negotiation.accepted = accepted;
            
            if (accepted) {
                // Add player to team
                addPlayerToTeam(negotiation.player, negotiation.offer);
                
                // Deduct signing bonus
                gameState.budget -= negotiation.offer.signingBonus;
                document.getElementById('budget').textContent = gameState.budget;
                recordTransferExpense(negotiation.offer.signingBonus);
                
                // CRITICAL: Remove player from ALL scout reports to prevent multiple offers
                removePlayerFromScoutReports(negotiation.player);
                
                showCustomAlert(`üéâ ${negotiation.player.name} accepted your offer and joined your team!`);
            } else {
                showCustomAlert(`‚ùå ${negotiation.player.name} rejected your offer. They want better terms or prefer their current team.`);
            }
            
            updateContractNegotiationsList();
            updateScoutReportsList(); // Update scout reports display to show player removal
            displayPlayers();
            autoSave();
        }
        
        // Calculate acceptance chance
        function calculateAcceptanceChance(negotiation) {
            const player = negotiation.player;
            const offer = negotiation.offer;
            const suggested = negotiation.scoutReport.contractSuggestion;
            
            let chance = 0.3; // Base 30% chance
            
            // Offer competitiveness
            const bonusRatio = offer.signingBonus / suggested.signingBonus;
            const salaryRatio = offer.perGameSalary / suggested.perGameSalary;
            const lengthRatio = offer.contractLength / suggested.contractLength;
            
            // Better offers increase chance
            if (bonusRatio >= 1.2) chance += 0.3; // 20% over suggestion
            else if (bonusRatio >= 1.0) chance += 0.2; // At suggestion
            else if (bonusRatio >= 0.8) chance += 0.1; // 80% of suggestion
            
            if (salaryRatio >= 1.2) chance += 0.3;
            else if (salaryRatio >= 1.0) chance += 0.2;
            else if (salaryRatio >= 0.8) chance += 0.1;
            
            // Longer contracts are more attractive
            if (lengthRatio >= 1.0) chance += 0.1;
            
            // Player factors
            if (player.age > 30) chance += 0.1; // Older players more likely to move
            if (player.isStar) chance -= 0.2; // Stars are harder to get
            
            // Team strength factor (simplified)
            const playerTeamPosition = Math.floor(Math.random() * 8) + 1; // Simulate current team position
            if (playerTeamPosition > 5) chance += 0.2; // Players from weak teams more likely to move
            
            // Random loyalty factor
            chance += (Math.random() - 0.5) * 0.3; // ¬±15% random factor
            
            return Math.max(0.05, Math.min(0.95, chance)); // Clamp between 5% and 95%
        }
        
        // Remove player from all scout reports (to prevent multiple offers)
        function removePlayerFromScoutReports(player) {
            // Remove from scout reports
            marketState.scoutReports = marketState.scoutReports.filter(report => 
                !(report.player.name === player.name && 
                  report.player.age === player.age && 
                  report.player.type === player.type)
            );
            
            // Remove from any pending contract negotiations
            marketState.contractNegotiations = marketState.contractNegotiations.filter(negotiation => 
                !(negotiation.player.name === player.name && 
                  negotiation.player.age === player.age && 
                  negotiation.player.type === player.type)
            );
        }
        
        // Add player to team
        function addPlayerToTeam(player, contract) {
            // Check roster space
            if (gameState.players.length >= 20) {
                showCustomAlert('Your roster is full! Release a player first before signing new ones.');
                return false;
            }
            
            // CRITICAL: Remove player from their original AI team roster
            removePlayerFromAITeams(player);
            
            // Create new player object for your team
            const newPlayer = {
                ...player,
                contract: {
                    signingBonus: contract.signingBonus,
                    perGameSalary: contract.perGameSalary,
                    contractLength: contract.contractLength,
                    seasonsRemaining: contract.contractLength
                },
                isTransfer: true,
                transferDate: Date.now(),
                // Mark as transferred to prevent future scouting
                isTransferred: true
            };
            
            gameState.players.push(newPlayer);
            
            // CRITICAL FIX: Update the team selection dropdown after adding player
            updatePlayerSelector();
            
            return true;
        }
        
        // Remove player from AI teams after successful transfer
        function removePlayerFromAITeams(transferredPlayer) {
            gameState.aiTeams.forEach(team => {
                // Find and remove the player from this team's roster
                const playerIndex = team.players.findIndex(p => 
                    p.name === transferredPlayer.name && 
                    p.age === transferredPlayer.age &&
                    p.type === transferredPlayer.type
                );
                
                if (playerIndex !== -1) {
                    console.log(`Removing ${transferredPlayer.name} from ${team.name}'s roster`);
                    team.players.splice(playerIndex, 1);
                    
                    // Replace with a new player of the same type to maintain team balance
                    const replacementPlayer = new CricketPlayer(transferredPlayer.type, team.level);
                    team.players.push(replacementPlayer);
                    console.log(`Added replacement player ${replacementPlayer.name} to ${team.name}`);
                }
            });
        }
        
        // Update contract negotiations list
        function updateContractNegotiationsList() {
            const listElement = document.getElementById('contract-negotiations-list');
            const noNegotiationsElement = document.getElementById('no-negotiations');
            
            if (marketState.contractNegotiations.length === 0) {
                listElement.innerHTML = '';
                noNegotiationsElement.style.display = 'block';
                return;
            }
            
            noNegotiationsElement.style.display = 'none';
            
            listElement.innerHTML = marketState.contractNegotiations.map(negotiation => {
                const statusColor = negotiation.status === 'pending' ? 'text-yellow-600 dark:text-yellow-400' :
                                   negotiation.status === 'accepted' ? 'text-green-600 dark:text-green-400' :
                                   'text-red-600 dark:text-red-400';
                
                const statusIcon = negotiation.status === 'pending' ? '‚è≥' :
                                  negotiation.status === 'accepted' ? '‚úÖ' :
                                  '‚ùå';
                
                return `
                    <div class="bg-white dark:bg-gray-700 p-4 rounded border">
                        <div class="flex justify-between items-start mb-2">
                            <div>
                                <h4 class="font-bold">${negotiation.player.name}</h4>
                                <p class="text-sm text-gray-600 dark:text-gray-400">${negotiation.player.type} ‚Ä¢ Age ${negotiation.player.age} ‚Ä¢ From ${negotiation.teamName}</p>
                            </div>
                            <div class="text-right">
                                <p class="font-medium ${statusColor}">${statusIcon} ${negotiation.status.toUpperCase()}</p>
                            </div>
                        </div>
                        
                        <div class="text-sm">
                            <p><strong>Your Offer:</strong></p>
                            <p>Signing: $${negotiation.offer.signingBonus.toLocaleString()} | Per Game: $${negotiation.offer.perGameSalary.toLocaleString()} | ${negotiation.offer.contractLength} season(s)</p>
                        </div>
                        
                        ${negotiation.status === 'pending' ? '<p class="text-xs text-gray-500 mt-2">Awaiting player response...</p>' : ''}
                    </div>
                `;
            }).join('');
        }
        
        // Update free agents list (simplified for now)
        function updateFreeAgentsList() {
            const listElement = document.getElementById('free-agents-list');
            const noAgentsElement = document.getElementById('no-free-agents');
            
            // For now, show placeholder
            listElement.innerHTML = '';
            noAgentsElement.style.display = 'block';
        }
        
        // Update transfer window status
        function updateTransferWindowStatus() {
            const statusElement = document.getElementById('transfer-window-status');
            
            if (marketState.transferWindowOpen) {
                statusElement.textContent = 'Open - You can make contract offers';
                statusElement.className = 'text-sm text-green-600 dark:text-green-400';
            } else {
                statusElement.textContent = 'Closed - Transfer window not active';
                statusElement.className = 'text-sm text-red-600 dark:text-red-400';
            }
        }
        
        // Initialize market system
        function initializeMarketSystem() {
            checkMarketAvailability();
        }
        
        // Update market check on competition change
        function updateMarketForCompetition() {
            checkMarketAvailability();
        }
        
        // CRITICAL: Update scout button state based on timing
        function updateScoutButtonState() {
            const sendButton = document.getElementById('send-scouts-btn');
            if (!sendButton) return;
            
            if (!marketState.scoutingEnabled) {
                sendButton.disabled = true;
                sendButton.textContent = 'Scouting Not Available';
                sendButton.className = 'px-3 py-2 bg-gray-400 text-white rounded text-sm cursor-not-allowed';
            } else if (marketState.scoutCooldown) {
                sendButton.disabled = true;
                sendButton.textContent = 'Scouting...';
                sendButton.className = 'px-3 py-2 bg-gray-400 text-white rounded text-sm cursor-not-allowed';
            } else {
                sendButton.disabled = false;
                sendButton.textContent = 'üîç Send Scouts Out ($500)';
                sendButton.className = 'px-3 py-2 bg-green-500 text-white hover:bg-green-600 rounded text-sm';
            }
        }
        
        // CRITICAL: Process scout reports expiry after matches
        function processScoutReportExpiry() {
            marketState.scoutReports = marketState.scoutReports.filter(report => {
                report.expiresAfterGames--;
                return report.expiresAfterGames > 0;
            });
            
            // Update display if any reports were removed
            updateScoutReportsList();
        }
        
        // CRITICAL: Track games for scouting timing
        function updateScoutingTiming() {
            const playerStanding = gameState.leagueStandings.find(s => s.isPlayer);
            const gamesPlayed = playerStanding ? playerStanding.gamesPlayed : 0;
            
            // CRITICAL: Scout timing rules:
            // - Available at start of season (games = 0)
            // - Disabled after first game until first away game
            // - First away game re-enables scouting
            
            if (gamesPlayed === 0) {
                // Start of season - scouts available
                marketState.scoutingEnabled = true;
            } else if (gamesPlayed === 1) {
                // After first game - disable scouts
                marketState.scoutingEnabled = false;
            } else {
                // Check if this is the first away game of the season
                // Look through recent results to find first away game
                const playerResults = gameState.recentResults.filter(result => 
                    result.team1 === gameState.teamName || result.team2 === gameState.teamName
                );
                
                // Find first away game (where user's team is team2)
                const firstAwayGame = playerResults.find(result => result.team2 === gameState.teamName);
                
                if (firstAwayGame && !marketState.firstAwayGameScoutingEnabled) {
                    // This is or was the first away game - enable scouting
                    marketState.scoutingEnabled = true;
                    marketState.firstAwayGameScoutingEnabled = true;
                } else if (!marketState.firstAwayGameScoutingEnabled) {
                    // Still waiting for first away game
                    marketState.scoutingEnabled = false;
                }
            }
            
            // Process scout report expiry
            processScoutReportExpiry();
            
            // Update button state
            updateScoutButtonState();
        }
        
        // Start the game
        initGame();
        
        // Initialize training system
        initializeTrainingSystem();
        
        // Initialize market system
        initializeMarketSystem();
    </script>
</body>
</html>
