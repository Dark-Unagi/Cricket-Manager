<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cricket Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-button.active { 
            background-color: #5D5CDE; 
            color: white; 
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
    <!-- Header -->
    <div class="bg-green-600 dark:bg-green-700 text-white p-4 shadow-lg">
        <h1 class="text-2xl font-bold text-center">Cricket Manager</h1>
        <div class="text-center mt-2">
            <span class="text-sm">Local Club Level</span> | 
            <span class="text-sm">Budget: $<span id="budget">50000</span></span>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="bg-gray-100 dark:bg-gray-800 flex border-b border-gray-200 dark:border-gray-700">
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium border-r border-gray-200 dark:border-gray-700 active" onclick="showTab('roster')">
            Roster
        </button>
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium border-r border-gray-200 dark:border-gray-700" onclick="showTab('market')">
            Market
        </button>
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium border-r border-gray-200 dark:border-gray-700" onclick="showTab('training')">
            Training
        </button>
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium border-r border-gray-200 dark:border-gray-700" onclick="showTab('game')">
            Game
        </button>
        <button class="tab-button flex-1 py-3 px-1 text-xs font-medium" onclick="showTab('league')">
            League
        </button>
    </div>

    <!-- Tab Contents -->
    <div class="p-4">
        <!-- Roster Tab -->
        <div id="roster-tab" class="tab-content active">
            <h2 class="text-xl font-bold mb-4">Team Roster (<span id="roster-count">15</span>/20)</h2>
            
            <!-- Team Name Editor -->
            <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg border mb-4">
                <label class="block text-sm font-medium mb-2">Team Name:</label>
                <input type="text" id="team-name-input" value="Your Team" onchange="updateTeamName()" 
                       class="w-full text-base p-2 border rounded dark:bg-gray-700 dark:border-gray-600" 
                       placeholder="Enter your team name...">
            </div>
            
            <!-- Filter Buttons -->
            <div class="flex flex-wrap gap-2 mb-4">
                <button onclick="filterPlayers('all')" class="filter-btn bg-blue-500 text-white px-3 py-1 rounded text-sm">All</button>
                <button onclick="filterPlayers('Batter')" class="filter-btn bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded text-sm">Batters</button>
                <button onclick="filterPlayers('Bowler')" class="filter-btn bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded text-sm">Bowlers</button>
                <button onclick="filterPlayers('All-rounder')" class="filter-btn bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded text-sm">All-rounders</button>
            </div>

            <!-- Player List -->
            <div id="player-list" class="space-y-3">
                <!-- Players will be generated here -->
            </div>
        </div>

        <!-- Market Tab -->
        <div id="market-tab" class="tab-content">
            <h2 class="text-xl font-bold mb-4">Transfer Market</h2>
            <div class="text-center text-gray-500 mt-8">
                <p>Market features coming soon!</p>
                <p class="text-sm mt-2">Scout for players, buy rising stars, and trade with other clubs.</p>
            </div>
        </div>

        <!-- Training Tab -->
        <div id="training-tab" class="tab-content">
            <h2 class="text-xl font-bold mb-4">Training Center</h2>
            
            <!-- Training Information Panel -->
            <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg border mb-6">
                <h3 class="text-lg font-bold mb-2 text-blue-800 dark:text-blue-200">üèÉ Training System</h3>
                <div class="text-sm text-blue-700 dark:text-blue-300 space-y-1">
                    <p>‚Ä¢ <strong>Gradual Growth:</strong> Players improve slowly over 2-3 games after training</p>
                    <p>‚Ä¢ <strong>Increasing Costs:</strong> Each training session costs 50% more than the last</p>
                    <p>‚Ä¢ <strong>Individual Limits:</strong> Every player has natural talent ceilings</p>
                    <p>‚Ä¢ <strong>Specialization:</strong> Focus on key skills to build world-class players</p>
                </div>
            </div>
            
            <!-- Player Selection for Training -->
            <div class="mb-6">
                <label class="block text-lg font-bold mb-3">Select Player to Train:</label>
                <select id="training-player-selector" onchange="selectPlayerForTraining()" class="w-full text-base p-3 border rounded-lg dark:bg-gray-700 dark:border-gray-600">
                    <option value="">Choose a player...</option>
                </select>
            </div>
            
            <!-- Selected Player Training Panel -->
            <div id="player-training-panel" class="bg-gray-50 dark:bg-gray-800 rounded-lg p-6 border" style="display: none;">
                <div class="flex justify-between items-start mb-4">
                    <div>
                        <h3 id="training-player-name" class="text-xl font-bold">Player Name</h3>
                        <p id="training-player-type" class="text-sm text-gray-600 dark:text-gray-400">Player Type</p>
                    </div>
                    <div class="text-right">
                        <p class="text-sm text-gray-600 dark:text-gray-400">Age: <span id="training-player-age">25</span></p>
                        <p class="text-sm text-gray-600 dark:text-gray-400">Games: <span id="training-player-games">15</span></p>
                    </div>
                </div>
                
                <!-- Active Training Queue -->
                <div id="training-queue-section" class="mb-6" style="display: none;">
                    <h4 class="font-bold text-green-600 dark:text-green-400 mb-2">üéØ Active Training</h4>
                    <div id="training-queue-list" class="space-y-2">
                        <!-- Active training items will appear here -->
                    </div>
                </div>
                
                <!-- Training Skills Grid -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    
                    <!-- Batting Training -->
                    <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-blue-600 dark:text-blue-400 mb-3">üèè Batting Training</h4>
                        <div class="space-y-3">
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Defense Training</span>
                                    <span id="defense-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">45/85</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Reduces dismissal chance, improves consistency</p>
                                <div class="flex justify-between items-center">
                                    <span id="defense-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('battingDefense')" id="defense-btn" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Aggression Training</span>
                                    <span id="aggression-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">32/78</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Increases boundary hitting, higher strike rates</p>
                                <div class="flex justify-between items-center">
                                    <span id="aggression-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('battingAggression')" id="aggression-btn" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Consistency Training</span>
                                    <span id="consistency-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">28/92</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">More predictable scores, fewer low scores</p>
                                <div class="flex justify-between items-center">
                                    <span id="consistency-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('battingConsistency')" id="consistency-btn" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                    
                    <!-- Bowling Training -->
                    <div id="bowling-training-section" class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-red-600 dark:text-red-400 mb-3">‚öæ Bowling Training</h4>
                        <div class="space-y-3">
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Defensive Bowling</span>
                                    <span id="bowl-defense-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">35/71</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Limits runs, fewer extras (wides/no-balls)</p>
                                <div class="flex justify-between items-center">
                                    <span id="bowl-defense-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('bowlingDefense')" id="bowl-defense-btn" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Aggressive Bowling</span>
                                    <span id="bowl-aggression-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">41/66</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Takes more wickets, may concede more runs</p>
                                <div class="flex justify-between items-center">
                                    <span id="bowl-aggression-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('bowlingAggression')" id="bowl-aggression-btn" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Bowling Consistency</span>
                                    <span id="bowl-consistency-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">29/89</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Follows captain's plans, balanced approach</p>
                                <div class="flex justify-between items-center">
                                    <span id="bowl-consistency-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$500</span>
                                    <button onclick="startTraining('bowlingConsistency')" id="bowl-consistency-btn" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                    
                    <!-- Fielding Training -->
                    <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-green-600 dark:text-green-400 mb-3">ü•Ö Fielding Training</h4>
                        <div class="space-y-3">
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Catching Practice</span>
                                    <span id="catching-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">33/75</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Fewer dropped catches, helps bowlers take wickets</p>
                                <div class="flex justify-between items-center">
                                    <span id="catching-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$300</span>
                                    <button onclick="startTraining('fieldingCatching')" id="catching-btn" class="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <div class="training-skill-item">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Agility Training</span>
                                    <span id="agility-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">27/81</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Better ground fielding, more run-outs</p>
                                <div class="flex justify-between items-center">
                                    <span id="agility-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$300</span>
                                    <button onclick="startTraining('fieldingAgility')" id="agility-btn" class="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                    
                    <!-- Specialist Training -->
                    <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                        <h4 class="font-bold text-purple-600 dark:text-purple-400 mb-3">‚≠ê Specialist Training</h4>
                        <div class="space-y-3">
                            
                            <!-- Wicket-Keeping Training -->
                            <div id="wicketkeeping-training" class="training-skill-item" style="display: none;">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Wicket-Keeping</span>
                                    <span id="wicketkeeping-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">0/0</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Stops byes, stumping chances, catching edges</p>
                                <div class="flex justify-between items-center">
                                    <span id="wicketkeeping-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$400</span>
                                    <button onclick="startTraining('wicketKeeping')" id="wicketkeeping-btn" class="px-3 py-1 bg-purple-500 text-white rounded text-sm hover:bg-purple-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Captaincy Training -->
                            <div id="captaincy-training" class="training-skill-item" style="display: none;">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-medium">Captaincy</span>
                                    <span id="captaincy-level" class="text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">0/0</span>
                                </div>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Better bowling changes, field placements</p>
                                <div class="flex justify-between items-center">
                                    <span id="captaincy-cost" class="text-sm font-bold text-green-600 dark:text-green-400">$600</span>
                                    <button onclick="startTraining('captaincy')" id="captaincy-btn" class="px-3 py-1 bg-purple-500 text-white rounded text-sm hover:bg-purple-600">
                                        Train
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Message for non-specialists -->
                            <div id="no-specialist-training" class="text-center text-gray-500 py-4">
                                <p class="text-sm">This player is not a wicket-keeper or captain.</p>
                                <p class="text-xs mt-1">Assign specialist roles in the Roster tab first.</p>
                            </div>
                            
                        </div>
                    </div>
                    
                </div>
            </div>
        </div>

        <!-- Game Tab -->
        <div id="game-tab" class="tab-content">
            <h2 id="competition-title" class="text-xl font-bold mb-4">Local Cup</h2>
            
            <!-- Competition Selection -->
            <div class="grid grid-cols-2 gap-2 mb-6">
                <button id="local-btn" onclick="selectCompetition('local')" class="competition-btn bg-green-500 text-white py-2 px-3 rounded text-sm font-medium">
                    Local Cup
                </button>
                <button id="national-btn" onclick="selectCompetition('national')" disabled class="competition-btn bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 py-2 px-3 rounded text-sm font-medium cursor-not-allowed">
                    National Cup
                </button>
                <button id="worldcup-btn" onclick="selectCompetition('worldcup')" disabled class="competition-btn bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 py-2 px-3 rounded text-sm font-medium cursor-not-allowed">
                    World Cup
                </button>
                <button id="test-btn" onclick="selectCompetition('test')" disabled class="competition-btn bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 py-2 px-3 rounded text-sm font-medium cursor-not-allowed">
                    Test World Series
                </button>
            </div>
            
            <!-- Match Day Report -->
            <div id="match-day-report" class="bg-gradient-to-r from-green-50 to-blue-50 dark:from-green-900 dark:to-blue-900 p-4 rounded-lg border mb-6">
                <h3 class="text-lg font-bold mb-3 text-center">üìä Match Day Report</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div class="bg-white dark:bg-gray-800 p-3 rounded">
                        <h4 class="font-medium mb-2">üèüÔ∏è Venue Details</h4>
                        <p class="text-sm"><strong>Opponent:</strong> <span id="opponent-name">Thunder Hawks</span></p>
                        <p class="text-sm"><strong>Venue:</strong> <span id="home-away">Home Match</span></p>
                        <p class="text-sm text-green-600 dark:text-green-400 text-xs mt-1" id="home-advantage">üè† Home crowd advantage: +5% motivation boost</p>
                    </div>
                    
                    <div class="bg-white dark:bg-gray-800 p-3 rounded">
                        <h4 class="font-medium mb-2">üèè Pitch Conditions</h4>
                        <p class="text-sm"><strong>Pitch Type:</strong> <span id="pitch-type">Fast Pitch</span></p>
                        <p class="text-sm"><strong>Weather:</strong> <span id="weather-conditions">Sunny & Clear</span></p>
                        <p class="text-sm text-blue-600 dark:text-blue-400 text-xs mt-1" id="conditions-effect">‚ö° Favors fast bowlers and power hitters</p>
                    </div>
                </div>
                
                <div class="text-center text-xs text-gray-600 dark:text-gray-400">
                    Next scheduled match for your team
                </div>
            </div>
            
            <!-- Match Control Buttons -->
            <div class="text-center mb-6">
                <button id="start-match-btn" onclick="startMatch()" class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg text-lg font-medium">
                    üèè Start Match
                </button>
                <button id="auto-complete-btn" onclick="autoCompleteMatch()" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg text-lg font-medium ml-4" style="display: none;">
                    ‚ö° Auto-Complete
                </button>
            </div>
            
            <!-- Live Match Details -->
            <div id="live-match-details" class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg border mb-6" style="display: none;">
                <h3 class="text-lg font-bold mb-3 text-center">üî¥ Live Match</h3>
                <div id="match-commentary" class="space-y-2 max-h-64 overflow-y-auto">
                    <!-- Live match updates will appear here -->
                </div>
            </div>
            
            <!-- Team Selection -->
            <div class="mb-6">
                <h3 class="text-lg font-bold mb-3">üèè Team Selection</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Your Team XI -->
                    <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg">
                        <h4 class="font-medium mb-3 text-blue-800 dark:text-blue-200">Your Team XI</h4>
                        <div id="your-team-xi" class="space-y-2">
                            <!-- Will be populated by selectPlayerForXI -->
                        </div>
                        <div class="mt-3">
                            <label class="block text-sm font-medium mb-2">Select players from roster:</label>
                            <select id="player-selector" onchange="selectPlayerForXI()" class="w-full text-base p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
                                <option value="">Choose a player...</option>
                                <!-- Will be populated with available players -->
                            </select>
                        </div>
                    </div>
                    
                    <!-- Opponent XI -->
                    <div class="bg-red-50 dark:bg-red-900 p-4 rounded-lg">
                        <h4 class="font-medium mb-3 text-red-800 dark:text-red-200"><span id="opponent-team-name">Thunder Hawks</span> XI</h4>
                        <div id="opponent-team-xi" class="space-y-2">
                            <!-- Will be populated with opponent's team -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Team Strategy -->
            <div class="mb-6">
                <h3 class="text-lg font-bold mb-3">üìã Team Strategy</h3>
                
                <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">Batting Strategy:</label>
                            <select id="batting-strategy" class="w-full text-base p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
                                <option value="conservative">Take it slow, don't get out</option>
                                <option value="aggressive">Hit hard, score fast</option>
                                <option value="balanced">Play safe but look for runs</option>
                                <option value="captain-choice">Let captain decide</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium mb-2">Toss Strategy:</label>
                            <select id="toss-strategy" class="w-full text-base p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
                                <option value="bat-first">If we win toss, we bat</option>
                                <option value="field-first">If we win toss, we field</option>
                                <option value="captain-choice">Let captain decide</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- League Tab -->
        <div id="league-tab" class="tab-content">
            <h2 id="league-title" class="text-xl font-bold mb-4">Local Cup Standings</h2>
            
            <!-- League Table -->
            <div class="bg-gray-50 dark:bg-gray-800 rounded-lg overflow-hidden mb-6">
                <div class="grid grid-cols-6 gap-2 p-3 bg-gray-200 dark:bg-gray-700 text-xs font-medium">
                    <div>Team</div>
                    <div class="text-center">P</div>
                    <div class="text-center">W</div>
                    <div class="text-center">L</div>
                    <div class="text-center">Pts</div>
                    <div class="text-center">NRR</div>
                </div>
                <div id="standings-list">
                    <!-- Standings will be generated here -->
                </div>
            </div>
            
            <!-- Season Schedule -->
            <div class="bg-gray-50 dark:bg-gray-800 rounded-lg overflow-hidden mb-6">
                <div class="flex justify-between items-center p-3 bg-gray-200 dark:bg-gray-700">
                    <h3 class="text-lg font-bold">Season Schedule</h3>
                    <button onclick="toggleSchedule()" id="schedule-toggle" class="text-sm px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">
                        Show Schedule
                    </button>
                </div>
                <div id="season-schedule" class="p-4 space-y-4" style="display: none;">
                    <!-- Schedule will be generated here -->
                </div>
            </div>

            <!-- Recent Results -->
            <h3 class="text-lg font-bold mb-3">Recent Results</h3>
            <div id="recent-results" class="space-y-2">
                <!-- Recent match results will show here -->
            </div>
        </div>
    </div>

    <script>
        // Dark mode support
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Game state
        const gameState = {
            budget: 50000,
            level: 'Local Club',
            teamName: 'Your Team',
            players: [],
            currentFilter: 'all',
            currentCompetition: 'local',
            competitions: {
                local: { unlocked: true, completed: false },
                national: { unlocked: false, completed: false },
                worldcup: { unlocked: false, completed: false },
                test: { unlocked: false, completed: false }
            },
            aiTeams: [],
            leagueStandings: [],
            recentResults: [],
            // Fan base and income system
            fanBase: 15, // Starting fan base (secret from player)
            totalIncome: 0, // Total income earned
            winStreak: 0, // Current win streak
            lossStreak: 0 // Current loss streak
        };

        // Player class for generating cricketers
        class CricketPlayer {
            constructor(type, level = 'local') {
                this.name = this.generateName();
                this.age = Math.floor(Math.random() * 15) + 18; // 18-32
                this.type = type;
                this.gamesPlayed = Math.floor(Math.random() * 50);
                this.isWicketKeeper = Math.random() < 0.1; // 10% chance
                this.isInjured = false;
                this.injuryDaysLeft = 0;
                
                // Generate stats based on level and type
                this.generateStats(level);
                
                // Generate hidden traits
                this.generateHiddenTraits();
                
                // Assign bowling type for bowlers and all-rounders
                if (type === 'Bowler' || type === 'All-rounder') {
                    this.bowlingType = this.generateBowlingType();
                }
            }
            
            generateName() {
                const firstNames = ['Alex', 'Ben', 'Chris', 'Dan', 'Ethan', 'Felix', 'George', 'Harry', 'Ian', 'Jack', 
                                 'Kyle', 'Luke', 'Matt', 'Nick', 'Owen', 'Paul', 'Quinn', 'Ryan', 'Sam', 'Tom',
                                 'Aaron', 'Blake', 'Connor', 'David', 'Eric', 'Frank', 'Glen', 'Henry', 'Isaac', 'James'];
                const lastNames = ['Smith', 'Jones', 'Brown', 'Wilson', 'Taylor', 'Clark', 'White', 'Hall', 'Green', 'Adams',
                                 'Baker', 'Cooper', 'Evans', 'Fisher', 'Gray', 'Hill', 'King', 'Lee', 'Miller', 'Moore',
                                 'Parker', 'Roberts', 'Scott', 'Turner', 'Walker', 'Young', 'Allen', 'Bell', 'Carter', 'Davis'];
                
                return firstNames[Math.floor(Math.random() * firstNames.length)] + ' ' + 
                       lastNames[Math.floor(Math.random() * lastNames.length)];
            }
            
            generateStats(level) {
                // Base stats influenced by level (local = lower, higher levels = better)
                const levelMultiplier = level === 'local' ? 0.6 : level === 'national' ? 0.8 : 1.0;
                
                // Local Cup: 10-25 games played
                this.gamesPlayed = Math.floor(Math.random() * 16) + 10; // 10-25 games
                
                // ALL PLAYERS HAVE BATTING STATS (since all players must bat)
                // Generate realistic batting average for level
                const baseAverage = level === 'local' ? 
                    (15 + Math.random() * 25) : // 15-40 for local
                    level === 'national' ? 
                    (20 + Math.random() * 30) : // 20-50 for national
                    (25 + Math.random() * 35); // 25-60 for international
                
                this.battingAverage = Math.floor(baseAverage * levelMultiplier);
                
                // Calculate total runs based on average and games (with some variance)
                const runsVariance = 0.8 + Math.random() * 0.4; // 0.8 to 1.2 multiplier
                this.totalRuns = Math.floor(this.battingAverage * this.gamesPlayed * runsVariance);
                
                // Strike rate (runs per 100 balls) - realistic for level
                this.strikeRate = Math.floor((60 + Math.random() * 80) * levelMultiplier); // 60-140 for local
                
                // High score should be realistic (typically 1.5-3x average, max around 150-200 for local)
                const highScoreMultiplier = 1.5 + Math.random() * 1.5; // 1.5-3x average
                this.highScore = Math.min(
                    Math.floor(this.battingAverage * highScoreMultiplier + Math.random() * 20),
                    level === 'local' ? 180 : level === 'national' ? 220 : 300
                );
                
                // 50s and 100s based on total runs and high score
                this.fifties = Math.floor(this.totalRuns / (this.battingAverage * 8)); // Rough estimate
                this.hundreds = Math.floor(this.totalRuns / (this.battingAverage * 20)); // Even rougher
                
                // Adjust for high score - can't have hundreds if high score < 100
                if (this.highScore < 100) {
                    this.hundreds = 0;
                    this.fifties = Math.min(this.fifties, Math.floor(this.totalRuns / (this.battingAverage * 12)));
                }
                if (this.highScore < 50) {
                    this.fifties = 0;
                }
                
                // BOWLING STATS (only for bowlers and all-rounders)
                if (this.type === 'Bowler' || this.type === 'All-rounder') {
                    // Economy rate (runs per over) - realistic for amateur cricket
                    this.economyRate = Math.max(3.0, 4.0 + Math.random() * 4.0 + (2.0 - levelMultiplier * 2)); // 3-8 runs per over
                    
                    // Total wickets based on games played and bowling skill
                    const wicketsPerGame = level === 'local' ? 
                        (1 + Math.random() * 2.5) * levelMultiplier : // 0.6-2.1 wickets per game for local
                        (1.5 + Math.random() * 3) * levelMultiplier;
                    this.totalWickets = Math.floor(wicketsPerGame * this.gamesPlayed);
                    
                    // Best bowling figures - realistic performances
                    const bestWickets = Math.min(
                        Math.floor(Math.random() * 4) + 3, // 3-6 wickets
                        Math.min(7, this.totalWickets) // Can't be more than total wickets or 7
                    );
                    
                    // Calculate realistic runs for best bowling (good bowling performance)
                    const runsPerWicket = this.economyRate * 3 + Math.random() * 10; // 3 overs per wicket + variance
                    const bestRuns = Math.floor(bestWickets * runsPerWicket * 0.7); // 30% better than average
                    this.bestBowling = `${bestWickets}/${bestRuns}`;
                    
                    // 5-wicket and 10-wicket hauls (rare achievements)
                    this.fiveWicketHauls = bestWickets >= 5 ? Math.floor(this.totalWickets / 25) : 0;
                    this.tenWicketHauls = 0; // Very rare in limited overs cricket
                    
                    // For longer format cricket, 10-wicket hauls might happen
                    if (level !== 'local' && this.totalWickets > 50) {
                        this.tenWicketHauls = Math.floor(this.totalWickets / 80);
                    }
                }
            }
            
            generateHiddenTraits() {
                this.hiddenTraits = [];
                
                // 70% chance of no trait, 25% chance of 1 trait, 5% chance of 2 traits
                const traitCount = Math.random() < 0.7 ? 0 : Math.random() < 0.95 ? 1 : 2;
                
                const negativeTraits = ['Bad Run Calling', 'Dropsies', 'Wild Balls', 'Injury Prone'];
                const positiveTraits = ['Rock Solid', 'Big Hitter', 'Fast Pitch Specialist', 'Slow Pitch Specialist', 
                                      'Bouncy Pitch Specialist', 'Spin Specialist', 'Pace Specialist', 'Great Fielder'];
                
                for (let i = 0; i < traitCount; i++) {
                    const isPositive = Math.random() < 0.6; // 60% chance positive trait
                    const traits = isPositive ? positiveTraits : negativeTraits;
                    const trait = traits[Math.floor(Math.random() * traits.length)];
                    
                    if (!this.hiddenTraits.includes(trait)) {
                        this.hiddenTraits.push(trait);
                    }
                }
                
                // Initialize training system
                this.initializeTrainingSystem();
            }
            
            initializeTrainingSystem() {
                // Training skills (0-100 scale, start at 20-40 for amateurs)
                this.trainingSkills = {
                    // Batting skills
                    battingDefense: Math.floor(Math.random() * 20) + 20,    // 20-39
                    battingAggression: Math.floor(Math.random() * 20) + 20, // 20-39
                    battingConsistency: Math.floor(Math.random() * 20) + 20, // 20-39
                    
                    // Bowling skills (only for bowlers/all-rounders)
                    bowlingDefense: this.type !== 'Batter' ? Math.floor(Math.random() * 20) + 20 : 0,
                    bowlingAggression: this.type !== 'Batter' ? Math.floor(Math.random() * 20) + 20 : 0,
                    bowlingConsistency: this.type !== 'Batter' ? Math.floor(Math.random() * 20) + 20 : 0,
                    
                    // Fielding (all players)
                    fieldingCatching: Math.floor(Math.random() * 20) + 20,   // 20-39
                    fieldingAgility: Math.floor(Math.random() * 20) + 20,    // 20-39
                    
                    // Specialist skills
                    wicketKeeping: this.isWicketKeeper ? Math.floor(Math.random() * 20) + 20 : 0,
                    captaincy: this.isCaptain ? Math.floor(Math.random() * 20) + 20 : 0
                };
                
                // Natural talent ceiling (60-95, determines max potential)
                this.talentCeiling = {
                    battingDefense: Math.floor(Math.random() * 35) + 60,    // 60-94
                    battingAggression: Math.floor(Math.random() * 35) + 60,
                    battingConsistency: Math.floor(Math.random() * 35) + 60,
                    bowlingDefense: Math.floor(Math.random() * 35) + 60,
                    bowlingAggression: Math.floor(Math.random() * 35) + 60,
                    bowlingConsistency: Math.floor(Math.random() * 35) + 60,
                    fieldingCatching: Math.floor(Math.random() * 35) + 60,
                    fieldingAgility: Math.floor(Math.random() * 35) + 60,
                    wicketKeeping: Math.floor(Math.random() * 35) + 60,
                    captaincy: Math.floor(Math.random() * 35) + 60
                };
                
                // Training costs (start at base, multiply by 1.5 each time)
                this.trainingCosts = {
                    battingDefense: 500,
                    battingAggression: 500,
                    battingConsistency: 500,
                    bowlingDefense: 500,
                    bowlingAggression: 500,
                    bowlingConsistency: 500,
                    fieldingCatching: 300,
                    fieldingAgility: 300,
                    wicketKeeping: 400,
                    captaincy: 600
                };
                
                // Training queue (pending improvements)
                this.trainingQueue = [];
                
                // Training difficulty (some players struggle with certain skills)
                this.trainingDifficulty = this.generateTrainingDifficulty();
            }
            
            generateTrainingDifficulty() {
                // Some players find certain skills harder to learn
                const difficulty = {};
                const skills = Object.keys(this.trainingCosts);
                
                skills.forEach(skill => {
                    // 70% normal, 20% easier, 10% harder
                    const rand = Math.random();
                    if (rand < 0.1) {
                        difficulty[skill] = 'hard';    // +50% cost, slower progress
                    } else if (rand < 0.3) {
                        difficulty[skill] = 'easy';    // -25% cost, faster progress
                    } else {
                        difficulty[skill] = 'normal';  // Standard rates
                    }
                });
                
                return difficulty;
            }
            
            generateBowlingType() {
                const types = ['Fast', 'Medium', 'Swing', 'Off-spin', 'Leg-spin'];
                return types[Math.floor(Math.random() * types.length)];
            }
        }

        // Generate initial roster
        function generateInitialRoster() {
            const roster = [];
            
            // Generate 6 batters, 5 bowlers, 4 all-rounders
            for (let i = 0; i < 6; i++) roster.push(new CricketPlayer('Batter'));
            for (let i = 0; i < 5; i++) roster.push(new CricketPlayer('Bowler'));
            for (let i = 0; i < 4; i++) roster.push(new CricketPlayer('All-rounder'));
            
            return roster;
        }

        // Display players
        function displayPlayers() {
            const playerList = document.getElementById('player-list');
            const filteredPlayers = gameState.currentFilter === 'all' ? 
                gameState.players : gameState.players.filter(p => p.type === gameState.currentFilter);
            
            playerList.innerHTML = filteredPlayers.map(player => {
                let statsHTML = `
                    <div class="text-xs text-gray-600 dark:text-gray-400 mt-1">
                        Games: ${player.gamesPlayed} | Age: ${player.age}
                        <br><strong>BATTING:</strong>
                        <br>Runs: ${player.totalRuns} | Avg: ${player.battingAverage} | S/R: ${player.strikeRate}
                        <br>High Score: ${player.highScore} | 50s: ${player.fifties} | 100s: ${player.hundreds}
                `;
                
                if (player.type === 'Bowler' || player.type === 'All-rounder') {
                    statsHTML += `
                        <br><br><strong>BOWLING:</strong>
                        <br>Wickets: ${player.totalWickets} | Economy: ${player.economyRate.toFixed(1)}
                        <br>Best: ${player.bestBowling} | 5w: ${player.fiveWicketHauls} | 10w: ${player.tenWicketHauls}
                        ${player.bowlingType ? `<br>Style: ${player.bowlingType}` : ''}
                    `;
                }
                
                statsHTML += '</div>';
                
                const typeColor = player.type === 'Batter' ? 'bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200' :
                                player.type === 'Bowler' ? 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200' :
                                'bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200';
                
                return `
                    <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg border border-gray-200 dark:border-gray-700">
                        <div class="flex justify-between items-start">
                            <div class="flex items-center gap-3">
                                <div class="flex flex-col gap-1">
                                    <label class="text-xs text-gray-500">Captain</label>
                                    <input type="radio" name="captain" value="${player.name}" onchange="setCaptain('${player.name}')" 
                                           class="w-4 h-4 text-blue-600" ${player.isCaptain ? 'checked' : ''}>
                                </div>
                                <div class="flex flex-col gap-1">
                                    <label class="text-xs text-gray-500">WK</label>
                                    <input type="radio" name="wicketkeeper" value="${player.name}" onchange="setWicketKeeper('${player.name}')" 
                                           class="w-4 h-4 text-yellow-600" ${player.isWicketKeeper ? 'checked' : ''}>
                                </div>
                                <div class="flex-1">
                                    <div class="flex items-center gap-2">
                                        <h3 class="font-medium">${player.name}</h3>
                                        ${player.isCaptain ? '<span class="text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-1 rounded">CAPTAIN</span>' : ''}
                                        ${player.isWicketKeeper ? '<span class="text-xs bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 px-1 rounded">WK</span>' : ''}
                                        ${player.isInjured ? '<span class="text-xs bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 px-1 rounded">INJURED</span>' : ''}
                                    </div>
                                    <span class="inline-block text-xs px-2 py-1 rounded ${typeColor} mt-1">${player.type}</span>
                                    ${statsHTML}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('roster-count').textContent = gameState.players.length;
        }

        // Tab switching
        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        }

        // Filter players
        function filterPlayers(type) {
            gameState.currentFilter = type;
            
            // Update filter button styles
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-200', 'dark:bg-gray-700');
            });
            
            event.target.classList.remove('bg-gray-200', 'dark:bg-gray-700');
            event.target.classList.add('bg-blue-500', 'text-white');
            
            displayPlayers();
        }

        // AI Team class
        class AITeam {
            constructor(name, level = 'local') {
                this.name = name;
                this.level = level;
                this.players = this.generateTeamRoster(level);
                this.gamesPlayed = 0;
                this.wins = 0;
                this.losses = 0;
                this.points = 0;
                this.netRunRate = 0;
                this.budget = Math.floor(Math.random() * 30000) + 40000; // 40k-70k budget
                this.isPlayer = false;
                
                // Fan base and income system
                this.fanBase = this.generateInitialFanBase(level);
                this.totalIncome = 0;
                this.winStreak = 0;
                this.lossStreak = 0;
            }
            
            generateInitialFanBase(level) {
                // Generate realistic starting fan bases based on competition level
                switch (level) {
                    case 'local':
                        return Math.floor(Math.random() * 20) + 8; // 8-27 fans
                    case 'national':
                        return Math.floor(Math.random() * 500) + 200; // 200-699 fans
                    case 'worldcup':
                        return Math.floor(Math.random() * 2000) + 1000; // 1000-2999 fans
                    case 'test':
                        return Math.floor(Math.random() * 3000) + 2000; // 2000-4999 fans
                    default:
                        return 15;
                }
            }
            
            generateTeamRoster(level) {
                const roster = [];
                // Generate balanced team: 6 batters, 5 bowlers, 4 all-rounders
                for (let i = 0; i < 6; i++) roster.push(new CricketPlayer('Batter', level));
                for (let i = 0; i < 5; i++) roster.push(new CricketPlayer('Bowler', level));
                for (let i = 0; i < 4; i++) roster.push(new CricketPlayer('All-rounder', level));
                return roster;
            }
            
            selectXI(pitchType) {
                // AI team selects XI using same logic as generateOpponentXI
                const batters = this.players.filter(p => p.type === 'Batter');
                const bowlers = this.players.filter(p => p.type === 'Bowler');
                const allRounders = this.players.filter(p => p.type === 'All-rounder');
                
                // Sort by skill
                batters.sort((a, b) => (b.battingAverage || 0) - (a.battingAverage || 0));
                bowlers.sort((a, b) => (b.totalWickets || 0) - (a.totalWickets || 0));
                allRounders.sort((a, b) => (b.battingAverage + b.totalWickets) - (a.battingAverage + a.totalWickets));
                
                // Build XI with 4-6 bowling options
                const selectedXI = [];
                selectedXI.push(...batters.slice(0, 3)); // Top 3 batters
                selectedXI.push(...allRounders.slice(0, 2)); // Top 2 all-rounders
                selectedXI.push(...bowlers.slice(0, 4)); // Top 4 bowlers
                selectedXI.push(...batters.slice(3, 5)); // Fill remaining with batters
                
                return selectedXI.slice(0, 11);
            }
            
            getTeamStrength() {
                // Calculate overall team strength based on player stats
                let totalStrength = 0;
                this.players.forEach(player => {
                    let playerStrength = 0;
                    if (player.type === 'Batter' || player.type === 'All-rounder') {
                        playerStrength += player.battingAverage + (player.strikeRate / 2);
                    }
                    if (player.type === 'Bowler' || player.type === 'All-rounder') {
                        playerStrength += (player.totalWickets / 2) + (10 - player.economyRate);
                    }
                    totalStrength += playerStrength;
                });
                return totalStrength / this.players.length;
            }
        }

        // Generate AI teams for competition
        function generateAITeams(level) {
            const teamNames = [
                'Thunder Hawks', 'Lightning Bolts', 'Storm Riders', 'Fire Eagles', 'Ice Warriors',
                'Golden Lions', 'Silver Sharks', 'Red Dragons', 'Blue Tigers', 'Green Hornets',
                'Mighty Wolves', 'Royal Knights', 'Wild Cats', 'Speed Demons', 'Power Rangers'
            ];
            
            const teams = [];
            const numTeams = level === 'local' ? 7 : level === 'national' ? 11 : 15; // 8, 12, or 16 teams total
            
            for (let i = 0; i < numTeams; i++) {
                teams.push(new AITeam(teamNames[i], level));
            }
            
            return teams;
        }

        // Competition selection
        function selectCompetition(competition) {
            if (!gameState.competitions[competition].unlocked) return;
            
            gameState.currentCompetition = competition;
            
            // Update UI
            document.querySelectorAll('.competition-btn').forEach(btn => {
                btn.classList.remove('bg-green-500', 'text-white');
                btn.classList.add('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400');
            });
            
            const selectedBtn = document.getElementById(competition + '-btn');
            selectedBtn.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400');
            selectedBtn.classList.add('bg-green-500', 'text-white');
            
            // Update titles
            const competitionNames = {
                local: 'Local Cup',
                national: 'National Cup', 
                worldcup: 'World Cup',
                test: 'Test World Series'
            };
            
            document.getElementById('competition-title').textContent = competitionNames[competition];
            document.getElementById('league-title').textContent = competitionNames[competition] + ' Standings';
            
            // Generate fresh competition
            initializeCompetition(competition);
        }

        // Initialize competition with AI teams
        function initializeCompetition(level) {
            gameState.aiTeams = generateAITeams(level);
            
            // Initialize player's fan base for competition level if needed
            initializePlayerFanBase(level);
            
            // Add player's team to standings
            gameState.leagueStandings = [
                {
                    name: 'Your Team',
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0,
                    points: 0,
                    netRunRate: 0,
                    isPlayer: true
                },
                ...gameState.aiTeams.map(team => ({
                    name: team.name,
                    gamesPlayed: team.gamesPlayed,
                    wins: team.wins,
                    losses: team.losses,
                    points: team.points,
                    netRunRate: team.netRunRate,
                    isPlayer: false
                }))
            ];
            
            gameState.recentResults = [];
            updateStandings();
            updateRecentResults();
        }
        
        // Initialize player fan base based on competition level
        function initializePlayerFanBase(level) {
            // Only adjust fan base when moving to a higher competition, never reduce
            const minFanBaseForLevel = {
                'local': 15,
                'national': 200,
                'worldcup': 1000, 
                'test': 2000
            };
            
            const currentMin = minFanBaseForLevel[level] || 15;
            if (gameState.fanBase < currentMin) {
                gameState.fanBase = currentMin;
            }
        }
        
        // Fan base and income management system
        function calculateFanBaseChange(won, playerScored100) {
            if (won) {
                gameState.winStreak++;
                gameState.lossStreak = 0;
                
                // Win streak bonus: 5% + 1% per additional win + 1% for centuries
                let increase = 5 + Math.max(0, gameState.winStreak - 1);
                if (playerScored100) increase += 1;
                
                const newFans = Math.floor(gameState.fanBase * (increase / 100));
                gameState.fanBase += newFans;
                
                // Apply competition caps
                applyFanBaseCaps();
                
            } else {
                gameState.lossStreak++;
                gameState.winStreak = 0;
                
                // Loss streak penalty: 3% + 1% per additional loss
                const decrease = 3 + Math.max(0, gameState.lossStreak - 1);
                const lostFans = Math.floor(gameState.fanBase * (decrease / 100));
                gameState.fanBase = Math.max(5, gameState.fanBase - lostFans); // Never go below 5 fans
            }
        }
        
        // Apply fan base caps based on competition level
        function applyFanBaseCaps() {
            const level = gameState.currentCompetition;
            
            if (level === 'local') {
                gameState.fanBase = Math.min(gameState.fanBase, 100);
            } else if (level === 'national') {
                // Cap at 2000 with small growth beyond
                if (gameState.fanBase > 2000) {
                    const excess = gameState.fanBase - 2000;
                    const reducedGrowth = Math.floor(excess * 0.1); // 10% of excess growth
                    gameState.fanBase = 2000 + reducedGrowth;
                }
            } else if (level === 'worldcup' || level === 'test') {
                // Diminishing returns after 10000
                if (gameState.fanBase > 10000) {
                    const excess = gameState.fanBase - 10000;
                    const reducedGrowth = Math.floor(excess * 0.2); // 20% of excess growth
                    gameState.fanBase = 10000 + reducedGrowth;
                }
            }
        }
        
        // Calculate match income based on fan bases and home/away split
        function calculateMatchIncome(playerTeam, opponentTeam, isHomeGame) {
            const level = gameState.currentCompetition;
            
            // Fan value per game based on competition level
            const fanValues = {
                'local': 5,
                'national': 15,
                'worldcup': 35,
                'test': 50
            };
            
            const fanValue = fanValues[level] || 5;
            
            // Calculate total attendance (both teams' fans)
            const playerFans = gameState.fanBase;
            const opponentFans = opponentTeam.fanBase || 50; // Fallback if undefined
            const totalAttendance = playerFans + opponentFans;
            
            // Calculate total gate revenue
            const totalRevenue = totalAttendance * fanValue;
            
            // Home team gets 80%, away team gets 20%
            const playerIncome = isHomeGame ? 
                Math.floor(totalRevenue * 0.8) : 
                Math.floor(totalRevenue * 0.2);
                
            const opponentIncome = isHomeGame ?
                Math.floor(totalRevenue * 0.2) :
                Math.floor(totalRevenue * 0.8);
            
            // Update incomes
            gameState.totalIncome += playerIncome;
            if (opponentTeam.totalIncome !== undefined) {
                opponentTeam.totalIncome += opponentIncome;
            }
            
            return {
                playerIncome,
                opponentIncome,
                totalRevenue,
                attendance: totalAttendance
            };
        }
        
        // Update AI team fan bases based on their results
        function updateAITeamFanBases() {
            gameState.aiTeams.forEach(team => {
                // Simple fan base update for AI teams
                if (team.wins > team.losses) {
                    // Winning team gains fans
                    const increase = 2 + Math.floor(Math.random() * 3); // 2-4% increase
                    team.fanBase = Math.floor(team.fanBase * (1 + increase / 100));
                } else if (team.losses > team.wins) {
                    // Losing team loses fans
                    const decrease = 1 + Math.floor(Math.random() * 2); // 1-2% decrease
                    team.fanBase = Math.max(5, Math.floor(team.fanBase * (1 - decrease / 100)));
                }
                
                // Apply same caps as player
                const level = gameState.currentCompetition;
                if (level === 'local') {
                    team.fanBase = Math.min(team.fanBase, 100);
                } else if (level === 'national') {
                    if (team.fanBase > 2000) {
                        const excess = team.fanBase - 2000;
                        const reducedGrowth = Math.floor(excess * 0.1);
                        team.fanBase = 2000 + reducedGrowth;
                    }
                } else if (level === 'worldcup' || level === 'test') {
                    if (team.fanBase > 10000) {
                        const excess = team.fanBase - 10000;
                        const reducedGrowth = Math.floor(excess * 0.2);
                        team.fanBase = 10000 + reducedGrowth;
                    }
                }
            });
        }

        // Update league standings display
        function updateStandings() {
            const standingsList = document.getElementById('standings-list');
            
            // Sort by points, then by net run rate
            const sortedStandings = [...gameState.leagueStandings].sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                return b.netRunRate - a.netRunRate;
            });
            
            standingsList.innerHTML = sortedStandings.map((team, index) => {
                const position = index + 1;
                const bgColor = team.isPlayer ? 'bg-blue-50 dark:bg-blue-900' : 'bg-white dark:bg-gray-800';
                const textColor = team.isPlayer ? 'font-bold text-blue-800 dark:text-blue-200' : '';
                
                return `
                    <div class="grid grid-cols-6 gap-2 p-3 border-b border-gray-200 dark:border-gray-700 ${bgColor}">
                        <div class="${textColor}">${position}. ${team.name}</div>
                        <div class="text-center text-xs">${team.gamesPlayed}</div>
                        <div class="text-center text-xs">${team.wins}</div>
                        <div class="text-center text-xs">${team.losses}</div>
                        <div class="text-center text-xs font-medium">${team.points}</div>
                        <div class="text-center text-xs">${team.netRunRate.toFixed(2)}</div>
                    </div>
                `;
            }).join('');
        }

        // Update recent results display - show only current round's results
        function updateRecentResults() {
            const recentResultsDiv = document.getElementById('recent-results');
            
            if (gameState.recentResults.length === 0) {
                recentResultsDiv.innerHTML = '<p class="text-gray-500 text-sm">No matches played yet</p>';
                return;
            }
            
            // Show only the most recent round's results
            // Calculate how many matches should be in the current round
            const totalTeams = 1 + gameState.aiTeams.length; // Player + AI teams
            const matchesPerRound = Math.floor(totalTeams / 2); // Half the teams play each round
            
            // Get only the last round's matches (most recent results)
            const currentRoundResults = gameState.recentResults.slice(-matchesPerRound);
            
            recentResultsDiv.innerHTML = `
                <div class="mb-2">
                    <h4 class="text-sm font-medium text-gray-600 dark:text-gray-400">Round ${matchState.roundNumber - 1} Results:</h4>
                </div>
            ` + currentRoundResults.map((result, index) => {
                // Format result message with proper cricket format
                const team1Name = result.team1;
                const team2Name = result.team2;
                const winner = result.winner;
                const margin = result.margin;
                
                // Determine loser for proper result format
                const loser = winner === team1Name ? team2Name : team1Name;
                let resultMessage;
                
                if (winner === 'Tie') {
                    resultMessage = 'Match tied';
                } else if (margin.includes('runs')) {
                    resultMessage = `${winner} won by ${margin}`;
                } else {
                    resultMessage = `${winner} won by ${margin}`;
                }
                
                // Show scores in cricket format with space and | separator
                const scoresDisplay = `${team1Name} - ${result.score1}  |  ${team2Name} - ${result.score2}`;
                
                // Use the correct index from the current round results
                const actualResultIndex = gameState.recentResults.length - matchesPerRound + index;
                
                return `
                    <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded border hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer transition-colors" 
                         onclick="showMatchTranscript(${actualResultIndex})">
                        <div class="text-sm font-medium">${resultMessage}</div>
                        <div class="text-xs text-gray-600 dark:text-gray-400 mt-1">
                            ${scoresDisplay}
                        </div>
                        <div class="text-xs text-blue-600 dark:text-blue-400 mt-1">
                            Click to view match transcript ‚Üí
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Show match transcript modal with tabs
        function showMatchTranscript(resultIndex) {
            const result = gameState.recentResults[resultIndex];
            if (!result || !result.transcript) {
                showCustomAlert('Match transcript not available');
                return;
            }
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-6xl w-full max-h-[90vh] overflow-hidden">
                    <div class="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700">
                        <div class="flex items-center">
                            <h3 class="text-lg font-bold mr-6">Match Details</h3>
                            <!-- Tab Navigation -->
                            <div class="flex border-b">
                                <button onclick="showMatchTab('transcript')" id="transcript-tab-btn" 
                                        class="match-tab-btn px-4 py-2 text-sm font-medium border-b-2 border-blue-500 text-blue-600 dark:text-blue-400">
                                    Transcript
                                </button>
                                <button onclick="showMatchTab('scorecard')" id="scorecard-tab-btn" 
                                        class="match-tab-btn px-4 py-2 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                                    Scorecard
                                </button>
                            </div>
                        </div>
                        <button onclick="this.closest('.fixed').remove()" 
                                class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-xl">
                            ‚úï
                        </button>
                    </div>
                    
                    <div class="overflow-y-auto max-h-[calc(90vh-160px)]">
                        <!-- Transcript Tab Content -->
                        <div id="transcript-content" class="match-tab-content p-4">
                            <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded">
                                <p class="font-medium">${result.winner} won by ${result.margin}</p>
                                <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">
                                    ${result.team1} - ${result.score1}  |  ${result.team2} - ${result.score2}
                                </p>
                            </div>
                            <div class="space-y-2">
                                ${result.transcript}
                            </div>
                        </div>
                        
                        <!-- Scorecard Tab Content -->
                        <div id="scorecard-content" class="match-tab-content p-4" style="display: none;">
                            ${generateScorecard(result)}
                        </div>
                    </div>
                    
                    <div class="p-4 border-t border-gray-200 dark:border-gray-700 text-center">
                        <button onclick="this.closest('.fixed').remove()" 
                                class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Show match tab function
        function showMatchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.match-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Remove active styles from all tabs
            document.querySelectorAll('.match-tab-btn').forEach(btn => {
                btn.classList.remove('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
                btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-200');
            });
            
            // Show selected tab content
            document.getElementById(tabName + '-content').style.display = 'block';
            
            // Add active styles to selected tab
            const activeBtn = document.getElementById(tabName + '-tab-btn');
            activeBtn.classList.add('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
            activeBtn.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-200');
        }
        
        // Generate scorecard display
        function generateScorecard(result) {
            // Find the match data from stored result or currentMatch
            let matchData = null;
            
            // First check if match data is stored in the result (for persistence)
            if (result.matchData) {
                matchData = result.matchData;
            }
            // Fallback to current match if it matches
            else if (currentMatch && currentMatch.getMatchResult().team1 === result.team1 && currentMatch.getMatchResult().team2 === result.team2) {
                matchData = currentMatch;
            }
            
            // If we don't have detailed match data, show simplified scorecard
            if (!matchData) {
                return `
                    <div class="text-center text-gray-500 mt-8">
                        <p>Detailed scorecard not available for this match.</p>
                        <p class="text-sm mt-2">Only matches played in the current session have detailed statistics.</p>
                    </div>
                `;
            }
            
            return generateDetailedScorecard(matchData);
        }
        
        // Generate detailed scorecard from match data
        function generateDetailedScorecard(match) {
            let scorecardHTML = '';
            
            // First Innings (Batting First)
            const firstInningsBatters = match.battingFirst === match.team1 ? match.team1Players : match.team2Players;
            const firstInningsFielders = match.battingFirst === match.team1 ? match.team2Players : match.team1Players;
            const firstInningsExtras = match.battingFirst === match.team1 ? match.team1Extras : match.team2Extras;
            const firstInningsScore = match.battingFirst === match.team1 ? match.team1Score : match.team2Score;
            const firstInningsTeamName = match.battingFirst.name || 'Your Team';
            
            scorecardHTML += generateInningsScorecard(firstInningsTeamName, firstInningsBatters, firstInningsFielders, firstInningsExtras, firstInningsScore, true);
            
            // Second Innings (Chasing)
            const secondInningsBatters = match.battingFirst === match.team1 ? match.team2Players : match.team1Players;
            const secondInningsFielders = match.battingFirst === match.team1 ? match.team1Players : match.team2Players;
            const secondInningsExtras = match.battingFirst === match.team1 ? match.team2Extras : match.team1Extras;
            const secondInningsScore = match.battingFirst === match.team1 ? match.team2Score : match.team1Score;
            const secondInningsTeamName = match.battingFirst === match.team1 ? (match.team2.name || 'Your Team') : (match.team1.name || 'Your Team');
            
            scorecardHTML += generateInningsScorecard(secondInningsTeamName, secondInningsBatters, secondInningsFielders, secondInningsExtras, secondInningsScore, false);
            
            return scorecardHTML;
        }
        
        // Generate innings scorecard
        function generateInningsScorecard(teamName, batters, fielders, extras, score, isFirstInnings) {
            let html = `
                <div class="mb-8">
                    <h4 class="text-lg font-bold mb-4 text-blue-600 dark:text-blue-400">${teamName} ${isFirstInnings ? '(1st Innings)' : '(2nd Innings)'}</h4>
                    
                    <!-- Batting Performance -->
                    <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 mb-4 ">
                        <h5 class="font-medium mb-3">Batting</h5>
                        <div class="space-y-1 font-mono text-sm">
            `;
            
            // Display each batsman
            batters.forEach((player, index) => {
                if (player.matchStats.ballsFaced > 0 || player.matchStats.isOut) {
                    const lastName = player.name.split(' ').pop();
                    let dismissalText = '';
                    
                    if (player.matchStats.isOut) {
                        switch (player.matchStats.dismissalType) {
                            case 'bowled':
                                dismissalText = `b. ${player.matchStats.bowlerWhoGotWicket.split(' ').pop()}`;
                                break;
                            case 'caught':
                                const catcherName = player.matchStats.caughtBy ? player.matchStats.caughtBy.split(' ').pop() : 'fielder';
                                dismissalText = `c. ${catcherName} b. ${player.matchStats.bowlerWhoGotWicket.split(' ').pop()}`;
                                break;
                            case 'lbw':
                                dismissalText = `lbw b. ${player.matchStats.bowlerWhoGotWicket.split(' ').pop()}`;
                                break;
                            case 'runout':
                                dismissalText = 'run out';
                                break;
                            case 'stumped':
                                dismissalText = `st. wk b. ${player.matchStats.bowlerWhoGotWicket.split(' ').pop()}`;
                                break;
                        }
                    } else if (player.matchStats.ballsFaced > 0) {
                        dismissalText = 'NOT OUT';
                    }
                    
                    html += `
                        <div class="flex justify-between items-center">
                            <span class="flex-1">${player.name}</span>
                            <span class="flex-1 text-left text-sm text-gray-600 dark:text-gray-400">${dismissalText}</span>
                            <span class="font-bold w-16 text-right">${player.matchStats.runs}</span>
                            <span class="w-16 text-right text-xs text-gray-500">(${player.matchStats.ballsFaced})</span>
                        </div>
                    `;
                }
            });
            
            // Add extras
            if (extras.total > 0) {
                let extrasBreakdown = [];
                if (extras.wides > 0) extrasBreakdown.push(`${extras.wides}w`);
                if (extras.noballs > 0) extrasBreakdown.push(`${extras.noballs}nb`);
                if (extras.legbyes > 0) extrasBreakdown.push(`${extras.legbyes}lb`);
                if (extras.byes > 0) extrasBreakdown.push(`${extras.byes}b`);
                
                html += `
                    <div class="flex justify-between border-t pt-1 mt-2">
                        <span class="flex-1">Extras ${extrasBreakdown.join(', ')}</span>
                        <span class="font-bold w-12 text-right">${extras.total}</span>
                        <span class="w-12"></span>
                    </div>
                `;
            }
            
            // Total score
            html += `
                    <div class="flex justify-between border-t-2 pt-2 mt-2 font-bold">
                        <span class="flex-1">TOTAL</span>
                        <span class="w-12 text-right">${score.runs}/${score.wickets}</span>
                        <span class="w-12 text-right text-xs">(${score.overs}.0 ov)</span>
                    </div>
                </div>
            `;
            
            // Bowling figures
            html += `
                    <!-- Bowling Performance -->
                    <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                        <h5 class="font-medium mb-3">Bowling</h5>
                        <div class="space-y-1 font-mono text-sm">
                            <div class="flex justify-between font-medium text-xs text-gray-500 mb-2">
                                <span class="flex-1">Bowler</span>
                                <span class="w-12 text-center">O</span>
                                <span class="w-12 text-center">R</span>
                                <span class="w-12 text-center">W</span>
                                <span class="w-12 text-center">Econ</span>
                            </div>
            `;
            
            // Display bowling figures for bowlers who bowled
            fielders.forEach(player => {
                if (player.matchStats.ballsBowled > 0) {
                    const lastName = player.name.split(' ').pop();
                    const overs = Math.floor(player.matchStats.ballsBowled / 6);
                    const balls = player.matchStats.ballsBowled % 6;
                    const oversDisplay = balls > 0 ? `${overs}.${balls}` : `${overs}`;
                    const economy = overs > 0 ? (player.matchStats.runsConceded / overs).toFixed(1) : '0.0';
                    
                    html += `
                        <div class="flex justify-between">
                            <span class="flex-1">${lastName}</span>
                            <span class="w-12 text-center">${oversDisplay}</span>
                            <span class="w-12 text-center">${player.matchStats.runsConceded}</span>
                            <span class="w-12 text-center">${player.matchStats.wicketsTaken}</span>
                            <span class="w-12 text-center">${economy}</span>
                        </div>
                    `;
                }
            });
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }

        // Simulate match between two teams (basic version)
        function simulateMatch(team1, team2) {
            // Simple simulation - will be expanded with proper cricket mechanics
            const team1Strength = team1.getTeamStrength ? team1.getTeamStrength() : 50;
            const team2Strength = team2.getTeamStrength ? team2.getTeamStrength() : 50;
            
            const team1Score = Math.floor(Math.random() * 100) + team1Strength + 120;
            const team2Score = Math.floor(Math.random() * 100) + team2Strength + 120;
            
            const winner = team1Score > team2Score ? team1 : team2;
            const loser = winner === team1 ? team2 : team1;
            const margin = Math.abs(team1Score - team2Score);
            
            return {
                team1: team1.name,
                team2: team2.name,
                score1: team1Score,
                score2: team2Score,
                winner: winner.name,
                margin: `${margin} runs`
            };
        }

        // Match day state
        const matchState = {
            opponent: null,
            isHomeGame: true,
            pitchType: 'Fast Pitch',
            weather: 'Sunny & Clear',
            selectedXI: [],
            opponentXI: [],
            roundNumber: 1
        };

        // Set captain
        function setCaptain(playerName) {
            gameState.players.forEach(player => {
                player.isCaptain = player.name === playerName;
            });
            displayPlayers();
            updatePlayerSelector();
        }

        // Set wicket keeper
        function setWicketKeeper(playerName) {
            gameState.players.forEach(player => {
                player.isWicketKeeper = player.name === playerName;
            });
            displayPlayers();
            updatePlayerSelector();
        }

        // Schedule next match automatically (no user control)
        function scheduleNextMatch() {
            // Use the same round-robin logic as the season schedule
            const allTeams = [gameState.teamName, ...gameState.aiTeams.map(t => t.name)];
            const roundMatches = generateRoundMatches(allTeams, matchState.roundNumber);
            
            // Find the player's match for this round
            const playerMatch = roundMatches.find(match => 
                match.team1 === gameState.teamName || match.team2 === gameState.teamName
            );
            
            if (playerMatch) {
                // Determine opponent and home/away
                const opponentName = playerMatch.team1 === gameState.teamName ? playerMatch.team2 : playerMatch.team1;
                matchState.opponent = gameState.aiTeams.find(team => team.name === opponentName);
                matchState.isHomeGame = playerMatch.team1 === gameState.teamName;
            } else {
                // Fallback if no match found (shouldn't happen with proper round-robin)
                const teamIndex = (matchState.roundNumber - 1) % gameState.aiTeams.length;
                matchState.opponent = gameState.aiTeams[teamIndex];
                matchState.isHomeGame = matchState.roundNumber <= gameState.aiTeams.length;
            }
            
            // Random pitch conditions
            const pitchTypes = ['Fast Pitch', 'Slow Pitch', 'Bouncy Pitch', 'Spinning Pitch', 'Green Pitch'];
            matchState.pitchType = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];
            
            // Random weather conditions - cricket is summer sport, rain is rare
            const weatherConditions = [
                { condition: 'Sunny & Clear', risk: 'none', effect: 'Perfect playing conditions', weight: 40 },
                { condition: 'Partly Cloudy', risk: 'none', effect: 'Good for all players', weight: 25 },
                { condition: 'Overcast', risk: 'none', effect: 'Favors swing bowlers', weight: 20 },
                { condition: 'Hot & Humid', risk: 'injury', effect: 'Swing bowling conditions, injury risk', weight: 12 },
                { condition: 'Threatening Rain', risk: 'rain', effect: 'Match may be interrupted', weight: 2 },
                { condition: 'Light Drizzle', risk: 'cancellation', effect: 'High chance of cancellation', weight: 1 }
            ];
            
            // Weighted random selection for weather - cricket is summer sport, rain is rare
            const totalWeight = weatherConditions.reduce((sum, weather) => sum + weather.weight, 0);
            let randomWeight = Math.random() * totalWeight;
            let selectedWeather = weatherConditions[0];
            
            for (const weather of weatherConditions) {
                randomWeight -= weather.weight;
                if (randomWeight <= 0) {
                    selectedWeather = weather;
                    break;
                }
            }
            
            matchState.weather = selectedWeather.condition;
            
            // Update UI
            updateMatchDayReport();
            generateOpponentXI();
        }

        // Simulate detailed match with player stat updates
        function simulateDetailedMatch(team1, team2, pitchType, weather, isHomeGame = false) {
            // Enhanced match simulation that updates individual player stats
            const team1Players = team1.isPlayer ? 
                matchState.selectedXI.map(name => gameState.players.find(p => p.name === name)) :
                team1.selectXI(pitchType);
            
            const team2Players = team2.isPlayer ? 
                matchState.selectedXI.map(name => gameState.players.find(p => p.name === name)) :
                team2.selectXI(pitchType);
            
            // Calculate team strengths with conditions
            let team1Strength = calculateTeamStrength(team1Players, pitchType, weather, isHomeGame);
            let team2Strength = calculateTeamStrength(team2Players, pitchType, weather, false);
            
            // Simulate scores
            const team1Score = Math.floor(Math.random() * 100) + team1Strength + 120;
            const team2Score = Math.floor(Math.random() * 100) + team2Strength + 120;
            
            const winner = team1Score > team2Score ? team1 : team2;
            const margin = Math.abs(team1Score - team2Score);
            
            // Update player statistics for both teams
            updatePlayerStatsAfterMatch(team1Players, team1Score, team1Score > team2Score);
            updatePlayerStatsAfterMatch(team2Players, team2Score, team2Score > team1Score);
            
            return {
                team1: team1.name || 'Your Team',
                team2: team2.name || 'Your Team', 
                score1: team1Score,
                score2: team2Score,
                winner: winner.name || 'Your Team',
                margin: `${margin} runs`
            };
        }

        // Calculate team strength with conditions
        function calculateTeamStrength(players, pitchType, weather, isHomeGame) {
            let strength = 0;
            players.forEach(player => {
                let playerStrength = player.battingAverage + (player.strikeRate / 3);
                
                if (player.type === 'Bowler' || player.type === 'All-rounder') {
                    playerStrength += (player.totalWickets / 2) + (10 - player.economyRate) * 2;
                }
                
                // Apply pitch conditions
                if (player.hiddenTraits.includes(`${pitchType.split(' ')[0]} Pitch Specialist`)) {
                    playerStrength *= 1.15; // 15% boost for specialists
                }
                
                // Apply weather conditions
                if (weather === 'Overcast' && player.bowlingType === 'Swing') {
                    playerStrength *= 1.1;
                }
                
                // Home advantage
                if (isHomeGame) {
                    playerStrength *= 1.05;
                }
                
                strength += playerStrength;
            });
            
            return strength / players.length;
        }

        // Update individual player statistics after match
        function updatePlayerStatsAfterMatch(players, teamScore, won) {
            players.forEach((player, index) => {
                // Update games played
                player.gamesPlayed++;
                
                // Simulate individual performance based on team score and position
                const battingOrder = index + 1;
                const expectedRuns = Math.floor(teamScore / 11) + Math.random() * 20 - 10;
                const actualRuns = Math.max(0, Math.floor(expectedRuns * (0.7 + Math.random() * 0.6)));
                
                // Update batting stats
                player.totalRuns += actualRuns;
                player.battingAverage = Math.floor(player.totalRuns / player.gamesPlayed);
                
                // Update high score occasionally
                if (actualRuns > player.highScore && Math.random() < 0.05) {
                    player.highScore = actualRuns;
                }
                
                // Update 50s and 100s
                if (actualRuns >= 50) player.fifties++;
                if (actualRuns >= 100) player.hundreds++;
                
                // Update bowling stats for bowlers
                if (player.type === 'Bowler' || player.type === 'All-rounder') {
                    const wicketsTaken = Math.floor(Math.random() * 4); // 0-3 wickets
                    player.totalWickets += wicketsTaken;
                    
                    // Update best bowling occasionally
                    if (wicketsTaken >= 3 && Math.random() < 0.2) {
                        const runsGiven = Math.floor(wicketsTaken * player.economyRate * 6 * 0.8);
                        player.bestBowling = `${wicketsTaken}/${runsGiven}`;
                    }
                    
                    // Update 5-wicket hauls
                    if (wicketsTaken >= 5) player.fiveWicketHauls++;
                }
            });
        }

        // Process full round of matches for entire league - FIXED TO FOLLOW SCHEDULE
        function processLeagueRound() {
            const roundResults = [];
            
            // Get ALL matches for this round using the same logic as the schedule
            const allTeams = [gameState.teamName, ...gameState.aiTeams.map(t => t.name)];
            const allRoundMatches = generateRoundMatches(allTeams, matchState.roundNumber);
            
            // Debug: Log the matches to see what's happening
            console.log(`Round ${matchState.roundNumber} - All matches:`, allRoundMatches);
            
            // Filter out the player's match (already played) and simulate the remaining AI vs AI matches
            const aiMatches = allRoundMatches.filter(match => 
                match.team1 !== gameState.teamName && match.team2 !== gameState.teamName
            );
            
            // Debug: Log AI matches
            console.log(`Round ${matchState.roundNumber} - AI matches only:`, aiMatches);
            
            // Simulate each AI vs AI match for this round
            aiMatches.forEach(match => {
                const team1 = gameState.aiTeams.find(t => t.name === match.team1);
                const team2 = gameState.aiTeams.find(t => t.name === match.team2);
                
                if (team1 && team2) {
                    // Random pitch and weather for each match
                    const pitchTypes = ['Fast Pitch', 'Slow Pitch', 'Bouncy Pitch', 'Spinning Pitch', 'Green Pitch'];
                    const randomPitch = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];
                    const weatherTypes = ['Sunny & Clear', 'Partly Cloudy', 'Overcast', 'Hot & Humid'];
                    const randomWeather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                    
                    const result = simulateDetailedMatch(team1, team2, randomPitch, randomWeather);
                    roundResults.push(result);
                    
                    // Update team records
                    if (result.winner === team1.name) {
                        team1.wins++;
                        team1.points += 2;
                        team2.losses++;
                    } else if (result.winner === team2.name) {
                        team2.wins++;
                        team2.points += 2;
                        team1.losses++;
                    } else {
                        // Handle ties
                        team1.points += 1;
                        team2.points += 1;
                    }
                    
                    team1.gamesPlayed++;
                    team2.gamesPlayed++;
                    
                    // Update net run rate (simplified)
                    team1.netRunRate = (team1.wins - team1.losses) + Math.random() * 2 - 1;
                    team2.netRunRate = (team2.wins - team2.losses) + Math.random() * 2 - 1;
                }
            });
            
            // Debug: Log how many AI results we're adding
            console.log(`Round ${matchState.roundNumber} - Adding ${roundResults.length} AI match results`);
            console.log(`Round ${matchState.roundNumber} - Total results before adding AI matches: ${gameState.recentResults.length}`);
            
            // Add all results to recent results
            gameState.recentResults.push(...roundResults);
            
            console.log(`Round ${matchState.roundNumber} - Total results after adding AI matches: ${gameState.recentResults.length}`);
            
            // Update league standings for AI teams
            gameState.leagueStandings = gameState.leagueStandings.map(standing => {
                if (!standing.isPlayer) {
                    const team = gameState.aiTeams.find(t => t.name === standing.name);
                    if (team) {
                        return {
                            ...standing,
                            gamesPlayed: team.gamesPlayed,
                            wins: team.wins,
                            losses: team.losses,
                            points: team.points,
                            netRunRate: team.netRunRate
                        };
                    }
                }
                return standing;
            });
        }

        // Generate round-robin matches for a specific round
        function generateRoundRobinMatches(teams, roundNumber) {
            const matches = [];
            const numTeams = teams.length;
            
            // If odd number of teams, one team gets a bye each round
            if (numTeams % 2 === 1) {
                // For simplicity, just pair teams that are available
                // In a real round-robin with byes, we'd track which team sits out
                const availableTeams = teams.slice(0, numTeams - 1);
                
                for (let i = 0; i < availableTeams.length; i += 2) {
                    if (i + 1 < availableTeams.length) {
                        // Rotate pairings based on round number
                        const team1Index = (i + roundNumber - 1) % availableTeams.length;
                        const team2Index = (i + 1 + roundNumber - 1) % availableTeams.length;
                        
                        if (team1Index !== team2Index) {
                            matches.push({
                                home: availableTeams[team1Index],
                                away: availableTeams[team2Index]
                            });
                        }
                    }
                }
            } else {
                // Even number of teams - everyone plays
                for (let i = 0; i < numTeams / 2; i++) {
                    // Round-robin rotation algorithm
                    let team1Index = i;
                    let team2Index = (numTeams - 1 - i + roundNumber - 1) % numTeams;
                    
                    // Ensure we don't pair a team with itself
                    if (team1Index === team2Index) {
                        team2Index = (team2Index + 1) % numTeams;
                    }
                    
                    // Make sure indices are different and valid
                    if (team1Index !== team2Index && team1Index < numTeams && team2Index < numTeams) {
                        matches.push({
                            home: teams[team1Index],
                            away: teams[team2Index]
                        });
                    }
                }
            }
            
            return matches;
        }

        // Update match day report display
        function updateMatchDayReport() {
            document.getElementById('opponent-name').textContent = matchState.opponent.name;
            document.getElementById('opponent-team-name').textContent = matchState.opponent.name;
            document.getElementById('home-away').textContent = matchState.isHomeGame ? 'Home Match' : 'Away Match';
            document.getElementById('pitch-type').textContent = matchState.pitchType;
            document.getElementById('weather-conditions').textContent = matchState.weather;
            
            // Update advantages/effects
            const homeAdvantage = document.getElementById('home-advantage');
            if (matchState.isHomeGame) {
                homeAdvantage.textContent = 'üè† Home crowd advantage: +5% motivation boost';
                homeAdvantage.className = 'text-sm text-green-600 dark:text-green-400 text-xs mt-1';
            } else {
                homeAdvantage.textContent = '‚úàÔ∏è Away match: -3% motivation, +2% experience';
                homeAdvantage.className = 'text-sm text-orange-600 dark:text-orange-400 text-xs mt-1';
            }
            
            // Update pitch effects
            const conditionsEffect = document.getElementById('conditions-effect');
            const pitchEffects = {
                'Fast Pitch': '‚ö° Favors fast bowlers and power hitters',
                'Slow Pitch': 'üêå Favors spin bowlers and patient batters',
                'Bouncy Pitch': 'üèÄ Favors tall bowlers and pull shots',
                'Spinning Pitch': 'üå™Ô∏è Heavily favors spin bowlers',
                'Green Pitch': 'üå± Favors seam and swing bowlers'
            };
            
            conditionsEffect.textContent = pitchEffects[matchState.pitchType] || 'Standard playing conditions';
        }

        // Generate opponent XI with strategic bowling composition based on pitch
        function generateOpponentXI() {
            // Separate players by type
            const batters = matchState.opponent.players.filter(p => p.type === 'Batter');
            const bowlers = matchState.opponent.players.filter(p => p.type === 'Bowler');
            const allRounders = matchState.opponent.players.filter(p => p.type === 'All-rounder');
            
            // Sort batters by batting average (best first)
            batters.sort((a, b) => (b.battingAverage || 0) - (a.battingAverage || 0));
            
            // Strategic bowling selection based on pitch conditions
            const pitchBowlingPreference = {
                'Fast Pitch': ['Fast', 'Medium'],
                'Slow Pitch': ['Off-spin', 'Leg-spin', 'Medium'],
                'Bouncy Pitch': ['Fast', 'Medium'],
                'Spinning Pitch': ['Off-spin', 'Leg-spin'],
                'Green Pitch': ['Swing', 'Medium', 'Fast']
            };
            
            const preferredBowlingTypes = pitchBowlingPreference[matchState.pitchType] || ['Fast', 'Medium', 'Off-spin'];
            
            // Score bowlers and all-rounders based on pitch suitability
            const scoreBowler = (player) => {
                let score = (player.totalWickets || 0) - (player.economyRate || 10);
                // Bonus for preferred bowling types on this pitch
                if (preferredBowlingTypes.includes(player.bowlingType)) {
                    score += 20;
                }
                return score;
            };
            
            // Sort bowlers by pitch suitability and skill
            bowlers.sort((a, b) => scoreBowler(b) - scoreBowler(a));
            
            // Sort all-rounders by combined value (batting + bowling + pitch suitability)
            allRounders.sort((a, b) => {
                const aStrength = (a.battingAverage || 0) + scoreBowler(a);
                const bStrength = (b.battingAverage || 0) + scoreBowler(b);
                return bStrength - aStrength;
            });
            
            // Build XI strategically: minimum 4 bowlers, maximum 6
            const selectedXI = [];
            const bowlingCapableCount = (player) => player.type === 'Bowler' || player.type === 'All-rounder';
            
            // Always select best 3 batters for top order
            selectedXI.push(...batters.slice(0, 3));
            
            // Select 1-2 best all-rounders for middle order
            selectedXI.push(...allRounders.slice(0, 2));
            
            // Count current bowlers
            let bowlerCount = selectedXI.filter(bowlingCapableCount).length;
            
            // Add remaining players to reach 11, ensuring 4-6 bowlers
            const remainingSlots = 11 - selectedXI.length;
            const remainingPlayers = [
                ...batters.slice(3),
                ...allRounders.slice(2),
                ...bowlers
            ].sort((a, b) => {
                // Prioritize bowlers if we need more
                if (bowlerCount < 4) {
                    if (bowlingCapableCount(a) && !bowlingCapableCount(b)) return -1;
                    if (!bowlingCapableCount(a) && bowlingCapableCount(b)) return 1;
                }
                // Otherwise select by overall strength
                const aStrength = (a.battingAverage || 0) + scoreBowler(a);
                const bStrength = (b.battingAverage || 0) + scoreBowler(b);
                return bStrength - aStrength;
            });
            
            // Fill remaining slots
            for (let i = 0; i < remainingSlots && i < remainingPlayers.length; i++) {
                const player = remainingPlayers[i];
                selectedXI.push(player);
                if (bowlingCapableCount(player)) {
                    bowlerCount++;
                }
                // Don't exceed 6 bowlers
                if (bowlerCount >= 6 && remainingSlots - i > 1) {
                    // Fill remaining with best available batters
                    const remainingBatters = remainingPlayers.slice(i + 1).filter(p => !bowlingCapableCount(p));
                    selectedXI.push(...remainingBatters.slice(0, remainingSlots - i - 1));
                    break;
                }
            }
            
            // Ensure exactly 11 players
            matchState.opponentXI = selectedXI.slice(0, 11);
            
            // Reorder for proper batting order: batters first, all-rounders middle, bowlers last
            const finalXI = [];
            const xiByType = {
                batters: matchState.opponentXI.filter(p => p.type === 'Batter'),
                allRounders: matchState.opponentXI.filter(p => p.type === 'All-rounder'),
                bowlers: matchState.opponentXI.filter(p => p.type === 'Bowler')
            };
            
            // Build batting order: batters (1-6), all-rounders (7-9), bowlers (10-11)
            finalXI.push(...xiByType.batters);
            finalXI.push(...xiByType.allRounders);
            finalXI.push(...xiByType.bowlers);
            
            matchState.opponentXI = finalXI;
            
            // Select captain (usually top batter or experienced all-rounder)
            const captain = matchState.opponentXI[0] || matchState.opponentXI.find(p => p.type === 'All-rounder');
            if (captain) captain.isCaptain = true;
            
            // Select wicket keeper (prefer designated WK, otherwise middle-order player)
            let wicketKeeper = matchState.opponentXI.find(p => p.isWicketKeeper);
            if (!wicketKeeper) {
                // Select from middle order (positions 4-7)
                wicketKeeper = matchState.opponentXI.slice(3, 7).find(p => p.type === 'All-rounder') || matchState.opponentXI[4];
                if (wicketKeeper) wicketKeeper.isWicketKeeper = true;
            }
            
            displayOpponentXI();
        }

        // Display opponent XI
        function displayOpponentXI() {
            const opponentXIDiv = document.getElementById('opponent-team-xi');
            
            opponentXIDiv.innerHTML = matchState.opponentXI.map((player, index) => {
                const battingStats = (player.type === 'Batter' || player.type === 'All-rounder') 
                    ? `Runs: ${player.totalRuns} | Avg: ${player.battingAverage} | S/R: ${player.strikeRate}`
                    : `${player.bowlingType} | Best: ${player.bestBowling} | Econ: ${player.economyRate.toFixed(1)}`;
                
                let playerRole = '';
                if (player.isCaptain) playerRole += ' (C)';
                if (player.isWicketKeeper) playerRole += ' (WK)';
                
                return `
                    <div class="text-sm p-2 bg-white dark:bg-gray-700 rounded border">
                        <div class="font-medium">${index + 1}. ${player.name}${playerRole}</div>
                        <div class="text-xs text-gray-600 dark:text-gray-400">${battingStats}</div>
                    </div>
                `;
            }).join('');
        }

        // Update player selector for XI selection
        function updatePlayerSelector() {
            const selector = document.getElementById('player-selector');
            
            // Auto-add captain to XI if not already selected
            const captain = gameState.players.find(p => p.isCaptain);
            if (captain && !matchState.selectedXI.includes(captain.name) && matchState.selectedXI.length < 11) {
                matchState.selectedXI.push(captain.name);
                displayYourXI();
            }
            
            // Filter available players - exclude injured, already selected, AND the captain
            const availablePlayers = gameState.players.filter(p => 
                !p.isInjured && 
                !matchState.selectedXI.includes(p.name) &&
                !p.isCaptain  // Remove captain from dropdown since they're auto-added
            );
            
            selector.innerHTML = '<option value="">Choose a player...</option>' +
                availablePlayers.map(player => {
                    let playerStats = '';
                    if (player.type === 'Batter') {
                        playerStats = `HS: ${player.highScore} | Avg: ${player.battingAverage} | S/R: ${player.strikeRate}`;
                    } else if (player.type === 'Bowler') {
                        playerStats = `${player.bowlingType} | Best: ${player.bestBowling} | Econ: ${player.economyRate.toFixed(1)} | Wkts: ${player.totalWickets}`;
                    } else if (player.type === 'All-rounder') {
                        playerStats = `Avg: ${player.battingAverage} | Best: ${player.bestBowling} | ${player.bowlingType}`;
                    }
                    
                    // Add (WK) tag for wicket keepers in dropdown
                    const playerDisplayName = player.isWicketKeeper ? `${player.name} (WK)` : player.name;
                    
                    return `<option value="${player.name}">${playerDisplayName} - ${playerStats}</option>`;
                }).join('');
        }

        // Select player for XI
        function selectPlayerForXI() {
            const selector = document.getElementById('player-selector');
            const playerName = selector.value;
            
            if (playerName && matchState.selectedXI.length < 11) {
                matchState.selectedXI.push(playerName);
                displayYourXI();
                updatePlayerSelector();
                selector.value = '';
            }
        }

        // Display your XI
        function displayYourXI() {
            const yourXIDiv = document.getElementById('your-team-xi');
            
            if (matchState.selectedXI.length === 0) {
                yourXIDiv.innerHTML = '<p class="text-gray-500 text-sm">No players selected</p>';
                return;
            }
            
            yourXIDiv.innerHTML = matchState.selectedXI.map((playerName, index) => {
                const player = gameState.players.find(p => p.name === playerName);
                const battingStats = (player.type === 'Batter' || player.type === 'All-rounder') 
                    ? `HS: ${player.highScore} | Avg: ${player.battingAverage} | S/R: ${player.strikeRate}`
                    : `${player.bowlingType} | Best: ${player.bestBowling} | Econ: ${player.economyRate.toFixed(1)}`;
                
                let playerRole = '';
                if (player.isCaptain) playerRole += ' (C)';
                if (player.isWicketKeeper) playerRole += ' (WK)';
                
                return `
                    <div class="text-sm p-2 bg-white dark:bg-gray-700 rounded border flex justify-between items-center">
                        <div>
                            <div class="font-medium">${index + 1}. ${player.name}${playerRole}</div>
                            <div class="text-xs text-gray-600 dark:text-gray-400">${battingStats}</div>
                        </div>
                        <button onclick="removeFromXI('${playerName}')" class="text-red-500 hover:text-red-700 text-xs">Remove</button>
                    </div>
                `;
            }).join('');
        }

        // Remove player from XI
        function removeFromXI(playerName) {
            matchState.selectedXI = matchState.selectedXI.filter(name => name !== playerName);
            displayYourXI();
            updatePlayerSelector();
        }

        // Start match
        function startMatch() {
            if (matchState.selectedXI.length !== 11) {
                showCustomAlert('Please select exactly 11 players for your team!');
                return;
            }
            
            if (!gameState.players.some(p => p.isCaptain)) {
                showCustomAlert('Please select a team captain from the Roster tab!');
                return;
            }
            
            // Show live match details
            document.getElementById('live-match-details').style.display = 'block';
            
            // Start match simulation
            simulateMatchPlay();
        }

        // Cricket match simulation system
        let currentMatch = null;
        let matchInterval = null;

        class CricketMatch {
            constructor(team1, team2, pitchType, weather, isHomeGame) {
                this.team1 = team1;
                this.team2 = team2;
                this.pitchType = pitchType;
                this.weather = weather;
                this.isHomeGame = isHomeGame;
                
                // Get playing XIs
                this.team1Players = team1.isPlayer ? 
                    matchState.selectedXI.map(name => gameState.players.find(p => p.name === name)) :
                    team1.selectXI(pitchType);
                this.team2Players = team2.isPlayer ? 
                    matchState.selectedXI.map(name => gameState.players.find(p => p.name === name)) :
                    team2.selectXI(pitchType);
                
                // Initialize match stats
                this.tossWinner = Math.random() < 0.5 ? team1 : team2;
                this.battingFirst = this.decideBattingFirst();
                this.fieldingFirst = this.battingFirst === team1 ? team2 : team1;
                
                this.innings = 1;
                this.currentOver = 1;
                this.currentBall = 1;
                this.totalOvers = 50;
                this.powerplayOvers = 10;
                
                this.team1Score = { runs: 0, wickets: 0, overs: 0, balls: 0 };
                this.team2Score = { runs: 0, wickets: 0, overs: 0, balls: 0 };
                this.currentScore = this.battingFirst === team1 ? this.team1Score : this.team2Score;
                
                // Current partnership
                this.striker = 0; // Index in batting order
                this.nonStriker = 1;
                this.currentBowler = null;
                this.bowlerEnd = 'A'; // A or B end
                this.previousBowler = null;
                this.bowlerOverCount = 0;
                
                // Initialize batting and bowling stats for this match
                this.initializeMatchStats();
                
                // Weather interruption chance
                this.rainDelay = false;
                this.oversReduced = 50;
                
                this.overHistory = [];
                this.commentary = [];
            }
            
            decideBattingFirst() {
                const strategy = document.getElementById('toss-strategy').value;
                const tossChoice = strategy === 'captain-choice' ? (Math.random() < 0.5) :
                                 strategy === 'bat-first' ? true :
                                 strategy === 'field-first' ? false :
                                 Math.random() < 0.5;
                
                return (this.tossWinner === this.team1) === tossChoice ? this.team1 : this.team2;
            }
            
            initializeMatchStats() {
                // Initialize match-specific stats for all players
                [...this.team1Players, ...this.team2Players].forEach(player => {
                    player.matchStats = {
                        runs: 0,
                        ballsFaced: 0,
                        fours: 0,
                        sixes: 0,
                        strikeRate: 0,
                        runsConceded: 0,
                        oversBowled: 0,
                        ballsBowled: 0,
                        wicketsTaken: 0,
                        economyRate: 0,
                        // Additional detailed tracking
                        dismissalType: null, // 'bowled', 'caught', 'lbw', 'runout', 'stumped'
                        caughtBy: null,
                        bowlerWhoGotWicket: null,
                        isOut: false,
                        wicketsOfBowler: [] // Array of {batsman, dismissalType, caughtBy}
                    };
                });
                
                // Initialize extras tracking
                this.team1Extras = { wides: 0, noballs: 0, byes: 0, legbyes: 0, total: 0 };
                this.team2Extras = { wides: 0, noballs: 0, byes: 0, legbyes: 0, total: 0 };
            }
            
            getCurrentBattingTeam() {
                return this.innings === 1 ? this.battingFirst : this.fieldingFirst;
            }
            
            getCurrentFieldingTeam() {
                return this.innings === 1 ? this.fieldingFirst : this.battingFirst;
            }
            
            getCurrentBattingOrder() {
                return this.getCurrentBattingTeam() === this.team1 ? this.team1Players : this.team2Players;
            }
            
            getCurrentBowlingTeam() {
                return this.getCurrentFieldingTeam() === this.team1 ? this.team1Players : this.team2Players;
            }
            
            simulateOver() {
                const battingTeam = this.getCurrentBattingOrder();
                const bowlingTeam = this.getCurrentBowlingTeam();
                
                // Select bowler for this over - must change if hitting 10-over limit or other conditions
                if (this.currentOver === 1 || this.shouldChangeBowler()) {
                    this.selectNewBowler(bowlingTeam);
                }
                
                let overRuns = 0;
                let overBalls = [];
                let overWickets = 0;
                let extraBalls = 0;
                
                // Check for weather interruption
                if (this.checkWeatherInterruption()) {
                    return this.handleWeatherInterruption();
                }
                
                // Simulate 6 balls (plus extras)
                for (let ball = 1; ball <= 6 + extraBalls; ball++) {
                    if (this.currentScore.wickets >= 10) break;
                    
                    const result = this.simulateBall(battingTeam, bowlingTeam);
                    overBalls.push(result.display);
                    overRuns += result.runs;
                    
                    if (result.wicket) overWickets++;
                    if (result.extra) extraBalls++;
                    
                    // Handle batting rotation
                    if (!result.extra && result.runs % 2 === 1) {
                        [this.striker, this.nonStriker] = [this.nonStriker, this.striker];
                    }
                }
                
                // End of over - rotate strike
                [this.striker, this.nonStriker] = [this.nonStriker, this.striker];
                
                // Update over count and bowler stats
                this.currentScore.overs++;
                this.bowlerOverCount++;
                this.bowlerEnd = this.bowlerEnd === 'A' ? 'B' : 'A';
                
                // CRITICAL: Update total overs bowled for this bowler (cumulative across match)
                this.currentBowler.matchStats.oversBowled++;
                
                // Create over summary
                const overSummary = {
                    number: this.currentOver,
                    balls: overBalls.join(' '),
                    runs: overRuns,
                    wickets: overWickets,
                    bowler: this.currentBowler.name,
                    commentary: this.generateOverCommentary(overBalls, overRuns, overWickets)
                };
                
                this.overHistory.push(overSummary);
                this.currentOver++;
                
                return overSummary;
            }
            
            simulateBall(battingTeam, bowlingTeam) {
                const striker = battingTeam[this.striker];
                const bowler = this.currentBowler;
                
                // Calculate realistic base probabilities (totaling ~1.0)
                let dotProb = 0.45;        // 45% - most common outcome
                let singleProb = 0.30;     // 30% - primary scoring method
                let doubleProb = 0.12;     // 12% - good running
                let tripleProb = 0.02;     // 2% - rare, good running
                let fourProb = 0.06;       // 6% - boundary hitting
                let sixProb = 0.02;        // 2% - aggressive hitting
                let wicketProb = 0.025;    // 2.5% - realistic wicket rate for 50 overs
                let wideProb = 0.015;      // 1.5% - bowling error
                let noBallProb = 0.005;    // 0.5% - rare bowling error
                let byeProb = 0.01;        // 1% - fielding/keeping error
                
                // Player skill factors
                const strikerSkill = this.calculateBattingSkill(striker);
                let bowlerSkill = this.calculateBowlingSkill(bowler);
                
                // Non-bowlers are less economical (captain has no choice situation)
                if (bowler.matchStats.emergencyBowler) {
                    bowlerSkill *= 0.6; // 40% reduction in bowling skill for non-bowlers
                }
                
                // Match situation factors
                const situationFactor = this.calculateSituationFactor();
                const powerplayFactor = this.currentOver <= this.powerplayOvers ? 1.2 : 1.0;
                
                // Adjust probabilities based on player skills and situation
                const skillDifferential = strikerSkill - bowlerSkill; // -1 to +1 range
                
                // Better batters: fewer dots, more scoring shots, fewer wickets
                if (skillDifferential > 0) {
                    const advantage = skillDifferential * 0.3; // Max 30% adjustment
                    dotProb *= (1 - advantage * 0.4);
                    singleProb *= (1 + advantage * 0.3);
                    doubleProb *= (1 + advantage * 0.4);
                    fourProb *= (1 + advantage * 0.5);
                    sixProb *= (1 + advantage * 0.6);
                    wicketProb *= (1 - advantage * 0.6);
                }
                // Better bowlers: more dots, fewer scoring shots, more wickets
                else if (skillDifferential < 0) {
                    const advantage = Math.abs(skillDifferential) * 0.3;
                    dotProb *= (1 + advantage * 0.3);
                    singleProb *= (1 - advantage * 0.2);
                    doubleProb *= (1 - advantage * 0.3);
                    fourProb *= (1 - advantage * 0.4);
                    sixProb *= (1 - advantage * 0.5);
                    wicketProb *= (1 + advantage * 0.4);
                }
                
                // Powerplay adjustments (field restrictions)
                if (this.currentOver <= this.powerplayOvers) {
                    fourProb *= 1.3;
                    sixProb *= 1.4;
                    dotProb *= 0.9;
                    singleProb *= 1.1;
                }
                
                // Late innings pressure (last 10 overs)
                if (this.currentOver > 40) {
                    fourProb *= 1.2;
                    sixProb *= 1.3;
                    wicketProb *= 1.1;
                    dotProb *= 0.95;
                }
                
                // Normalize probabilities to ensure they sum to ~1
                const totalProb = dotProb + singleProb + doubleProb + tripleProb + fourProb + sixProb + wicketProb + wideProb + noBallProb + byeProb;
                const normalizeFactor = 1.0 / totalProb;
                
                dotProb *= normalizeFactor;
                singleProb *= normalizeFactor;
                doubleProb *= normalizeFactor;
                tripleProb *= normalizeFactor;
                fourProb *= normalizeFactor;
                sixProb *= normalizeFactor;
                wicketProb *= normalizeFactor;
                wideProb *= normalizeFactor;
                noBallProb *= normalizeFactor;
                byeProb *= normalizeFactor;
                
                // Generate outcome using cumulative probabilities
                const rand = Math.random();
                let cumulative = 0;
                let result = { runs: 0, wicket: false, extra: false, display: '.' };
                
                cumulative += wicketProb;
                if (rand < cumulative) {
                    result = { runs: 0, wicket: true, extra: false, display: 'X' };
                    this.handleWicket(striker, bowler);
                    
                } else {
                    cumulative += wideProb;
                    if (rand < cumulative) {
                        const wideRuns = Math.random() < 0.8 ? 1 : (1 + Math.floor(Math.random() * 2));
                        result = { runs: wideRuns, wicket: false, extra: true, display: `W${wideRuns > 1 ? wideRuns : ''}` };
                        
                    } else {
                        cumulative += noBallProb;
                        if (rand < cumulative) {
                            const noBallRuns = Math.floor(Math.random() * 3); // 0-2 additional runs
                            result = { runs: 1 + noBallRuns, wicket: false, extra: true, display: `nb${noBallRuns > 0 ? noBallRuns : ''}` };
                            
                        } else {
                            cumulative += byeProb;
                            if (rand < cumulative) {
                                const byeRuns = Math.random() < 0.7 ? 1 : (1 + Math.floor(Math.random() * 2));
                                result = { runs: byeRuns, wicket: false, extra: false, display: `lb${byeRuns}` };
                                
                            } else {
                                cumulative += sixProb;
                                if (rand < cumulative) {
                                    result = { runs: 6, wicket: false, extra: false, display: '6' };
                                    striker.matchStats.sixes++;
                                    
                                } else {
                                    cumulative += fourProb;
                                    if (rand < cumulative) {
                                        result = { runs: 4, wicket: false, extra: false, display: '4' };
                                        striker.matchStats.fours++;
                                        
                                    } else {
                                        cumulative += tripleProb;
                                        if (rand < cumulative) {
                                            result = { runs: 3, wicket: false, extra: false, display: '3' };
                                            
                                        } else {
                                            cumulative += doubleProb;
                                            if (rand < cumulative) {
                                                result = { runs: 2, wicket: false, extra: false, display: '2' };
                                                
                                            } else {
                                                cumulative += singleProb;
                                                if (rand < cumulative) {
                                                    result = { runs: 1, wicket: false, extra: false, display: '1' };
                                                } 
                                                // Else dot ball (default)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Update scores and stats
                this.currentScore.runs += result.runs;
                if (!result.extra) {
                    striker.matchStats.ballsFaced++;
                    striker.matchStats.runs += result.runs;
                    bowler.matchStats.ballsBowled++;
                }
                bowler.matchStats.runsConceded += result.runs;
                
                // Update extras tracking
                const currentExtras = this.innings === 1 ? this.team1Extras : this.team2Extras;
                if (result.extra) {
                    if (result.display.startsWith('W')) {
                        currentExtras.wides += result.runs;
                    } else if (result.display.startsWith('nb')) {
                        currentExtras.noballs += result.runs;
                    }
                } else if (result.display.startsWith('lb')) {
                    currentExtras.legbyes += result.runs;
                } else if (result.display.startsWith('b')) {
                    currentExtras.byes += result.runs;
                }
                currentExtras.total = currentExtras.wides + currentExtras.noballs + currentExtras.legbyes + currentExtras.byes;
                
                return result;
            }
            
            // Calculate normalized batting skill (0 to 1)
            calculateBattingSkill(player) {
                // Base skill from batting average (normalized to 0-1)
                let skill = Math.min(player.battingAverage / 60, 1.0); // 60+ average = skill 1.0
                
                // Adjust for strike rate (aggressive vs defensive)
                const strikeRateNorm = Math.min(player.strikeRate / 150, 1.0);
                skill = (skill * 0.7) + (strikeRateNorm * 0.3); // 70% average, 30% strike rate
                
                // Experience factor based on games played
                const experienceFactor = Math.min(player.gamesPlayed / 50, 1.0);
                skill = (skill * 0.8) + (experienceFactor * 0.2);
                
                // Age factor (peak at 26-30, decline after 32)
                let ageFactor = 1.0;
                if (player.age < 22) ageFactor = 0.85; // Young, inexperienced
                else if (player.age < 26) ageFactor = 0.95; // Developing
                else if (player.age <= 30) ageFactor = 1.0; // Prime
                else if (player.age <= 34) ageFactor = 0.95; // Veteran
                else ageFactor = 0.85; // Declining
                
                skill *= ageFactor;
                
                return Math.max(0.1, Math.min(skill, 1.0)); // Clamp between 0.1 and 1.0
            }
            
            // Calculate normalized bowling skill (0 to 1)
            calculateBowlingSkill(player) {
                // Base skill from economy rate (lower is better)
                let skill = Math.max(0, (8 - player.economyRate) / 5); // Economy 3 = skill 1.0, Economy 8 = skill 0
                
                // Adjust for wicket-taking ability
                const wicketRate = Math.min(player.totalWickets / Math.max(player.gamesPlayed, 1) / 3, 1.0); // 3+ wickets per game = 1.0
                skill = (skill * 0.6) + (wicketRate * 0.4); // 60% economy, 40% wickets
                
                // Experience factor
                const experienceFactor = Math.min(player.gamesPlayed / 50, 1.0);
                skill = (skill * 0.8) + (experienceFactor * 0.2);
                
                // Age factor (similar to batting)
                let ageFactor = 1.0;
                if (player.age < 22) ageFactor = 0.85;
                else if (player.age < 26) ageFactor = 0.95;
                else if (player.age <= 30) ageFactor = 1.0;
                else if (player.age <= 34) ageFactor = 0.95;
                else ageFactor = 0.85;
                
                skill *= ageFactor;
                
                return Math.max(0.1, Math.min(skill, 1.0));
            }
            
            // Calculate situation factor (pressure, required run rate, etc.)
            calculateSituationFactor() {
                if (this.innings === 1) {
                    // First innings - consistent batting
                    return 1.0;
                } else {
                    // Second innings - chasing target
                    const target = this.getTarget();
                    const needed = target - this.currentScore.runs;
                    const ballsLeft = (this.oversReduced - this.currentOver + 1) * 6;
                    
                    if (ballsLeft <= 0) return 1.0;
                    
                    const requiredRate = needed / (ballsLeft / 6); // Required run rate per over
                    const currentRate = this.currentScore.runs / Math.max(this.currentOver - 1, 1);
                    
                    // More pressure = more risky shots
                    if (requiredRate > currentRate + 2) {
                        return 1.3; // High pressure - more boundaries, more wickets
                    } else if (requiredRate < currentRate - 2) {
                        return 0.8; // Comfortable chase - more conservative
                    }
                    
                    return 1.0;
                }
            }
            
            handleWicket(striker, bowler) {
                this.currentScore.wickets++;
                bowler.matchStats.wicketsTaken++;
                
                // Generate dismissal type and details
                const dismissalTypes = ['bowled', 'caught', 'lbw', 'runout', 'stumped'];
                const dismissalType = dismissalTypes[Math.floor(Math.random() * dismissalTypes.length)];
                
                // Set dismissal details
                striker.matchStats.isOut = true;
                striker.matchStats.dismissalType = dismissalType;
                striker.matchStats.bowlerWhoGotWicket = bowler.name;
                
                // For caught dismissals, randomly select fielder
                if (dismissalType === 'caught') {
                    const fieldingTeam = this.getCurrentBowlingTeam();
                    const fielders = fieldingTeam.filter(p => p !== bowler);
                    if (fielders.length > 0) {
                        striker.matchStats.caughtBy = fielders[Math.floor(Math.random() * fielders.length)].name;
                    }
                }
                
                // Add to bowler's wickets list
                bowler.matchStats.wicketsOfBowler.push({
                    batsman: striker.name,
                    dismissalType: dismissalType,
                    caughtBy: striker.matchStats.caughtBy || null
                });
                
                // Bring in next batsman
                const nextBatsmanIndex = this.findNextBatsman();
                if (nextBatsmanIndex !== -1) {
                    this.striker = nextBatsmanIndex;
                }
            }
            
            findNextBatsman() {
                const battingOrder = this.getCurrentBattingOrder();
                for (let i = 2; i < battingOrder.length; i++) {
                    if (i !== this.striker && i !== this.nonStriker && battingOrder[i].matchStats.ballsFaced === 0) {
                        return i;
                    }
                }
                return -1;
            }
            
            selectNewBowler(bowlingTeam) {
                this.previousBowler = this.currentBowler;
                
                // CRITICAL: Get available bowlers (excludes current AND previous to prevent consecutive overs)
                let availableBowlers = this.getAvailableBowlers(bowlingTeam);
                
                // Captain's bowling selection logic
                if (availableBowlers.length > 0) {
                    // Sort by bowling skill and form
                    availableBowlers.sort((a, b) => {
                        // Calculate current match economy (if bowled in this match)
                        const aMatchEcon = a.matchStats.ballsBowled > 0 ? 
                            (a.matchStats.runsConceded / Math.max(1, Math.floor(a.matchStats.ballsBowled / 6))) : a.economyRate;
                        const bMatchEcon = b.matchStats.ballsBowled > 0 ? 
                            (b.matchStats.runsConceded / Math.max(1, Math.floor(b.matchStats.ballsBowled / 6))) : b.economyRate;
                        
                        // Prefer bowlers with better current form
                        const aScore = (a.totalWickets / Math.max(a.gamesPlayed, 1)) * 10 - aMatchEcon;
                        const bScore = (b.totalWickets / Math.max(b.gamesPlayed, 1)) * 10 - bMatchEcon;
                        
                        return bScore - aScore;
                    });
                    
                    this.currentBowler = availableBowlers[0];
                }
                // CRITICAL: If no valid bowlers, we have a serious problem - emergency protocol
                else {
                    // Last resort: find ANY player who can bowl (even if violates 10-over limit)
                    // This should only happen in extreme circumstances
                    const emergencyBowlers = bowlingTeam.filter(p => 
                        p !== this.currentBowler &&
                        p !== this.previousBowler // Still can't bowl consecutive overs
                    );
                    
                    if (emergencyBowlers.length > 0) {
                        // Pick best available emergency option
                        emergencyBowlers.sort((a, b) => {
                            // Prefer bowlers/all-rounders over batters
                            const aIsBowler = (a.type === 'Bowler' || a.type === 'All-rounder') ? 1 : 0;
                            const bIsBowler = (b.type === 'Bowler' || b.type === 'All-rounder') ? 1 : 0;
                            
                            if (aIsBowler !== bIsBowler) return bIsBowler - aIsBowler;
                            
                            // Then by experience
                            return b.gamesPlayed - a.gamesPlayed;
                        });
                        
                        this.currentBowler = emergencyBowlers[0];
                        
                        // Mark as emergency bowler if not a natural bowler
                        if (this.currentBowler.type === 'Batter') {
                            this.currentBowler.matchStats.emergencyBowler = true;
                        }
                        
                        console.warn(`EMERGENCY: ${this.currentBowler.name} selected despite constraints - ${this.currentBowler.matchStats.oversBowled} overs already bowled`);
                    }
                }
                
                // Update bowler's match stats
                if (this.currentBowler) {
                    this.bowlerOverCount = 0;
                    // Ensure overs bowled is initialized
                    this.currentBowler.matchStats.oversBowled = this.currentBowler.matchStats.oversBowled || 0;
                }
            }
            
            shouldChangeBowler() {
                if (!this.currentBowler) return true;
                
                // CRITICAL: Check 10-over limit using TOTAL match overs, not consecutive
                if (this.currentBowler.matchStats.oversBowled >= 10) return true;
                
                // CRITICAL: Bowler alternation - same bowler cannot bowl consecutive overs (alternating ends rule)
                if (this.previousBowler && this.currentBowler === this.previousBowler) return true;
                
                // Must bowl minimum 1 over before captain can make changes
                if (this.bowlerOverCount < 1) return false;
                
                // Captain logic for bowling changes after minimum 1 over
                if (this.bowlerOverCount >= 1) {
                    const currentEconomy = this.currentBowler.matchStats.runsConceded / Math.max(1, this.bowlerOverCount);
                    
                    // More aggressive bowling changes based on match situation
                    let economyThreshold = 8.0; // Base threshold
                    
                    // Adjust threshold based on match situation
                    if (this.currentOver <= this.powerplayOvers) {
                        economyThreshold = 9.0; // More lenient during powerplay
                    } else if (this.currentOver > 40) {
                        economyThreshold = 7.0; // More strict in death overs
                    }
                    
                    // Consider changing bowler if economy is poor
                    if (currentEconomy > economyThreshold) {
                        // But only if we have better bowling options available
                        const bowlingTeam = this.getCurrentBowlingTeam();
                        const availableBowlers = this.getAvailableBowlers(bowlingTeam);
                        
                        if (availableBowlers.length > 0) {
                            return Math.random() < 0.7; // 70% chance to change if poor economy
                        }
                    }
                    
                    // Random bowling changes for tactical reasons (every 3-5 overs)
                    if (this.bowlerOverCount >= 3 && Math.random() < 0.3) {
                        const bowlingTeam = this.getCurrentBowlingTeam();
                        const availableBowlers = this.getAvailableBowlers(bowlingTeam);
                        return availableBowlers.length > 0;
                    }
                }
                
                return false;
            }
            
            // Get available bowlers for captain's selection
            getAvailableBowlers(bowlingTeam) {
                // CRITICAL: Exclude previous bowler to prevent consecutive overs (alternating ends rule)
                let availableBowlers = bowlingTeam.filter(p => 
                    (p.type === 'Bowler' || p.type === 'All-rounder') &&
                    p !== this.currentBowler &&
                    p !== this.previousBowler && // CRITICAL: Cannot bowl consecutive overs
                    p.matchStats.oversBowled < 10
                );
                
                // If no specialized bowlers available, allow any player (except current and previous)
                if (availableBowlers.length === 0) {
                    availableBowlers = bowlingTeam.filter(p => 
                        p !== this.currentBowler &&
                        p !== this.previousBowler && // CRITICAL: Cannot bowl consecutive overs
                        p.matchStats.oversBowled < 10
                    );
                }
                
                return availableBowlers;
            }
            
            checkWeatherInterruption() {
                if (this.weather === 'Light Drizzle') {
                    return Math.random() < 0.3; // 30% chance
                } else if (this.weather === 'Threatening Rain') {
                    return Math.random() < 0.15; // 15% chance
                }
                return false;
            }
            
            handleWeatherInterruption() {
                if (this.weather === 'Light Drizzle' && Math.random() < 0.6) {
                    // Match abandoned
                    return { abandoned: true, reason: 'Match abandoned due to rain' };
                } else {
                    // Rain delay - reduce overs
                    const oversLost = Math.floor(Math.random() * 10) + 5;
                    this.oversReduced = Math.max(20, this.oversReduced - oversLost);
                    this.rainDelay = true;
                    return { 
                        delay: true, 
                        reason: `Rain delay! Match reduced to ${this.oversReduced} overs per side`,
                        oversLost: oversLost
                    };
                }
            }
            
            generateOverCommentary(balls, runs, wickets) {
                const comments = [];
                
                if (wickets > 0) {
                    const wicketComments = [
                        "Bowled him! Straight through the bat and pad.",
                        "Caught brilliantly in the slips!",
                        "LBW! That was plumb in front.",
                        "There's a mix-up! Terrible running between the wickets.",
                        "Stumped! The keeper was lightning quick.",
                        "Edge taken! The fielder makes no mistake."
                    ];
                    comments.push(wicketComments[Math.floor(Math.random() * wicketComments.length)]);
                }
                
                if (balls.includes('6')) {
                    const sixComments = [
                        "Smashed it! That's a long way over the boundary for 6!",
                        "What a shot! Clean as a whistle over the rope!",
                        "Maximum! The crowd erupts as the ball sails into the stands!",
                        "Brutal hitting! That ball is still rising as it clears the fence!"
                    ];
                    comments.push(sixComments[Math.floor(Math.random() * sixComments.length)]);
                }
                
                if (balls.includes('4')) {
                    const fourComments = [
                        "Brilliant cover-drive to the fence.",
                        "Sublime timing! The ball races away to the boundary.",
                        "Cracking shot! No fielder in the world could have stopped that.",
                        "Pierced the gap perfectly! Four runs all the way."
                    ];
                    comments.push(fourComments[Math.floor(Math.random() * fourComments.length)]);
                }
                
                if (runs === 0 && wickets === 0) {
                    const economicalComments = [
                        "Tight bowling! Not giving anything away.",
                        "Maiden over! Excellent bowling discipline.",
                        "The pressure is building with dot balls.",
                        "Superb line and length from the bowler."
                    ];
                    if (Math.random() < 0.3) comments.push(economicalComments[Math.floor(Math.random() * economicalComments.length)]);
                }
                
                if (runs >= 15) {
                    const expensiveComments = [
                        "Expensive over! The batsmen are on the attack.",
                        "The bowling is under pressure here!",
                        "Runs flowing freely this over!",
                        "The captain needs to think about a bowling change."
                    ];
                    comments.push(expensiveComments[Math.floor(Math.random() * expensiveComments.length)]);
                }
                
                return comments.join(' ');
            }
            
            isInningsComplete() {
                return this.currentScore.wickets >= 10 || this.currentOver > this.oversReduced;
            }
            
            getTarget() {
                return this.innings === 2 ? (this.battingFirst === this.team1 ? this.team1Score.runs : this.team2Score.runs) + 1 : 0;
            }
            
            isMatchComplete() {
                if (this.innings === 1) return false;
                const target = this.getTarget();
                return this.currentScore.runs >= target || this.isInningsComplete();
            }
            
            getMatchResult() {
                const team1Name = this.team1.name || 'Your Team';
                const team2Name = this.team2.name || 'Your Team';
                
                let winnerName, margin;
                if (this.team1Score.runs > this.team2Score.runs) {
                    winnerName = team1Name;
                    margin = `${this.team1Score.runs - this.team2Score.runs} runs`;
                } else if (this.team2Score.runs > this.team1Score.runs) {
                    winnerName = team2Name;
                    margin = `${10 - this.team2Score.wickets} wickets`;
                } else {
                    winnerName = 'Tie';
                    margin = 'Match tied';
                }
                
                return {
                    team1: team1Name,
                    team2: team2Name,
                    score1: `${this.team1Score.runs}/${this.team1Score.wickets}`,
                    score2: `${this.team2Score.runs}/${this.team2Score.wickets}`,
                    winner: winnerName,
                    margin: margin
                };
            }
        }

        // Enhanced match simulation that processes entire league round
        function simulateMatchPlay() {
            const commentary = document.getElementById('match-commentary');
            
            // Show/hide buttons
            document.getElementById('start-match-btn').style.display = 'none';
            document.getElementById('auto-complete-btn').style.display = 'inline-block';
            
            // Create new match
            const playerTeam = { isPlayer: true, name: gameState.teamName };
            currentMatch = new CricketMatch(playerTeam, matchState.opponent, matchState.pitchType, matchState.weather, matchState.isHomeGame);
            
            // Initial setup
            commentary.innerHTML = `
                <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded">
                    <p><strong>üèè ${gameState.teamName} vs ${currentMatch.team2.name}</strong></p>
                    <p>Toss: ${currentMatch.tossWinner.name || gameState.teamName} won and elected to ${currentMatch.battingFirst === currentMatch.tossWinner ? 'bat' : 'field'} first</p>
                    <p>Conditions: ${matchState.pitchType}, ${matchState.weather}</p>
                    ${currentMatch.powerplayOvers > 0 ? '<p><span class="text-yellow-600">Powerplay:</span> First 10 overs (fielding restrictions)</p>' : ''}
                </div>
            `;
            
            // Start over-by-over simulation
            matchInterval = setInterval(() => {
                if (currentMatch.isMatchComplete()) {
                    completeMatch();
                    return;
                }
                
                if (currentMatch.isInningsComplete() && currentMatch.innings === 1) {
                    // Switch innings
                    currentMatch.innings = 2;
                    currentMatch.currentOver = 1;
                    currentMatch.currentScore = currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team2Score : currentMatch.team1Score;
                    currentMatch.striker = 0;
                    currentMatch.nonStriker = 1;
                    currentMatch.currentBowler = null;
                    currentMatch.bowlerOverCount = 0;
                    
                    const target = currentMatch.getTarget();
                    commentary.innerHTML += `
                        <div class="mb-2 p-2 bg-gray-50 dark:bg-gray-700 rounded">
                            <p><strong>End of First Innings</strong></p>
                            <p>${currentMatch.battingFirst.name || gameState.teamName}: ${currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team1Score.runs : currentMatch.team2Score.runs}/${currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team1Score.wickets : currentMatch.team2Score.wickets}</p>
                            <p><strong>Target: ${target} runs</strong></p>
                        </div>
                    `;
                }
                
                const overResult = currentMatch.simulateOver();
                
                if (overResult.abandoned) {
                    commentary.innerHTML += `<div class="mb-2 p-2 bg-red-50 dark:bg-red-900 rounded"><p><strong>${overResult.reason}</strong></p></div>`;
                    completeAbandonedMatch();
                    return;
                }
                
                if (overResult.delay) {
                    commentary.innerHTML += `<div class="mb-2 p-2 bg-yellow-50 dark:bg-yellow-900 rounded"><p><strong>${overResult.reason}</strong></p></div>`;
                }
                
                // Display over
                const isPowerplay = currentMatch.currentOver <= currentMatch.powerplayOvers && currentMatch.innings === 1;
                const overClass = isPowerplay ? 'text-yellow-600 dark:text-yellow-400' : 'text-gray-500 dark:text-gray-400';
                
                commentary.innerHTML += `
                    <div class="mb-2">
                        <p><span class="${overClass}">Over ${overResult.number}${isPowerplay ? ' (PP)' : ''}:</span> ${overResult.balls}</p>
                        ${overResult.commentary ? `<p class="text-sm italic text-gray-600 dark:text-gray-400">"${overResult.commentary}"</p>` : ''}
                    </div>
                `;
                
                // Show current score and target (if chasing)
                if (currentMatch.innings === 2) {
                    const target = currentMatch.getTarget();
                    const needed = target - currentMatch.currentScore.runs;
                    const ballsLeft = (currentMatch.oversReduced - currentMatch.currentOver + 1) * 6;
                    
                    if (needed > 0 && ballsLeft > 0) {
                        commentary.innerHTML += `<p class="text-xs text-blue-600 dark:text-blue-400">Need ${needed} runs from ${ballsLeft} balls</p>`;
                    }
                }
                
                // Auto scroll to bottom
                commentary.scrollTop = commentary.scrollHeight;
                
            }, 1000); // 1 second per over
        }



        // Update team name function
        function updateTeamName() {
            const teamNameInput = document.getElementById('team-name-input');
            gameState.teamName = teamNameInput.value || 'Your Team';
            
            // Update player team standing
            const playerStanding = gameState.leagueStandings.find(s => s.isPlayer);
            if (playerStanding) {
                playerStanding.name = gameState.teamName;
            }
            
            // Update all references throughout the app
            updateTeamNameDisplay();
        }

        // Update team name display throughout app
        function updateTeamNameDisplay() {
            // Update standings
            updateStandings();
            
            // Update recent results
            updateRecentResults();
            
            // Update any match displays that reference team name
            const yourTeamLabels = document.querySelectorAll('[data-team-name]');
            yourTeamLabels.forEach(label => {
                label.textContent = gameState.teamName;
            });
        }

        // Auto-complete match function
        function autoCompleteMatch() {
            if (matchState.selectedXI.length !== 11) {
                showCustomAlert('Please select exactly 11 players for your team!');
                return;
            }
            
            if (!gameState.players.some(p => p.isCaptain)) {
                showCustomAlert('Please select a team captain from the Roster tab!');
                return;
            }
            
            // Show live match details
            document.getElementById('live-match-details').style.display = 'block';
            document.getElementById('auto-complete-btn').style.display = 'none';
            
            // Create and complete match instantly
            const playerTeam = { isPlayer: true, name: gameState.teamName };
            currentMatch = new CricketMatch(playerTeam, matchState.opponent, matchState.pitchType, matchState.weather, matchState.isHomeGame);
            
            const commentary = document.getElementById('match-commentary');
            
            // Initial setup
            commentary.innerHTML = `
                <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded">
                    <p><strong>üèè ${gameState.teamName} vs ${currentMatch.team2.name}</strong></p>
                    <p>Toss: ${currentMatch.tossWinner.name || gameState.teamName} won and elected to ${currentMatch.battingFirst === currentMatch.tossWinner ? 'bat' : 'field'} first</p>
                    <p>Conditions: ${matchState.pitchType}, ${matchState.weather}</p>
                    ${currentMatch.powerplayOvers > 0 ? '<p><span class="text-yellow-600">Powerplay:</span> First 10 overs (fielding restrictions)</p>' : ''}
                </div>
            `;
            
            // Simulate complete match instantly
            while (!currentMatch.isMatchComplete()) {
                if (currentMatch.isInningsComplete() && currentMatch.innings === 1) {
                    // Switch innings
                    currentMatch.innings = 2;
                    currentMatch.currentOver = 1;
                    currentMatch.currentScore = currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team2Score : currentMatch.team1Score;
                    currentMatch.striker = 0;
                    currentMatch.nonStriker = 1;
                    currentMatch.currentBowler = null;
                    currentMatch.bowlerOverCount = 0;
                    
                    const target = currentMatch.getTarget();
                    commentary.innerHTML += `
                        <div class="mb-2 p-2 bg-gray-50 dark:bg-gray-700 rounded">
                            <p><strong>End of First Innings</strong></p>
                            <p>${currentMatch.battingFirst.name || gameState.teamName}: ${currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team1Score.runs : currentMatch.team2Score.runs}/${currentMatch.battingFirst === currentMatch.team1 ? currentMatch.team1Score.wickets : currentMatch.team2Score.wickets}</p>
                            <p><strong>Target: ${target} runs</strong></p>
                        </div>
                    `;
                }
                
                const overResult = currentMatch.simulateOver();
                
                if (overResult.abandoned) {
                    commentary.innerHTML += `<div class="mb-2 p-2 bg-red-50 dark:bg-red-900 rounded"><p><strong>${overResult.reason}</strong></p></div>`;
                    break;
                }
                
                if (overResult.delay) {
                    commentary.innerHTML += `<div class="mb-2 p-2 bg-yellow-50 dark:bg-yellow-900 rounded"><p><strong>${overResult.reason}</strong></p></div>`;
                }
                
                // Display over
                const isPowerplay = currentMatch.currentOver <= currentMatch.powerplayOvers && currentMatch.innings === 1;
                const overClass = isPowerplay ? 'text-yellow-600 dark:text-yellow-400' : 'text-gray-500 dark:text-gray-400';
                
                commentary.innerHTML += `
                    <div class="mb-2">
                        <p><span class="${overClass}">Over ${overResult.number}${isPowerplay ? ' (PP)' : ''}:</span> ${overResult.balls}</p>
                        ${overResult.commentary ? `<p class="text-sm italic text-gray-600 dark:text-gray-400">"${overResult.commentary}"</p>` : ''}
                    </div>
                `;
                
                // Show current score and target (if chasing)
                if (currentMatch.innings === 2) {
                    const target = currentMatch.getTarget();
                    const needed = target - currentMatch.currentScore.runs;
                    const ballsLeft = (currentMatch.oversReduced - currentMatch.currentOver + 1) * 6;
                    
                    if (needed > 0 && ballsLeft > 0) {
                        commentary.innerHTML += `<p class="text-xs text-blue-600 dark:text-blue-400">Need ${needed} runs from ${ballsLeft} balls</p>`;
                    }
                }
            }
            
            // Complete the match
            completeMatch();
        }

        // Complete abandoned match (rain abandoned)
        function completeAbandonedMatch() {
            if (!currentMatch) return;
            
            // Clear the match interval immediately to prevent continued execution
            if (matchInterval) {
                clearInterval(matchInterval);
                matchInterval = null;
            }
            
            const commentary = document.getElementById('match-commentary');
            
            // Display final result for abandoned match
            commentary.innerHTML += `
                <div class="mt-4 p-4 bg-orange-50 dark:bg-orange-900 rounded border-2 border-orange-200 dark:border-orange-700">
                    <p class="text-lg font-bold text-center">Match Abandoned - Rain</p>
                    <div class="mt-2 text-center">
                        <p>Both teams receive 1 point</p>
                        <p><strong>${gameState.teamName}:</strong> ${currentMatch.team1Score.runs}/${currentMatch.team1Score.wickets}</p>
                        <p><strong>${currentMatch.team2.name}:</strong> ${currentMatch.team2Score.runs}/${currentMatch.team2Score.wickets}</p>
                    </div>
                </div>
            `;
            
            // Create abandoned match result
            const result = {
                team1: gameState.teamName,
                team2: currentMatch.team2.name,
                score1: `${currentMatch.team1Score.runs}/${currentMatch.team1Score.wickets}`,
                score2: `${currentMatch.team2Score.runs}/${currentMatch.team2Score.wickets}`,
                winner: 'Match Abandoned',
                margin: 'Rain',
                transcript: commentary.innerHTML
            };
            
            // Update league standings - both teams get 1 point, no win/loss
            const playerStanding = gameState.leagueStandings.find(s => s.isPlayer);
            playerStanding.gamesPlayed++;
            playerStanding.points += 1; // 1 point for abandoned match
            // NRR remains unchanged for abandoned matches
            
            // Update opponent standings
            const opponentStanding = gameState.leagueStandings.find(s => s.name === matchState.opponent.name);
            if (opponentStanding) {
                opponentStanding.gamesPlayed++;
                opponentStanding.points += 1; // 1 point for abandoned match
            }
            
            // Update AI team records
            matchState.opponent.gamesPlayed++;
            matchState.opponent.points += 1;
            // No win/loss update for abandoned matches
            
            // FAN BASE AND INCOME SYSTEM FOR ABANDONED MATCHES
            
            // Calculate income for abandoned match (reduced amount)
            const incomeData = calculateMatchIncome(
                { isPlayer: true, name: gameState.teamName }, 
                matchState.opponent, 
                matchState.isHomeGame
            );
            
            // Reduced income for abandoned matches (50% of normal)
            const reducedIncome = Math.floor(incomeData.playerIncome * 0.5);
            gameState.budget += reducedIncome;
            document.getElementById('budget').textContent = gameState.budget;
            
            // No fan base change for abandoned matches (neutral result)
            // Win/loss streaks remain unchanged
            
            // Add result to recent results with transcript
            gameState.recentResults.push(result);
            
            // Process AI matches and update displays
            processLeagueRound();
            
            // Update AI team fan bases after their matches
            updateAITeamFanBases();
            
            updateStandings();
            updateRecentResults();
            displayPlayers();
            
            // Schedule next match
            matchState.roundNumber++;
            scheduleNextMatch();
            
            // Auto-close match display and reset buttons
            setTimeout(() => {
                document.getElementById('start-match-btn').style.display = 'inline-block';
                document.getElementById('auto-complete-btn').style.display = 'none';
                document.getElementById('live-match-details').style.display = 'none';
                currentMatch = null;
            }, 5000);
        }

        // Complete match (shared logic)
        function completeMatch() {
            if (!currentMatch) return;
            
            // Clear the match interval immediately to prevent continued execution
            if (matchInterval) {
                clearInterval(matchInterval);
                matchInterval = null;
            }
            
            const commentary = document.getElementById('match-commentary');
            const result = currentMatch.getMatchResult();
            
            // Store the complete match transcript
            const matchTranscript = commentary.innerHTML;
            
            // Display final result
            commentary.innerHTML += `
                <div class="mt-4 p-4 bg-green-50 dark:bg-green-900 rounded border-2 border-green-200 dark:border-green-700">
                    <p class="text-lg font-bold text-center">${result.winner} won by ${result.margin}</p>
                    <div class="mt-2 text-center">
                        <p><strong>${result.team1}:</strong> ${result.score1}</p>
                        <p><strong>${result.team2}:</strong> ${result.score2}</p>
                    </div>
                </div>
            `;
            
            // Add final transcript to result
            result.transcript = commentary.innerHTML;
            
            // Update league standings for BOTH player and opponent
            const playerStanding = gameState.leagueStandings.find(s => s.isPlayer);
            const opponentStanding = gameState.leagueStandings.find(s => s.name === matchState.opponent.name);
            
            // Update player standings
            playerStanding.gamesPlayed++;
            if (result.winner === gameState.teamName) {
                playerStanding.wins++;
                playerStanding.points += 2;
            } else if (result.winner !== 'Tie') {
                playerStanding.losses++;
            } else {
                playerStanding.points += 1; // Tie
            }
            playerStanding.netRunRate = (playerStanding.wins - playerStanding.losses) + Math.random() * 2 - 1;
            
            // Update opponent standings 
            if (opponentStanding) {
                opponentStanding.gamesPlayed++;
                if (result.winner === matchState.opponent.name) {
                    opponentStanding.wins++;
                    opponentStanding.points += 2;
                } else if (result.winner !== 'Tie') {
                    opponentStanding.losses++;
                } else {
                    opponentStanding.points += 1; // Tie
                }
                opponentStanding.netRunRate = (opponentStanding.wins - opponentStanding.losses) + Math.random() * 2 - 1;
            }
            
            // Also update the AI team object to keep it in sync
            if (result.winner === matchState.opponent.name) {
                matchState.opponent.wins++;
                matchState.opponent.points += 2;
            } else if (result.winner !== 'Tie') {
                matchState.opponent.losses++;
            } else {
                matchState.opponent.points += 1;
            }
            matchState.opponent.gamesPlayed++;
            matchState.opponent.netRunRate = (matchState.opponent.wins - matchState.opponent.losses) + Math.random() * 2 - 1;
            
            // Update player stats
            currentMatch.team1Players.concat(currentMatch.team2Players).forEach(player => {
                if (player.matchStats.ballsFaced > 0) {
                    player.totalRuns += player.matchStats.runs;
                    player.gamesPlayed++;
                    player.battingAverage = Math.floor(player.totalRuns / player.gamesPlayed);
                    
                    // Update high score
                    if (player.matchStats.runs > player.highScore) {
                        player.highScore = player.matchStats.runs;
                    }
                    
                    // Update 50s and 100s
                    if (player.matchStats.runs >= 50) player.fifties++;
                    if (player.matchStats.runs >= 100) player.hundreds++;
                }
                
                if (player.matchStats.ballsBowled > 0) {
                    player.totalWickets += player.matchStats.wicketsTaken;
                    const newEconomy = player.matchStats.runsConceded / Math.max(1, player.matchStats.oversBowled);
                    player.economyRate = (player.economyRate + newEconomy) / 2; // Average with previous
                    
                    if (player.matchStats.wicketsTaken >= 5) player.fiveWicketHauls++;
                }
            });
            
            // CRITICAL: Process training queue after each match
            processTrainingQueue();
            
            // FAN BASE AND INCOME SYSTEM INTEGRATION
            
            // Check if any player scored 100+ runs for fan base bonus
            let playerScored100 = false;
            currentMatch.team1Players.concat(currentMatch.team2Players).forEach(player => {
                if (player.matchStats.runs >= 100) {
                    playerScored100 = true;
                }
            });
            
            // Calculate match income
            const incomeData = calculateMatchIncome(
                { isPlayer: true, name: gameState.teamName }, 
                matchState.opponent, 
                matchState.isHomeGame
            );
            
            // Update fan base based on match result
            const playerWon = result.winner === gameState.teamName;
            calculateFanBaseChange(playerWon, playerScored100);
            
            // Update budget display
            gameState.budget += incomeData.playerIncome;
            document.getElementById('budget').textContent = gameState.budget;
            
            // Add result to recent results with transcript and match data for scorecard persistence
            result.matchData = currentMatch; // Store the complete match object for scorecard access
            gameState.recentResults.push(result);
            
            // Process AI matches and update displays
            processLeagueRound();
            
            // Update AI team fan bases after their matches
            updateAITeamFanBases();
            
            updateStandings();
            updateRecentResults();
            displayPlayers();
            
            // Check if season is complete before scheduling next match
            if (checkSeasonComplete()) {
                // Auto-close match display immediately when season ends
                document.getElementById('start-match-btn').style.display = 'inline-block';
                document.getElementById('auto-complete-btn').style.display = 'none';
                document.getElementById('live-match-details').style.display = 'none';
                currentMatch = null;
                endSeason();
                return;
            }
            
            // Schedule next match
            matchState.roundNumber++;
            scheduleNextMatch();
            
            // Auto-close match display and reset buttons
            setTimeout(() => {
                document.getElementById('start-match-btn').style.display = 'inline-block';
                document.getElementById('auto-complete-btn').style.display = 'none';
                document.getElementById('live-match-details').style.display = 'none';
                currentMatch = null;
            }, 5000);
        }

        // Custom alert function (since alert() is not supported)
        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Toggle schedule visibility
        function toggleSchedule() {
            const scheduleDiv = document.getElementById('season-schedule');
            const toggleBtn = document.getElementById('schedule-toggle');
            
            if (scheduleDiv.style.display === 'none') {
                scheduleDiv.style.display = 'block';
                toggleBtn.textContent = 'Hide Schedule';
                generateSeasonSchedule();
            } else {
                scheduleDiv.style.display = 'none';
                toggleBtn.textContent = 'Show Schedule';
            }
        }

        // Generate complete season schedule with 14 rounds in 2 columns
        function generateSeasonSchedule() {
            const scheduleDiv = document.getElementById('season-schedule');
            const allTeams = [gameState.teamName, ...gameState.aiTeams.map(t => t.name)];
            
            // Generate 14 rounds total for double round-robin season
            const totalRounds = 14;
            
            // Split into two columns
            const rounds1to7 = [];
            const rounds8to14 = [];
            
            for (let round = 1; round <= 7; round++) {
                rounds1to7.push(generateRoundScheduleHTML(allTeams, round));
            }
            
            for (let round = 8; round <= 14; round++) {
                rounds8to14.push(generateRoundScheduleHTML(allTeams, round));
            }
            
            scheduleDiv.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="font-bold text-lg mb-4 text-center text-gray-800 dark:text-gray-200">Rounds 1-7</h3>
                        ${rounds1to7.join('')}
                    </div>
                    <div>
                        <h3 class="font-bold text-lg mb-4 text-center text-gray-800 dark:text-gray-200">Rounds 8-14</h3>
                        ${rounds8to14.join('')}
                    </div>
                </div>
            `;
        }

        // Generate HTML for a single round's schedule
        function generateRoundScheduleHTML(allTeams, round) {
            const roundMatches = generateRoundMatches(allTeams, round);
            
            let roundHTML = `
                <div class="mb-4">
                    <h4 class="font-bold text-md mb-2 text-blue-600 dark:text-blue-400">Round ${round}:</h4>
                    <div class="space-y-1">
            `;
            
            roundMatches.forEach(match => {
                const isPlayerMatch = match.team1 === gameState.teamName || match.team2 === gameState.teamName;
                const highlightClass = isPlayerMatch ? 'font-medium text-blue-800 dark:text-blue-200' : 'text-gray-700 dark:text-gray-300';
                
                roundHTML += `
                    <div class="text-sm ${highlightClass}">
                        ${match.team1} vs ${match.team2}
                    </div>
                `;
            });
            
            roundHTML += `
                    </div>
                </div>
            `;
            
            return roundHTML;
        }

        // Generate matches for a specific round (used for season schedule display)
        function generateRoundMatches(allTeams, round) {
            const matches = [];
            const numTeams = allTeams.length;
            
            if (numTeams % 2 === 1) {
                // Odd number of teams - one team gets a bye
                const activeTeams = [...allTeams];
                // Rotate teams for round-robin
                if (round > 1) {
                    const rotated = activeTeams.slice(1, (round - 1) % (numTeams - 1) + 1);
                    const remaining = activeTeams.slice((round - 1) % (numTeams - 1) + 1);
                    activeTeams.splice(1, numTeams - 1, ...remaining, ...rotated);
                }
                
                // Pair teams (skip last one for bye)
                for (let i = 0; i < activeTeams.length - 1; i += 2) {
                    if (i + 1 < activeTeams.length) {
                        matches.push({
                            team1: activeTeams[i],
                            team2: activeTeams[i + 1]
                        });
                    }
                }
            } else {
                // Even number of teams - everyone plays
                const activeTeams = [...allTeams];
                
                // Round-robin rotation: keep first team fixed, rotate others
                if (round > 1) {
                    const firstTeam = activeTeams[0];
                    const otherTeams = activeTeams.slice(1);
                    
                    // Rotate other teams
                    const rotations = (round - 1) % (numTeams - 1);
                    for (let r = 0; r < rotations; r++) {
                        otherTeams.push(otherTeams.shift());
                    }
                    
                    activeTeams.splice(0, numTeams, firstTeam, ...otherTeams);
                }
                
                // Generate matches
                for (let i = 0; i < numTeams / 2; i++) {
                    const team1Index = i;
                    const team2Index = numTeams - 1 - i;
                    
                    if (team1Index !== team2Index) {
                        matches.push({
                            team1: activeTeams[team1Index],
                            team2: activeTeams[team2Index]
                        });
                    }
                }
            }
            
            return matches;
        }

        // Check if season is complete (14 games played - double round robin)
        function checkSeasonComplete() {
            const playerStanding = gameState.leagueStandings.find(s => s.isPlayer);
            return playerStanding && playerStanding.gamesPlayed >= 14;
        }

        // End season and show results
        function endSeason() {
            // Sort standings to get final positions
            const finalStandings = [...gameState.leagueStandings].sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                return b.netRunRate - a.netRunRate;
            });
            
            // Find player's position
            const playerPosition = finalStandings.findIndex(s => s.isPlayer) + 1;
            
            let modalMessage, modalImage, shouldAdvance = false;
            
            if (playerPosition === 1) {
                modalMessage = "Congratulations! You have Won the Season! Try the next level.";
                modalImage = "üèÜ"; // Placeholder - trophy emoji
                shouldAdvance = true;
            } else if (playerPosition === 2 || playerPosition === 3) {
                const positionText = playerPosition === 2 ? "2nd" : "3rd";
                modalMessage = `${positionText} place! So close. Try for the Champions next season.`;
                modalImage = "ü•à"; // Placeholder - medal emoji
            } else {
                modalMessage = "A valiant effort. But it looks like the other teams were better this year.";
                modalImage = "‚öîÔ∏è"; // Placeholder - sword emoji
            }
            
            showEndSeasonModal(modalMessage, modalImage, playerPosition, finalStandings, shouldAdvance);
        }

        // Show end season modal
        function showEndSeasonModal(message, image, position, finalStandings, shouldAdvance) {
            // Update the Game Tab UI - replace Start Match with Start New Season
            updateGameTabForSeasonEnd(shouldAdvance);
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            
            // Create final standings HTML
            const standingsHTML = finalStandings.map((team, index) => {
                const pos = index + 1;
                const isPlayer = team.isPlayer;
                const highlightClass = isPlayer ? 'font-bold text-blue-600 dark:text-blue-400' : '';
                
                return `
                    <div class="flex justify-between items-center py-1 ${highlightClass}">
                        <span>${pos}. ${team.name}</span>
                        <span class="text-sm">${team.points} pts (${team.wins}W-${team.losses}L)</span>
                    </div>
                `;
            }).join('');
            
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-lg w-full max-h-[90vh] overflow-hidden">
                    <div class="p-6 text-center">
                        <div class="text-6xl mb-4">${image}</div>
                        <h2 class="text-2xl font-bold mb-4">Season Complete!</h2>
                        <p class="text-lg mb-6">${message}</p>
                        
                        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 mb-6">
                            <h3 class="font-bold mb-3">Final Standings:</h3>
                            <div class="space-y-1 text-sm">
                                ${standingsHTML}
                            </div>
                        </div>
                        
                        <div class="flex gap-3 justify-center">
                            ${shouldAdvance ? 
                                '<button onclick="advanceToNational()" class="px-6 py-3 bg-green-600 text-white hover:bg-green-700 rounded-lg font-medium">Next Level</button>' : 
                                '<button onclick="startNewSeasonFromModal()" class="px-6 py-3 bg-blue-600 text-white hover:bg-blue-700 rounded-lg font-medium">New Season</button>'
                            }
                            <button onclick="this.closest(\'div.fixed\').remove()" class="px-6 py-3 bg-gray-500 text-white hover:bg-gray-600 rounded-lg font-medium">Close</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // Update Game Tab UI for season end
        function updateGameTabForSeasonEnd(shouldAdvance) {
            const startMatchBtn = document.getElementById('start-match-btn');
            
            if (shouldAdvance) {
                // Show "Advance to Next Level" button
                startMatchBtn.textContent = 'üèÜ Advance to Next Level';
                startMatchBtn.className = 'bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg text-lg font-medium';
                startMatchBtn.onclick = () => advanceToNational();
            } else {
                // Show "Start New Season" button
                startMatchBtn.textContent = 'üîÑ Start New Season';
                startMatchBtn.className = 'bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg text-lg font-medium';
                startMatchBtn.onclick = () => startNewSeason();
            }
        }

        // Start new season from modal (same as startNewSeason but closes modal)
        function startNewSeasonFromModal() {
            startNewSeason();
            document.querySelector('div.fixed').remove();
        }

        // Advance to National Cup
        function advanceToNational() {
            // Enable National Cup
            gameState.competitions.national.unlocked = true;
            document.getElementById('national-btn').disabled = false;
            document.getElementById('national-btn').classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-500', 'dark:text-gray-400', 'cursor-not-allowed');
            document.getElementById('national-btn').classList.add('bg-yellow-500', 'text-white');
            
            // Age players
            agePlayers();
            
            // Close modal
            document.querySelector('div.fixed').remove();
            
            // Show success message
            showCustomAlert('National Cup unlocked! Your players have gained experience. Good luck in the next level!');
        }

        // Start new season
        function startNewSeason() {
            // Age players
            agePlayers();
            
            // Reset competition
            initializeCompetition(gameState.currentCompetition);
            matchState.roundNumber = 1;
            scheduleNextMatch();
            
            // Reset the Game Tab button to original state
            const startMatchBtn = document.getElementById('start-match-btn');
            startMatchBtn.textContent = 'üèè Start Match';
            startMatchBtn.className = 'bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg text-lg font-medium';
            startMatchBtn.onclick = () => startMatch();
            
            // Close modal if it exists
            const modal = document.querySelector('div.fixed');
            if (modal) modal.remove();
            
            // Show message
            showCustomAlert('New season started! Your players have aged and gained experience. Time to try again!');
        }

        // Age players by 1 year
        function agePlayers() {
            gameState.players.forEach(player => {
                player.age++;
                // Players maintain their stats but gain experience through aging
                // Could add future logic here for stat changes based on age
            });
            displayPlayers();
        }

        // Initialize game
        function initGame() {
            gameState.players = generateInitialRoster();
            
            // Set first player as captain by default
            if (gameState.players.length > 0) {
                gameState.players[0].isCaptain = true;
            }
            
            displayPlayers();
            initializeCompetition('local');
            updatePlayerSelector();
            scheduleNextMatch();
        }

        // TRAINING SYSTEM FUNCTIONS
        
        // Populate player selector for training
        function populateTrainingSelector() {
            const selector = document.getElementById('training-player-selector');
            
            selector.innerHTML = '<option value="">Choose a player...</option>' +
                gameState.players.map((player, index) => {
                    return `<option value="${index}">${player.name} - ${player.type} (Age: ${player.age})</option>`;
                }).join('');
        }
        
        // Select player for training
        function selectPlayerForTraining() {
            const selector = document.getElementById('training-player-selector');
            const playerIndex = parseInt(selector.value);
            
            if (isNaN(playerIndex)) {
                document.getElementById('player-training-panel').style.display = 'none';
                return;
            }
            
            const player = gameState.players[playerIndex];
            showTrainingPanel(player);
        }
        
        // Show training panel for selected player
        function showTrainingPanel(player) {
            document.getElementById('player-training-panel').style.display = 'block';
            
            // Update player details
            document.getElementById('training-player-name').textContent = player.name;
            document.getElementById('training-player-type').textContent = player.type;
            document.getElementById('training-player-age').textContent = player.age;
            document.getElementById('training-player-games').textContent = player.gamesPlayed;
            
            // Update active training queue
            updateTrainingQueue(player);
            
            // Update skill levels and costs
            updateTrainingUI(player);
            
            // Show/hide specialist sections
            updateSpecialistTraining(player);
            
            // Show/hide bowling training for batters
            const bowlingSection = document.getElementById('bowling-training-section');
            if (player.type === 'Batter') {
                bowlingSection.style.display = 'none';
            } else {
                bowlingSection.style.display = 'block';
            }
        }
        
        // Update training UI with current values
        function updateTrainingUI(player) {
            // Batting skills
            updateSkillDisplay('defense', 'battingDefense', player);
            updateSkillDisplay('aggression', 'battingAggression', player);
            updateSkillDisplay('consistency', 'battingConsistency', player);
            
            // Bowling skills (only for non-batters)
            if (player.type !== 'Batter') {
                updateSkillDisplay('bowl-defense', 'bowlingDefense', player);
                updateSkillDisplay('bowl-aggression', 'bowlingAggression', player);
                updateSkillDisplay('bowl-consistency', 'bowlingConsistency', player);
            }
            
            // Fielding skills
            updateSkillDisplay('catching', 'fieldingCatching', player);
            updateSkillDisplay('agility', 'fieldingAgility', player);
            
            // Specialist skills
            if (player.isWicketKeeper) {
                updateSkillDisplay('wicketkeeping', 'wicketKeeping', player);
            }
            if (player.isCaptain) {
                updateSkillDisplay('captaincy', 'captaincy', player);
            }
        }
        
        // Update individual skill display
        function updateSkillDisplay(elementPrefix, skillName, player) {
            const skill = player.trainingSkills[skillName];
            const ceiling = player.talentCeiling[skillName];
            const cost = calculateTrainingCost(player, skillName);
            const difficulty = player.trainingDifficulty[skillName];
            
            // Update level display
            const levelElement = document.getElementById(`${elementPrefix}-level`);
            if (levelElement) {
                levelElement.textContent = `${skill}/${ceiling}`;
                
                // Color-code based on how close to ceiling
                const progress = skill / ceiling;
                if (progress >= 0.9) {
                    levelElement.className = 'text-sm bg-red-200 dark:bg-red-700 px-2 py-1 rounded'; // Near max
                } else if (progress >= 0.7) {
                    levelElement.className = 'text-sm bg-yellow-200 dark:bg-yellow-700 px-2 py-1 rounded'; // Good
                } else {
                    levelElement.className = 'text-sm bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded'; // Room to grow
                }
            }
            
            // Update cost display
            const costElement = document.getElementById(`${elementPrefix}-cost`);
            if (costElement) {
                costElement.textContent = `$${cost}`;
                
                // Adjust cost color based on difficulty
                if (difficulty === 'hard') {
                    costElement.className = 'text-sm font-bold text-red-600 dark:text-red-400';
                } else if (difficulty === 'easy') {
                    costElement.className = 'text-sm font-bold text-green-600 dark:text-green-400';
                } else {
                    costElement.className = 'text-sm font-bold text-blue-600 dark:text-blue-400';
                }
            }
            
            // Update button state
            const buttonElement = document.getElementById(`${elementPrefix}-btn`);
            if (buttonElement) {
                const canTrain = canPlayerTrain(player, skillName, cost);
                
                if (!canTrain.allowed) {
                    buttonElement.disabled = true;
                    buttonElement.textContent = canTrain.reason;
                    buttonElement.className = buttonElement.className.replace(/bg-\w+-500/, 'bg-gray-400');
                } else {
                    buttonElement.disabled = false;
                    buttonElement.textContent = 'Train';
                    // Restore original color based on skill type
                    const originalClasses = {
                        'defense': 'bg-blue-500 hover:bg-blue-600',
                        'aggression': 'bg-blue-500 hover:bg-blue-600',
                        'consistency': 'bg-blue-500 hover:bg-blue-600',
                        'bowl-defense': 'bg-red-500 hover:bg-red-600',
                        'bowl-aggression': 'bg-red-500 hover:bg-red-600',
                        'bowl-consistency': 'bg-red-500 hover:bg-red-600',
                        'catching': 'bg-green-500 hover:bg-green-600',
                        'agility': 'bg-green-500 hover:bg-green-600',
                        'wicketkeeping': 'bg-purple-500 hover:bg-purple-600',
                        'captaincy': 'bg-purple-500 hover:bg-purple-600'
                    };
                    
                    const baseClass = 'px-3 py-1 text-white rounded text-sm';
                    buttonElement.className = `${baseClass} ${originalClasses[elementPrefix] || 'bg-blue-500 hover:bg-blue-600'}`;
                }
            }
        }
        
        // Calculate training cost with multipliers
        function calculateTrainingCost(player, skillName) {
            let baseCost = player.trainingCosts[skillName];
            const difficulty = player.trainingDifficulty[skillName];
            
            // Apply difficulty multiplier
            if (difficulty === 'hard') {
                baseCost = Math.floor(baseCost * 1.5);
            } else if (difficulty === 'easy') {
                baseCost = Math.floor(baseCost * 0.75);
            }
            
            return baseCost;
        }
        
        // Check if player can train a skill
        function canPlayerTrain(player, skillName, cost) {
            // Check budget
            if (gameState.budget < cost) {
                return { allowed: false, reason: 'No Budget' };
            }
            
            // Check if already at ceiling
            if (player.trainingSkills[skillName] >= player.talentCeiling[skillName]) {
                return { allowed: false, reason: 'Max Level' };
            }
            
            // Check if already training this skill
            if (player.trainingQueue.some(training => training.skill === skillName)) {
                return { allowed: false, reason: 'Training' };
            }
            
            // Check if player is injured
            if (player.isInjured) {
                return { allowed: false, reason: 'Injured' };
            }
            
            return { allowed: true };
        }
        
        // Start training a skill
        function startTraining(skillName) {
            const selector = document.getElementById('training-player-selector');
            const playerIndex = parseInt(selector.value);
            
            if (isNaN(playerIndex)) {
                showCustomAlert('Please select a player first!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            const cost = calculateTrainingCost(player, skillName);
            const canTrain = canPlayerTrain(player, skillName, cost);
            
            if (!canTrain.allowed) {
                showCustomAlert(`Cannot train this skill: ${canTrain.reason}`);
                return;
            }
            
            // Confirm training
            showTrainingConfirmDialog(player, skillName, cost);
        }
        
        // Show training confirmation dialog
        function showTrainingConfirmDialog(player, skillName, cost) {
            const skillNames = {
                'battingDefense': 'Batting Defense',
                'battingAggression': 'Batting Aggression', 
                'battingConsistency': 'Batting Consistency',
                'bowlingDefense': 'Bowling Defense',
                'bowlingAggression': 'Bowling Aggression',
                'bowlingConsistency': 'Bowling Consistency',
                'fieldingCatching': 'Fielding - Catching',
                'fieldingAgility': 'Fielding - Agility',
                'wicketKeeping': 'Wicket-Keeping',
                'captaincy': 'Captaincy'
            };
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <h3 class="text-lg font-bold mb-4">Confirm Training</h3>
                    <div class="mb-4">
                        <p><strong>Player:</strong> ${player.name}</p>
                        <p><strong>Skill:</strong> ${skillNames[skillName]}</p>
                        <p><strong>Cost:</strong> $${cost}</p>
                        <p><strong>Difficulty:</strong> ${player.trainingDifficulty[skillName]}</p>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">
                            Training will take effect after 2-3 games.
                        </p>
                    </div>
                    <div class="flex justify-end space-x-3">
                        <button class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded" onclick="this.closest('.fixed').remove()">
                            Cancel
                        </button>
                        <button class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded" onclick="confirmTraining('${skillName}', ${cost}); this.closest('.fixed').remove();">
                            Confirm
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // Confirm and process training
        function confirmTraining(skillName, cost) {
            const selector = document.getElementById('training-player-selector');
            const playerIndex = parseInt(selector.value);
            const player = gameState.players[playerIndex];
            
            // Deduct cost
            gameState.budget -= cost;
            document.getElementById('budget').textContent = gameState.budget;
            
            // Add to training queue
            const gamesUntilComplete = Math.floor(Math.random() * 2) + 2; // 2-3 games
            const trainingItem = {
                skill: skillName,
                gamesRemaining: gamesUntilComplete,
                improvement: calculateTrainingImprovement(player, skillName)
            };
            
            player.trainingQueue.push(trainingItem);
            
            // Increase cost for next training of this skill
            player.trainingCosts[skillName] = Math.floor(player.trainingCosts[skillName] * 1.5);
            
            // Update UI
            showTrainingPanel(player);
            
            showCustomAlert(`${player.name} has started training! Progress will be visible after ${gamesUntilComplete} games.`);
        }
        
        // Calculate training improvement amount
        function calculateTrainingImprovement(player, skillName) {
            const difficulty = player.trainingDifficulty[skillName];
            const currentSkill = player.trainingSkills[skillName];
            const ceiling = player.talentCeiling[skillName];
            
            let baseImprovement = 5; // Base improvement points
            
            // Adjust by difficulty
            if (difficulty === 'easy') {
                baseImprovement = 7;
            } else if (difficulty === 'hard') {
                baseImprovement = 3;
            }
            
            // Diminishing returns as you get closer to ceiling
            const progress = currentSkill / ceiling;
            if (progress > 0.8) {
                baseImprovement = Math.floor(baseImprovement * 0.5); // 50% improvement near ceiling
            } else if (progress > 0.6) {
                baseImprovement = Math.floor(baseImprovement * 0.75); // 75% improvement when advanced
            }
            
            // Add some randomness (¬±2 points)
            const randomVariation = Math.floor(Math.random() * 5) - 2; // -2 to +2
            
            return Math.max(1, baseImprovement + randomVariation); // Minimum 1 point improvement
        }
        
        // Update training queue display
        function updateTrainingQueue(player) {
            const queueSection = document.getElementById('training-queue-section');
            const queueList = document.getElementById('training-queue-list');
            
            if (player.trainingQueue.length === 0) {
                queueSection.style.display = 'none';
                return;
            }
            
            queueSection.style.display = 'block';
            
            const skillNames = {
                'battingDefense': 'Batting Defense',
                'battingAggression': 'Batting Aggression', 
                'battingConsistency': 'Batting Consistency',
                'bowlingDefense': 'Bowling Defense',
                'bowlingAggression': 'Bowling Aggression',
                'bowlingConsistency': 'Bowling Consistency',
                'fieldingCatching': 'Fielding - Catching',
                'fieldingAgility': 'Fielding - Agility',
                'wicketKeeping': 'Wicket-Keeping',
                'captaincy': 'Captaincy'
            };
            
            queueList.innerHTML = player.trainingQueue.map(training => {
                return `
                    <div class="flex justify-between items-center p-2 bg-green-50 dark:bg-green-900 rounded border">
                        <span class="font-medium">${skillNames[training.skill]}</span>
                        <span class="text-sm text-green-600 dark:text-green-400">
                            ${training.gamesRemaining} games remaining
                        </span>
                    </div>
                `;
            }).join('');
        }
        
        // Update specialist training sections
        function updateSpecialistTraining(player) {
            const wicketkeepingSection = document.getElementById('wicketkeeping-training');
            const captaincySection = document.getElementById('captaincy-training');
            const noSpecialistSection = document.getElementById('no-specialist-training');
            
            let hasSpecialistRole = false;
            
            if (player.isWicketKeeper) {
                wicketkeepingSection.style.display = 'block';
                hasSpecialistRole = true;
            } else {
                wicketkeepingSection.style.display = 'none';
            }
            
            if (player.isCaptain) {
                captaincySection.style.display = 'block';
                hasSpecialistRole = true;
            } else {
                captaincySection.style.display = 'none';
            }
            
            noSpecialistSection.style.display = hasSpecialistRole ? 'none' : 'block';
        }
        
        // Process training queue after each game
        function processTrainingQueue() {
            gameState.players.forEach(player => {
                if (player.trainingQueue.length > 0) {
                    player.trainingQueue.forEach((training, index) => {
                        training.gamesRemaining--;
                        
                        if (training.gamesRemaining <= 0) {
                            // Apply training improvement
                            const currentSkill = player.trainingSkills[training.skill];
                            const newSkill = Math.min(
                                currentSkill + training.improvement,
                                player.talentCeiling[training.skill]
                            );
                            
                            player.trainingSkills[training.skill] = newSkill;
                            
                            // Show improvement notification
                            showTrainingCompleteNotification(player, training.skill, training.improvement);
                            
                            // Remove from queue
                            player.trainingQueue.splice(index, 1);
                        }
                    });
                }
            });
        }
        
        // Show training completion notification
        function showTrainingCompleteNotification(player, skillName, improvement) {
            const skillNames = {
                'battingDefense': 'Batting Defense',
                'battingAggression': 'Batting Aggression', 
                'battingConsistency': 'Batting Consistency',
                'bowlingDefense': 'Bowling Defense',
                'bowlingAggression': 'Bowling Aggression',
                'bowlingConsistency': 'Bowling Consistency',
                'fieldingCatching': 'Fielding - Catching',
                'fieldingAgility': 'Fielding - Agility',
                'wicketKeeping': 'Wicket-Keeping',
                'captaincy': 'Captaincy'
            };
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <div class="text-center">
                        <div class="text-4xl mb-4">üéØ</div>
                        <h3 class="text-lg font-bold mb-4">Training Complete!</h3>
                        <p class="mb-2"><strong>${player.name}</strong></p>
                        <p class="mb-2">${skillNames[skillName]} improved by <strong>+${improvement}</strong> points!</p>
                        <p class="text-sm text-gray-600 dark:text-gray-400">
                            This improvement will help in future matches.
                        </p>
                    </div>
                    <div class="flex justify-center mt-6">
                        <button class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded" onclick="this.closest('.fixed').remove()">
                            Great!
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Auto-close after 5 seconds
            setTimeout(() => {
                const stillExists = document.body.contains(modal);
                if (stillExists) {
                    modal.remove();
                }
            }, 5000);
        }
        
        // Initialize training system on load
        function initializeTrainingSystem() {
            populateTrainingSelector();
        }
        
        // Start the game
        initGame();
        
        // Initialize training system
        initializeTrainingSystem();
    </script>
</body>
</html>